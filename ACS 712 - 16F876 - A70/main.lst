CCS PCM C Compiler, Version 4.114, 93483988               23-abr-14 18:23

               Filename: D:\SkyDrive\Eletronica\PROJETOS PIC CCS\ACS 712 - 16F876 - A70\main.lst

               ROM used: 4261 words (52%)
                         Largest free fragment is 2048
               RAM used: 28 (8%) at main() level
                         60 (16%) worst case
               Stack:    6 worst case (5 in main + 1 for interrupts)

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   04E
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.5
001A:  GOTO   01D
001B:  BTFSC  0B.2
001C:  GOTO   030
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   27,W
0028:  MOVWF  7B
0029:  MOVF   20,W
002A:  MOVWF  0A
002B:  SWAPF  21,W
002C:  MOVWF  03
002D:  SWAPF  7F,F
002E:  SWAPF  7F,W
002F:  RETFIE
0030:  BCF    0A.3
0031:  BCF    0A.4
0032:  GOTO   63C
.................... #include <16F876.h> 
.................... //////// Standard Header file for the PIC16F876 device //////////////// 
.................... #device PIC16F876 
.................... #list 
....................  
.................... #device adc=10 
.................... #FUSES NOWDT, HS, NOPUT, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NODEBUG, NOPROTECT 
.................... #use delay(clock=16000000) 
*
066B:  MOVLW  36
066C:  MOVWF  04
066D:  BCF    03.7
066E:  MOVF   00,W
066F:  BTFSC  03.2
0670:  GOTO   67F
0671:  MOVLW  05
0672:  MOVWF  78
0673:  CLRF   77
0674:  DECFSZ 77,F
0675:  GOTO   674
0676:  DECFSZ 78,F
0677:  GOTO   673
0678:  MOVLW  2E
0679:  MOVWF  77
067A:  DECFSZ 77,F
067B:  GOTO   67A
067C:  GOTO   67D
067D:  DECFSZ 00,F
067E:  GOTO   671
067F:  BCF    0A.3
0680:  BSF    0A.4
0681:  GOTO   091 (RETURN)
....................  
.................... #include "driverA70.c" 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
105B:  BCF    03.5
105C:  CLRF   28
105D:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define sce       PIN_c0 // 
.................... #define rst       PIN_c1 //  
.................... #define dc        PIN_a5 //  
.................... #define sclk      PIN_c3 //  
.................... #define sda       PIN_c5 // 
....................  
.................... BYTE const font8x12[128][12] = { 
....................   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,        // sp        0x20 1 
....................   0x00,0x30,0x78,0x78,0x78,0x30,0x30,0x00,0x30,0x30,0x00,0x00,        // !         0x21 2 
....................   0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,        // "         0x22 3 
....................   0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,        // #         0x23 4 
....................   0x30,0x30,0x7C,0xC0,0xC0,0x78,0x0C,0x0C,0xF8,0x30,0x30,0x00,        // $         0x24 5 
....................   0x00,0x00,0x00,0xC4,0xCC,0x18,0x30,0x60,0xCC,0x8C,0x00,0x00,        // %         0x25 6 
....................   0x00,0x70,0xD8,0xD8,0x70,0xFA,0xDE,0xCC,0xDC,0x76,0x00,0x00,        // &         0x26 7 
....................   0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,        // Grad      0x27  
....................   0x00,0x0C,0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x0C,0x00,0x00,        // (         0x28 
....................   0x00,0x60,0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x60,0x00,0x00,        // )         0x29 
....................   0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,        // *         0x2A 
....................   0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,        // +         0x2B 
....................   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x60,0x00,        // ,         0x2C 
....................   0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,        // -         0x2D 
....................   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x00,0x00,        // .         0x2E 
....................   0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,        // /         0x2F  
....................   0x00,0x7C,0xC6,0xCE,0xDE,0xD6,0xF6,0xE6,0xC6,0x7C,0x00,0x00,        // 0         0x30 
....................   0x00,0x10,0x30,0xF0,0x30,0x30,0x30,0x30,0x30,0xFC,0x00,0x00,        // 1         0x31 
....................   0x00,0x78,0xCC,0xCC,0x0C,0x18,0x30,0x60,0xCC,0xFC,0x00,0x00,        // 2         0x32 
....................   0x00,0x78,0xCC,0x0C,0x0C,0x38,0x0C,0x0C,0xCC,0x78,0x00,0x00,        // 3         0x33 
....................   0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x1E,0x00,0x00,        // 4         0x34 
....................   0x00,0xFC,0xC0,0xC0,0xC0,0xF8,0x0C,0x0C,0xCC,0x78,0x00,0x00,        // 5         0x35 
....................   0x00,0x38,0x60,0xC0,0xC0,0xF8,0xCC,0xCC,0xCC,0x78,0x00,0x00,        // 6         0x36 
....................   0x00,0xFE,0xC6,0xC6,0x06,0x0C,0x18,0x30,0x30,0x30,0x00,0x00,        // 7         0x37 
....................   0x00,0x78,0xCC,0xCC,0xCC,0x78,0xCC,0xCC,0xCC,0x78,0x00,0x00,        // 8         0x38 
....................   0x00,0x78,0xCC,0xCC,0xCC,0x7C,0x18,0x18,0x30,0x70,0x00,0x00,        // 9         0x39 
....................   0x00,0x00,0x00,0x38,0x38,0x00,0x00,0x38,0x38,0x00,0x00,0x00,        // :         0x3A 
....................   0x00,0x00,0x00,0x38,0x38,0x00,0x00,0x38,0x38,0x18,0x30,0x00,        // ;         0x3B 
....................   0x00,0x0C,0x18,0x30,0x60,0xC0,0x60,0x30,0x18,0x0C,0x00,0x00,        // <         0x3C 
....................   0x00,0x00,0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,        // =         0x3D 
....................   0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,        // >         0x3E 
....................   0x00,0x78,0xCC,0x0C,0x18,0x30,0x30,0x00,0x30,0x30,0x00,0x00,        // ?         0x3F 
....................   0x00,0x7C,0xC6,0xC6,0xDE,0xDE,0xDE,0xC0,0xC0,0x7C,0x00,0x00,        // @         0x40 
....................   0x00,0x30,0x78,0xCC,0xCC,0xCC,0xFC,0xCC,0xCC,0xCC,0x00,0x00,        // A         0x41 
....................   0x00,0xFC,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0xFC,0x00,0x00,        // B         0x42 
....................   0x00,0x3C,0x66,0xC6,0xC0,0xC0,0xC0,0xC6,0x66,0x3C,0x00,0x00,        // C         0x43 
....................   0x00,0xF8,0x6C,0x66,0x66,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,        // D         0x44 
....................   0x00,0xFE,0x62,0x60,0x64,0x7C,0x64,0x60,0x62,0xFE,0x00,0x00,        // E         0x45 
....................   0x00,0xFE,0x66,0x62,0x64,0x7C,0x64,0x60,0x60,0xF0,0x00,0x00,        // F         0x46 
....................   0x00,0x3C,0x66,0xC6,0xC0,0xC0,0xCE,0xC6,0x66,0x3E,0x00,0x00,        // G         0x47 
....................   0x00,0xCC,0xCC,0xCC,0xCC,0xFC,0xCC,0xCC,0xCC,0xCC,0x00,0x00,        // H         0x48 
....................   0x00,0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x78,0x00,0x00,        // I         0x49 
....................   0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0xCC,0x78,0x00,0x00,        // J         0x4A 
....................   0x00,0xE6,0x66,0x6C,0x6C,0x78,0x6C,0x6C,0x66,0xE6,0x00,0x00,        // K         0x4B 
....................   0x00,0xF0,0x60,0x60,0x60,0x60,0x62,0x66,0x66,0xFE,0x00,0x00,        // L         0x4C 
....................   0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,        // M         0x4D 
....................   0x00,0xC6,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0x00,0x00,        // N         0x4E 
....................   0x00,0x38,0x6C,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00,0x00,        // O         0x4F 
....................   0x00,0xFC,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0xF0,0x00,0x00,        // P         0x50 
....................   0x00,0x38,0x6C,0xC6,0xC6,0xC6,0xCE,0xDE,0x7C,0x0C,0x1E,0x00,        // Q         0x51 
....................   0x00,0xFC,0x66,0x66,0x66,0x7C,0x6C,0x66,0x66,0xE6,0x00,0x00,        // R         0x52 
....................   0x00,0x78,0xCC,0xCC,0xC0,0x70,0x18,0xCC,0xCC,0x78,0x00,0x00,        // S         0x53 
....................   0x00,0xFC,0xB4,0x30,0x30,0x30,0x30,0x30,0x30,0x78,0x00,0x00,        // T         0x54 
....................   0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x78,0x00,0x00,        // U         0x55 
....................   0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x78,0x30,0x00,0x00,        // V         0x56 
....................   0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0x6C,0x6C,0x6C,0x00,0x00,        // W         0x57 
....................   0x00,0xCC,0xCC,0xCC,0x78,0x30,0x78,0xCC,0xCC,0xCC,0x00,0x00,        // X         0x58 
....................   0x00,0xCC,0xCC,0xCC,0xCC,0x78,0x30,0x30,0x30,0x78,0x00,0x00,        // Y         0x59 
....................   0x00,0xFE,0xCE,0x98,0x18,0x30,0x60,0x62,0xC6,0xFE,0x00,0x00,        // Z         0x5A 
....................   0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,        // [ -       0x5B 
....................   0x00,0x00,0x80,0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,0x00,        // backslash 0x5C 
....................   0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,        // ]         0x5D 
....................   0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,        // ^         0x5E 
....................   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,        // _         0x5F 
....................   0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,        // '         0x60 
....................   0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0x76,0x00,0x00,        // a         0x61 
....................   0x00,0xE0,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0xDC,0x00,0x00,        // b         0x62 
....................   0x00,0x00,0x00,0x00,0x78,0xCC,0xC0,0xC0,0xCC,0x78,0x00,0x00,        // c         0x63 
....................   0x00,0x1C,0x0C,0x0C,0x7C,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,        // d         0x64 
....................   0x00,0x00,0x00,0x00,0x78,0xCC,0xFC,0xC0,0xCC,0x78,0x00,0x00,        // e         0x65 
....................   0x00,0x38,0x6C,0x60,0x60,0xF8,0x60,0x60,0x60,0xF0,0x00,0x00,        // f         0x66 
....................   0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0x7C,0x0C,0xCC,0x78,        // g         0x67 
....................   0x00,0xE0,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0xE6,0x00,0x00,        // h         0x68 
....................   0x00,0x18,0x18,0x00,0x78,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,        // i         0x69 
....................   0x00,0x0C,0x0C,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,        // j         0x6A 
....................   0x00,0xE0,0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00,0x00,        // k         0x6B 
....................   0x00,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,        // l         0x6C 
....................   0x00,0x00,0x00,0x00,0xFC,0xD6,0xD6,0xD6,0xD6,0xC6,0x00,0x00,        // m         0x6D 
....................   0x00,0x00,0x00,0x00,0xF8,0xCC,0xCC,0xCC,0xCC,0xCC,0x00,0x00,        // n         0x6E 
....................   0x00,0x00,0x00,0x00,0x78,0xCC,0xCC,0xCC,0xCC,0x78,0x00,0x00,        // o         0x6F 
....................   0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x7C,0x60,0xF0,        // p         0x70 
....................   0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0x1E,        // q         0x71 
....................   0x00,0x00,0x00,0x00,0xEC,0x6E,0x76,0x60,0x60,0xF0,0x00,0x00,        // r         0x72 
....................   0x00,0x00,0x00,0x00,0x78,0xCC,0x60,0x18,0xCC,0x78,0x00,0x00,        // s         0x73 
....................   0x00,0x00,0x20,0x60,0xFC,0x60,0x60,0x60,0x6C,0x38,0x00,0x00,        // t         0x74 
....................   0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,        // u         0x75 
....................   0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0x78,0x30,0x00,0x00,        // v         0x76 
....................   0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0x6C,0x6C,0x00,0x00,        // w         0x77 
....................   0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x6C,0xC6,0x00,0x00,        // x         0x78 
....................   0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x0C,0x18,0xF0,        // y         0x79 
....................   0x00,0x00,0x00,0x00,0xFC,0x8C,0x18,0x60,0xC4,0xFC,0x00,0x00,        // z         0x7A 
....................   0x00,0x1C,0x30,0x30,0x60,0xC0,0x60,0x30,0x30,0x1C,0x00,0x00,        // {         0x7B 
....................   0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x00,0x00,        // |         0x7C 
....................   0x00,0xE0,0x30,0x30,0x18,0x0C,0x18,0x30,0x30,0xE0,0x00,0x00,        // }         0x7D 
....................   0x00,0x73,0xDA,0xCE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,        // ->        0x7E 
....................   0x00,0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0x00,0x00,0x00,        // <-        0x7F 
.................... }; 
....................  
.................... BYTE const font8x8[128][8] = { 
....................   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // Leerzeichen 0x20 32 0 
....................   0x00,0x00,0x00,0xF2,0xF2,0x00,0x00,0x00,  // ! 33 1 
....................   0x00,0xE0,0xE0,0x00,0x00,0xE0,0xE0,0x00,  // " 34 2 
....................   0x28,0xFE,0xFE,0x28,0x28,0xFE,0xFE,0x28,  // # 35 3 
....................   0x00,0x48,0x5C,0xD6,0xD6,0x74,0x24,0x00,  // $ 36 4  
....................   0x00,0xC6,0x66,0x30,0x18,0xCC,0xC6,0x00,  // % 37 5 
....................   0x0A,0x4E,0xEE,0xB2,0xB2,0xFE,0x4C,0x00,  // & 38 6 
....................   0x00,0x80,0xC0,0x60,0x20,0x00,0x00,0x00,  // ' 39 7 
....................   0x00,0x00,0x82,0xC6,0x7C,0x38,0x00,0x00,  // ( 40 8 
....................   0x00,0x00,0x38,0x7C,0xC6,0x82,0x00,0x00,  // ) 41 9 
....................   0x10,0x54,0x7C,0x38,0x38,0x7C,0x54,0x10,  // * 42 10 
....................   0x00,0x10,0x10,0x7C,0x7C,0x10,0x10,0x00,  // + 43 11 
....................   0x00,0x00,0x00,0x06,0x07,0x01,0x00,0x00,  // , 44 12 
....................   0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x00,  // - 45 13 
....................   0x00,0x00,0x00,0x06,0x06,0x00,0x00,0x00,  // . 46 14  
....................   0x40,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,  // / 47 15 
....................   0x00,0x7C,0xFE,0xA2,0x92,0xFE,0x7C,0x00,  // 0  0x30 48 16 
....................   0x00,0x02,0x02,0xFE,0xFE,0x22,0x02,0x00,  // 1 49 
....................   0x00,0x62,0xF2,0x92,0x8A,0xCE,0x46,0x00,  // 2 50 
....................   0x00,0x6C,0xFE,0x92,0x92,0xC6,0x44,0x00,  // 3 51 
....................   0x08,0xFE,0xFE,0x68,0x28,0x18,0x18,0x00,  // 4 52 
....................   0x00,0x9C,0xBE,0xA2,0xA2,0xE6,0xE4,0x00,  // 5 53 
....................   0x00,0x4C,0xDE,0x92,0x92,0xFE,0x7C,0x00,  // 6 54 
....................   0x00,0xC0,0xE0,0xBE,0x9E,0xC0,0xC0,0x00,  // 7 55 
....................   0x00,0x6C,0xFE,0x92,0x92,0xFE,0x6C,0x00,  // 8 56 
....................   0x00,0x7C,0xFE,0x92,0x92,0xF6,0x64,0x00,  // 9 57 
....................   0x00,0x00,0x00,0x24,0x24,0x00,0x00,0x00,  // : 58 
....................   0x00,0x00,0x00,0x26,0x27,0x01,0x00,0x00,  // ; 59 
....................   0x00,0x82,0x82,0xC6,0x6C,0x38,0x10,0x00,  // < 60 
....................   0x00,0x28,0x28,0x28,0x28,0x28,0x28,0x00,  // = 61 
....................   0x00,0x10,0x38,0x6C,0xC6,0x82,0x82,0x00,  // > 62 
....................   0x00,0x60,0xF0,0x9A,0x8A,0xC0,0x40,0x00,  // ? 63 até aqui subtrai 0x20  
....................   0x00,0x74,0xF2,0xB2,0x82,0xFE,0x7C,0x00,  // @ 64 
....................   0x00,0x3E,0x7E,0xD0,0xD0,0x7E,0x3E,0x00,  // A  0x41 65 
....................   0x00,0x6C,0xFE,0x92,0x92,0xFE,0xFE,0x00,  // B 66 
....................   0x00,0x44,0xC6,0x82,0x82,0xFE,0x7C,0x00,  // C 67 
....................   0x00,0x38,0x7C,0xC6,0x82,0xFE,0xFE,0x00,  // D 68 
....................   0x00,0x82,0x82,0x92,0x92,0xFE,0xFE,0x00,  // E 69 
....................   0x00,0x80,0x80,0x90,0x90,0xFE,0xFE,0x00,  // F 70 
....................   0x00,0x5C,0xDE,0x92,0x82,0xFE,0x7C,0x00,  // G 71 
....................   0x00,0xFE,0xFE,0x10,0x10,0xFE,0xFE,0x00,  // H 72 
....................   0x00,0x00,0x82,0xFE,0xFE,0x82,0x00,0x00,  // I 73 
....................   0x00,0x80,0xFC,0xFE,0x82,0x06,0x04,0x00,  // J 74 
....................   0x00,0x82,0xC6,0x6C,0x38,0xFE,0xFE,0x00,  // K 75 
....................   0x00,0x02,0x02,0x02,0x02,0xFE,0xFE,0x00,  // L 76 
....................   0xFE,0xFE,0x60,0x30,0x60,0xFE,0xFE,0x00,  // M 77 
....................   0x00,0xFE,0xFE,0x38,0x70,0xFE,0xFE,0x00,  // N 78 
....................   0x00,0x7C,0xFE,0x82,0x82,0xFE,0x7C,0x00,   // O 79 
....................  
....................   0x00,0x60,0xF0,0x90,0x90,0xFE,0xFE,0x00,  // P 80 
....................   0x00,0x7A,0xFE,0x86,0x84,0xFC,0x78,0x00,  // Q 81 
....................   0x00,0x62,0xF6,0x9C,0x98,0xFE,0xFE,0x00,  // R 82 
....................   0x00,0x4C,0xDE,0x92,0x92,0xF6,0x64,0x00,  // S 83 
....................   0x00,0x80,0x80,0xFE,0xFE,0x80,0x80,0x00,  // T 84 
....................   0x00,0xFC,0xFE,0x02,0x02,0xFE,0xFC,0x00,  // U 85 
....................   0x00,0xF8,0xFC,0x06,0x06,0xFC,0xF8,0x00,  // V 86 
....................   0xFE,0xFE,0x0C,0x18,0x0C,0xFE,0xFE,0x00,  // W 87 
....................   0x00,0xC6,0xEE,0x38,0x38,0xEE,0xC6,0x00,  // X 88 
....................   0x00,0xE0,0xF0,0x1E,0x1E,0xF0,0xE0,0x00,  // Y 89 
....................   0x00,0xC2,0xE2,0xB2,0x9A,0x8E,0x86,0x00,  // Z 90 
....................   0x00,0x00,0x82,0x82,0xFE,0xFE,0x00,0x00,  // [ 91 
....................   0x40,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,  // backslash 92 
....................   0x00,0x00,0xFE,0xFE,0x82,0x82,0x00,0x00,  // ] 93 
....................   0x00,0x80,0xC0,0x60,0x20,0x00,0x00,0x00,  // ^ 94 
....................   0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,  // _ 95 
....................   0x00,0x80,0xC0,0x60,0x20,0x00,0x00,0x00,  // ` 96 
....................   0x00,0x1E,0x3E,0x2A,0x2A,0x2E,0x04,0x00,  // a 97 
....................   0x00,0x0C,0x1E,0x12,0x12,0x7E,0x7E,0x00,  // b 98 
....................   0x00,0x00,0x22,0x22,0x22,0x3E,0x1C,0x00,  // c 99 
....................   0x00,0x7E,0x7E,0x12,0x12,0x1E,0x0C,0x00,  // d 100 
....................   0x00,0x18,0x3A,0x2A,0x2A,0x3E,0x1C,0x00,  // e 101 
....................   0x00,0x50,0x50,0x7E,0x3E,0x10,0x00,0x00,  // f 102 
....................   0x00,0x3E,0x3F,0x25,0x25,0x3D,0x19,0x00,  // g 103 
....................   0x00,0x0E,0x1E,0x10,0x10,0x7E,0x7E,0x00,  // h 104 
....................   0x00,0x00,0x02,0x5E,0x5E,0x12,0x00,0x00,  // i 105 
....................   0x00,0x5E,0x5F,0x01,0x01,0x01,0x00,0x00,  // j 106 
....................   0x00,0x02,0x16,0x1C,0x08,0x7E,0x7E,0x00,  // k 107 
....................   0x00,0x00,0x02,0x7E,0x7E,0x42,0x00,0x00,  // l 108 
....................   0x1E,0x3E,0x38,0x1C,0x18,0x3E,0x3E,0x00,  // m 109  
....................   0x00,0x1E,0x3E,0x20,0x20,0x3E,0x3E,0x00,  // n 110 
....................   0x00,0x1C,0x3E,0x22,0x22,0x3E,0x1C,0x00,  // o 111 
....................   0x00,0x18,0x3C,0x24,0x24,0x3F,0x3F,0x00,  // p 112 
....................   0x00,0x3F,0x3F,0x24,0x24,0x3C,0x18,0x00,  // q 113 
....................   0x00,0x10,0x30,0x20,0x20,0x3E,0x3E,0x00,  // r 114 
....................   0x00,0x24,0x2E,0x2A,0x2A,0x3A,0x12,0x00,  // s 115 
....................   0x00,0x22,0x22,0x7E,0x7C,0x20,0x20,0x00,  // t 116 
....................   0x00,0x3E,0x3E,0x02,0x02,0x3E,0x3C,0x00,  // u 117 
....................   0x00,0x38,0x3C,0x06,0x06,0x3C,0x38,0x00,  // v 118 
....................   0x38,0x3E,0x0E,0x1C,0x0E,0x3E,0x38,0x00,  // w 119 
....................   0x00,0x22,0x36,0x1C,0x1C,0x36,0x22,0x00,  // x 120 
....................   0x00,0x3C,0x3E,0x07,0x05,0x3D,0x39,0x00,  // y 121 
....................   0x00,0x22,0x32,0x3A,0x2E,0x26,0x22,0x00,  // z 122 
....................   0x00,0x00,0x82,0x82,0xFE,0xFE,0x00,0x00,  // ] 123 
....................   0x00,0x44,0x92,0x92,0x7A,0x3E,0x16,0x02,  // Pfund 124 
....................   0x00,0x00,0xFE,0xFE,0x82,0x82,0x00,0x00,  // [ 125 
....................   0x00,0x10,0x30,0x7F,0x7F,0x30,0x10,0x00,  // Pfeil hoch 126 
....................   0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00,  // Pfeil links 127 
.................... }; 
....................  
.................... BYTE const font5x8[128][5] =  { 
....................   0x00,0x00,0x00,0x00,0x00,   // 20 space  
....................   0x00,0x00,0x5f,0x00,0x00,   // 21 ! 
....................   0x00,0x07,0x00,0x07,0x00,   // 22 " 
....................   0x14,0x7f,0x14,0x7f,0x14,   // 23 # 
....................   0x24,0x2a,0x7f,0x2a,0x12,   // 24 $ 
....................   0x23,0x13,0x08,0x64,0x62,   // 25 % 
....................   0x36,0x49,0x55,0x22,0x50,   // 26 & 
....................   0x00,0x05,0x03,0x00,0x00,   // 27 ' 
....................   0x00,0x1c,0x22,0x41,0x00,   // 28 ( 
....................   0x00,0x41,0x22,0x1c,0x00,   // 29 ) 
....................   0x14,0x08,0x3e,0x08,0x14,   // 2a * 
....................   0x08,0x08,0x3e,0x08,0x08,   // 2b + 
....................   0x00,0x50,0x30,0x00,0x00,   // 2c , 
....................   0x08,0x08,0x08,0x08,0x08,   // 2d - 
....................   0x00,0x60,0x60,0x00,0x00,   // 2e . 
....................   0x20,0x10,0x08,0x04,0x02,   // 2f / 
....................   0x3e,0x51,0x49,0x45,0x3e,   // 30 0 
....................   0x00,0x42,0x7f,0x40,0x00,   // 31 1 
....................   0x42,0x61,0x51,0x49,0x46,   // 32 2 
....................   0x21,0x41,0x45,0x4b,0x31,   // 33 3 
....................   0x18,0x14,0x12,0x7f,0x10,   // 34 4 
....................   0x27,0x45,0x45,0x45,0x39,   // 35 5 
....................   0x3c,0x4a,0x49,0x49,0x30,   // 36 6 
....................   0x01,0x71,0x09,0x05,0x03,   // 37 7 
....................   0x36,0x49,0x49,0x49,0x36,   // 38 8 
....................   0x06,0x49,0x49,0x29,0x1e,   // 39 9 
....................   0x00,0x36,0x36,0x00,0x00,   // 3a : 
....................   0x00,0x56,0x36,0x00,0x00,   // 3b ; 
....................   0x08,0x14,0x22,0x41,0x00,   // 3c < 
....................   0x14,0x14,0x14,0x14,0x14,   // 3d = 
....................   0x00,0x41,0x22,0x14,0x08,   // 3e > 
....................   0x02,0x01,0x51,0x09,0x06,   // 3f ? 
....................   0x32,0x49,0x79,0x41,0x3e,   // 40 @ 
....................   0x7e,0x11,0x11,0x11,0x7e,   // 41 A 
....................   0x7f,0x49,0x49,0x49,0x36,   // 42 B 
....................   0x3e,0x41,0x41,0x41,0x22,   // 43 C 
....................   0x7f,0x41,0x41,0x22,0x1c,   // 44 D 
....................   0x7f,0x49,0x49,0x49,0x41,   // 45 E 
....................   0x7f,0x09,0x09,0x09,0x01,   // 46 F 
....................   0x3e,0x41,0x49,0x49,0x7a,   // 47 G 
....................   0x7f,0x08,0x08,0x08,0x7f,   // 48 H 
....................   0x00,0x41,0x7f,0x41,0x00,   // 49 I 
....................   0x20,0x40,0x41,0x3f,0x01,   // 4a J 
....................   0x7f,0x08,0x14,0x22,0x41,   // 4b K 
....................   0x7f,0x40,0x40,0x40,0x40,   // 4c L 
....................   0x7f,0x02,0x0c,0x02,0x7f,   // 4d M 
....................   0x7f,0x04,0x08,0x10,0x7f,   // 4e N 
....................   0x3e,0x41,0x41,0x41,0x3e,    // 4f O 
....................  
....................   0x7f,0x09,0x09,0x09,0x06,   // 50 P 
....................   0x3e,0x41,0x51,0x21,0x5e,   // 51 Q 
....................   0x7f,0x09,0x19,0x29,0x46,   // 52 R 
....................   0x46,0x49,0x49,0x49,0x31,   // 53 S 
....................   0x01,0x01,0x7f,0x01,0x01,   // 54 T 
....................   0x3f,0x40,0x40,0x40,0x3f,   // 55 U 
....................   0x1f,0x20,0x40,0x20,0x1f,   // 56 V 
....................   0x3f,0x40,0x38,0x40,0x3f,   // 57 W 
....................   0x63,0x14,0x08,0x14,0x63,   // 58 X 
....................   0x07,0x08,0x70,0x08,0x07,   // 59 Y 
....................   0x61,0x51,0x49,0x45,0x43,   // 5a Z 
....................   0x00,0x7f,0x41,0x41,0x00,   // 5b [ 
....................   0x02,0x04,0x08,0x10,0x20,   // 5c 
....................   0x00,0x41,0x41,0x7f,0x00,   // 5d 
....................   0x04,0x02,0x01,0x02,0x04,   // 5e 
....................   0x40,0x40,0x40,0x40,0x40,   // 5f 
....................   0x00,0x01,0x02,0x04,0x00,   // 60 
....................   0x20,0x54,0x54,0x54,0x78,   // 61 a 
....................   0x7f,0x48,0x44,0x44,0x38,   // 62 b 
....................   0x38,0x44,0x44,0x44,0x20,   // 63 c 
....................   0x38,0x44,0x44,0x48,0x7f,   // 64 d 
....................   0x38,0x54,0x54,0x54,0x18,   // 65 e 
....................   0x08,0x7e,0x09,0x01,0x02,   // 66 f 
....................   0x0c,0x52,0x52,0x52,0x3e,   // 67 g 
....................   0x7f,0x08,0x04,0x04,0x78,   // 68 h 
....................   0x00,0x44,0x7d,0x40,0x00,   // 69 i 
....................   0x20,0x40,0x44,0x3d,0x00,   // 6a j 
....................   0x7f,0x10,0x28,0x44,0x00,   // 6b k 
....................   0x00,0x41,0x7f,0x40,0x00,   // 6c l 
....................   0x7c,0x04,0x18,0x04,0x78,   // 6d m 
....................   0x7c,0x08,0x04,0x04,0x78,   // 6e n 
....................   0x38,0x44,0x44,0x44,0x38,   // 6f o 
....................   0x7c,0x14,0x14,0x14,0x08,   // 70 p 
....................   0x08,0x14,0x14,0x18,0x7c,   // 71 q 
....................   0x7c,0x08,0x04,0x04,0x08,   // 72 r 
....................   0x48,0x54,0x54,0x54,0x20,   // 73 s 
....................   0x04,0x3f,0x44,0x40,0x20,   // 74 t 
....................   0x3c,0x40,0x40,0x20,0x7c,   // 75 u 
....................   0x1c,0x20,0x40,0x20,0x1c,   // 76 v 
....................   0x3c,0x40,0x30,0x40,0x3c,   // 77 w 
....................   0x44,0x28,0x10,0x28,0x44,   // 78 x 
....................   0x0c,0x50,0x50,0x50,0x3c,   // 79 y 
....................   0x44,0x64,0x54,0x4c,0x44,   // 7a z 
....................   0x00,0x08,0x36,0x41,0x00,   // 7b 
....................   0x00,0x00,0x7f,0x00,0x00,   // 7c 
....................   0x00,0x41,0x36,0x08,0x00,   // 7d 
....................   0x10,0x08,0x08,0x10,0x08,   // 7e 
....................   0x78,0x46,0x41,0x46,0x78    // 7f 
.................... }; 
....................  
....................  
.................... void SendCommand(BYTE Command); 
.................... void WriteDisplay(BYTE Value); 
.................... void Reset_LCD(void); 
.................... void ClearDisplay(void); 
.................... void Init_LCD(void); 
.................... void GotoXRow(BYTE x, BYTE Row); 
.................... char invByte(char bt); 
.................... void printChar5x8(char cvar); 
.................... void printChar8x8(char cvar); 
.................... void printChar8x12(char cvar); 
....................  
.................... long i; 
.................... int XX = 0, YY = 0; 
....................  
.................... void lcd_write(char dados){ 
....................    spi_write(dados); 
*
0682:  MOVF   13,W
0683:  MOVF   55,W
0684:  MOVWF  13
0685:  BSF    03.5
0686:  RRF    14,W
0687:  BTFSS  03.0
0688:  GOTO   686
.................... } 
0689:  BCF    03.5
068A:  RETURN
....................  
.................... void Reset_LCD(void){ 
....................   delay_us(10); 
*
06AB:  MOVLW  0D
06AC:  MOVWF  77
06AD:  DECFSZ 77,F
06AE:  GOTO   6AD
....................   output_bit(sda, 0); 
06AF:  BCF    07.5
06B0:  BCF    2E.5
06B1:  MOVF   2E,W
06B2:  BSF    03.5
06B3:  MOVWF  07
....................   output_bit(sclk, 0); 
06B4:  BCF    03.5
06B5:  BCF    07.3
06B6:  BCF    2E.3
06B7:  MOVF   2E,W
06B8:  BSF    03.5
06B9:  MOVWF  07
....................   output_bit(dc, 0); 
06BA:  BCF    03.5
06BB:  BCF    05.5
06BC:  BSF    03.5
06BD:  BCF    05.5
....................   delay_us(10); 
06BE:  MOVLW  0D
06BF:  MOVWF  77
06C0:  DECFSZ 77,F
06C1:  GOTO   6C0
....................   output_bit(rst, 1); 
06C2:  BCF    03.5
06C3:  BSF    07.1
06C4:  BCF    2E.1
06C5:  MOVF   2E,W
06C6:  BSF    03.5
06C7:  MOVWF  07
....................   delay_us(10); 
06C8:  MOVLW  0D
06C9:  MOVWF  77
06CA:  DECFSZ 77,F
06CB:  GOTO   6CA
....................   output_bit(sce, 0); 
06CC:  BCF    03.5
06CD:  BCF    07.0
06CE:  BCF    2E.0
06CF:  MOVF   2E,W
06D0:  BSF    03.5
06D1:  MOVWF  07
....................   delay_us(10); 
06D2:  MOVLW  0D
06D3:  MOVWF  77
06D4:  DECFSZ 77,F
06D5:  GOTO   6D4
....................   output_bit(rst, 0); 
06D6:  BCF    03.5
06D7:  BCF    07.1
06D8:  BCF    2E.1
06D9:  MOVF   2E,W
06DA:  BSF    03.5
06DB:  MOVWF  07
....................   delay_us(10);   
06DC:  MOVLW  0D
06DD:  MOVWF  77
06DE:  DECFSZ 77,F
06DF:  GOTO   6DE
....................   output_bit(rst, 1); 
06E0:  BCF    03.5
06E1:  BSF    07.1
06E2:  BCF    2E.1
06E3:  MOVF   2E,W
06E4:  BSF    03.5
06E5:  MOVWF  07
....................   output_bit(sce, 1); 
06E6:  BCF    03.5
06E7:  BSF    07.0
06E8:  BCF    2E.0
06E9:  MOVF   2E,W
06EA:  BSF    03.5
06EB:  MOVWF  07
.................... } 
....................  
.................... void Init_LCD(void){ 
....................   Reset_LCD(); 
....................   SendCommand(0x21);  // Function set: extended instruction set 
06EC:  MOVLW  21
06ED:  BCF    03.5
06EE:  MOVWF  54
06EF:  CALL   68B
....................   SendCommand(0x14);  // Bias System 
06F0:  MOVLW  14
06F1:  MOVWF  54
06F2:  CALL   68B
....................   SendCommand(0x0A);  // HV-gen stages 
06F3:  MOVLW  0A
06F4:  MOVWF  54
06F5:  CALL   68B
....................   SendCommand(0x05);  // Temperature Control 
06F6:  MOVLW  05
06F7:  MOVWF  54
06F8:  CALL   68B
....................   SendCommand(0xCC);  // Contrast: 204 
06F9:  MOVLW  CC
06FA:  MOVWF  54
06FB:  CALL   68B
....................   SendCommand(0x20);  // Function set: standard instruction set 
06FC:  MOVLW  20
06FD:  MOVWF  54
06FE:  CALL   68B
....................   SendCommand(0x11);  // VLCD programming range: high 
06FF:  MOVLW  11
0700:  MOVWF  54
0701:  CALL   68B
....................   SendCommand(0x0C);  // Display control: normal (inverted = 0x0D) 
0702:  MOVLW  0C
0703:  MOVWF  54
0704:  CALL   68B
....................    
.................... }    
0705:  BCF    0A.3
0706:  BSF    0A.4
0707:  GOTO   096 (RETURN)
....................  
.................... void ClearDisplay(void){ 
....................   GotoXRow(0,7); 
*
073A:  CLRF   51
073B:  MOVLW  07
073C:  MOVWF  52
073D:  CALL   708
....................   for (i=0; i<815; i++){ // eigentlich 101*64/8 aber Display-SOC  
073E:  CLRF   2B
073F:  CLRF   2A
0740:  MOVF   2B,W
0741:  SUBLW  03
0742:  BTFSS  03.0
0743:  GOTO   750
0744:  BTFSS  03.2
0745:  GOTO   74A
0746:  MOVF   2A,W
0747:  SUBLW  2E
0748:  BTFSS  03.0
0749:  GOTO   750
....................      WriteDisplay(0x00);                                  // unterstützt 0..101, also 102 Spalten pro Zeile  
074A:  CLRF   51
074B:  CALL   71A
....................   }                  // es sind aber nur 101 Spalten vorhanden! 
074C:  INCF   2A,F
074D:  BTFSC  03.2
074E:  INCF   2B,F
074F:  GOTO   740
.................... } 
0750:  BCF    0A.3
0751:  BSF    0A.4
0752:  GOTO   099 (RETURN)
....................  
.................... void GotoXRow(BYTE x, BYTE Row){ // x: 0..101, Row 0..7; 
....................   SendCommand( 0b00101000); 
*
0708:  MOVLW  28
0709:  MOVWF  54
070A:  CALL   68B
....................   SendCommand((0b01000000 + 7 - Row)); 
070B:  MOVF   52,W
070C:  SUBLW  47
070D:  MOVWF  53
070E:  MOVWF  54
070F:  CALL   68B
....................   SendCommand((0b10000000 + x )); 
0710:  MOVLW  80
0711:  ADDWF  51,W
0712:  MOVWF  53
0713:  MOVWF  54
0714:  CALL   68B
....................   XX = x; 
0715:  MOVF   51,W
0716:  MOVWF  2C
....................   YY = Row; 
0717:  MOVF   52,W
0718:  MOVWF  2D
....................   /*YY = 7 - Row; 
....................   XX = x;*/ 
.................... } 
0719:  RETURN
....................  
.................... void SendCommand(BYTE Command){ 
....................   output_bit(sda, 0); 
*
068B:  BCF    07.5
068C:  BCF    2E.5
068D:  MOVF   2E,W
068E:  BSF    03.5
068F:  MOVWF  07
....................   output_bit(sclk, 0); 
0690:  BCF    03.5
0691:  BCF    07.3
0692:  BCF    2E.3
0693:  MOVF   2E,W
0694:  BSF    03.5
0695:  MOVWF  07
....................   output_bit(dc, 0); 
0696:  BCF    03.5
0697:  BCF    05.5
0698:  BSF    03.5
0699:  BCF    05.5
....................   output_bit(sce, 0); 
069A:  BCF    03.5
069B:  BCF    07.0
069C:  BCF    2E.0
069D:  MOVF   2E,W
069E:  BSF    03.5
069F:  MOVWF  07
....................    
....................   lcd_write(Command); 
06A0:  BCF    03.5
06A1:  MOVF   54,W
06A2:  MOVWF  55
06A3:  CALL   682
....................    
....................   output_bit(sce, 1); 
06A4:  BSF    07.0
06A5:  BCF    2E.0
06A6:  MOVF   2E,W
06A7:  BSF    03.5
06A8:  MOVWF  07
.................... } 
06A9:  BCF    03.5
06AA:  RETURN
.................... void WriteDisplay(BYTE Value){           
....................   output_bit(sda, 0); 
*
071A:  BCF    07.5
071B:  BCF    2E.5
071C:  MOVF   2E,W
071D:  BSF    03.5
071E:  MOVWF  07
....................   output_bit(sclk, 0); 
071F:  BCF    03.5
0720:  BCF    07.3
0721:  BCF    2E.3
0722:  MOVF   2E,W
0723:  BSF    03.5
0724:  MOVWF  07
....................   output_bit(dc, 1); 
0725:  BCF    03.5
0726:  BSF    05.5
0727:  BSF    03.5
0728:  BCF    05.5
....................   output_bit(sce, 0); 
0729:  BCF    03.5
072A:  BCF    07.0
072B:  BCF    2E.0
072C:  MOVF   2E,W
072D:  BSF    03.5
072E:  MOVWF  07
....................  
....................   lcd_write(Value); 
072F:  BCF    03.5
0730:  MOVF   51,W
0731:  MOVWF  55
0732:  CALL   682
....................   output_bit(sce, 1); 
0733:  BSF    07.0
0734:  BCF    2E.0
0735:  MOVF   2E,W
0736:  BSF    03.5
0737:  MOVWF  07
....................   /*XX++; 
....................   if(XX > 101){ 
....................       XX = 0; 
....................       YY++; 
....................       if(YY > 7) 
....................          YY = 0; 
....................   }*/ 
.................... } 
0738:  BCF    03.5
0739:  RETURN
....................  
.................... void printChar5x8(char cvar){ 
....................   int i; 
....................   char c; 
....................   if ((cvar<0x20) || (cvar>0x7F)) return; 
*
0EDC:  MOVF   38,W
0EDD:  SUBLW  1F
0EDE:  BTFSC  03.0
0EDF:  GOTO   6E3
0EE0:  MOVF   38,W
0EE1:  SUBLW  7F
0EE2:  BTFSS  03.0
0EE3:  GOTO   716
....................   for (i=0;i<5;i++){ 
0EE4:  CLRF   39
0EE5:  MOVF   39,W
0EE6:  SUBLW  04
0EE7:  BTFSS  03.0
0EE8:  GOTO   712
....................     c=font5x8[((cvar&0xff)-0x20)][i]; 
0EE9:  MOVF   38,W
0EEA:  ADDLW  E0
0EEB:  MOVWF  3C
0EEC:  CLRF   51
0EED:  MOVF   3C,W
0EEE:  MOVWF  50
0EEF:  CLRF   53
0EF0:  MOVLW  05
0EF1:  MOVWF  52
0EF2:  BCF    0A.3
0EF3:  CALL   753
0EF4:  BSF    0A.3
0EF5:  MOVF   79,W
0EF6:  MOVWF  3C
0EF7:  MOVF   78,W
0EF8:  MOVWF  3B
0EF9:  MOVF   39,W
0EFA:  ADDWF  78,W
0EFB:  MOVWF  78
0EFC:  MOVF   79,W
0EFD:  MOVWF  7A
0EFE:  BTFSC  03.0
0EFF:  INCF   7A,F
0F00:  MOVF   78,W
0F01:  CALL   409
0F02:  MOVWF  78
0F03:  MOVWF  3A
....................     if((c!=0x00) || (cvar==0x20))      
0F04:  MOVF   3A,F
0F05:  BTFSS  03.2
0F06:  GOTO   70B
0F07:  MOVF   38,W
0F08:  SUBLW  20
0F09:  BTFSS  03.2
0F0A:  GOTO   710
....................        WriteDisplay(c); 
0F0B:  MOVF   3A,W
0F0C:  MOVWF  51
0F0D:  BCF    0A.3
0F0E:  CALL   71A
0F0F:  BSF    0A.3
....................   } 
0F10:  INCF   39,F
0F11:  GOTO   6E5
....................   WriteDisplay(0x00); 
0F12:  CLRF   51
0F13:  BCF    0A.3
0F14:  CALL   71A
0F15:  BSF    0A.3
.................... } 
0F16:  RETURN
....................  
.................... void printChar8x8(char cvar){ 
*
0F5F:  CLRF   3A
0F60:  CLRF   3C
0F61:  CLRF   3B
....................    BYTE i; 
....................    char c = 0x00; 
....................    long pos = 0; 
....................    if ((cvar<0x20) || (cvar>0x7F)) return; 
0F62:  MOVF   38,W
0F63:  SUBLW  1F
0F64:  BTFSC  03.0
0F65:  GOTO   769
0F66:  MOVF   38,W
0F67:  SUBLW  7F
0F68:  BTFSS  03.0
0F69:  GOTO   7C0
....................    pos = cvar-0x20;    
0F6A:  MOVLW  20
0F6B:  SUBWF  38,W
0F6C:  MOVWF  3B
0F6D:  CLRF   3C
....................    for (i=0;i<8;i++){ 
0F6E:  CLRF   39
0F6F:  MOVF   39,W
0F70:  SUBLW  07
0F71:  BTFSS  03.0
0F72:  GOTO   7BC
....................       c=font8x8[pos][(7-i)]; 
0F73:  RLF    3B,W
0F74:  MOVWF  3D
0F75:  RLF    3C,W
0F76:  MOVWF  3E
0F77:  RLF    3D,F
0F78:  RLF    3E,F
0F79:  RLF    3D,F
0F7A:  RLF    3E,F
0F7B:  MOVLW  F8
0F7C:  ANDWF  3D,F
0F7D:  MOVF   39,W
0F7E:  SUBLW  07
0F7F:  ADDWF  3D,W
0F80:  MOVWF  78
0F81:  MOVF   3E,W
0F82:  MOVWF  7A
0F83:  BTFSC  03.0
0F84:  INCF   7A,F
0F85:  MOVF   78,W
0F86:  CALL   000
0F87:  MOVWF  78
0F88:  MOVWF  3A
....................       /*if((c!=0x00) || (cvar==0x20)){       
....................          WriteDisplay(invByte(c));   
....................       }*/ 
....................       if((c!=0x00) || (cvar==0x20) && (i<3)){       
0F89:  MOVF   3A,F
0F8A:  BTFSS  03.2
0F8B:  GOTO   794
0F8C:  MOVF   38,W
0F8D:  SUBLW  20
0F8E:  BTFSS  03.2
0F8F:  GOTO   7BA
0F90:  MOVF   39,W
0F91:  SUBLW  02
0F92:  BTFSS  03.0
0F93:  GOTO   7BA
....................          WriteDisplay(invByte(c));   
0F94:  MOVF   3A,W
0F95:  MOVWF  3D
*
0FB4:  MOVF   78,W
0FB5:  MOVWF  3D
0FB6:  MOVWF  51
0FB7:  BCF    0A.3
0FB8:  CALL   71A
0FB9:  BSF    0A.3
....................       }       
....................    } 
0FBA:  INCF   39,F
0FBB:  GOTO   76F
....................    WriteDisplay(0x00);   
0FBC:  CLRF   51
0FBD:  BCF    0A.3
0FBE:  CALL   71A
0FBF:  BSF    0A.3
.................... } 
0FC0:  RETURN
....................  
.................... char invByte(char bt){    // Essa função é necessária para inverter os bits da maneira correta ex: 1100 0000 = 0000 0011 
*
0F96:  CLRF   3E
0F97:  MOVLW  80
0F98:  MOVWF  3F
0F99:  MOVLW  01
0F9A:  MOVWF  40
....................    char btInvert = 0x00; 
....................    Byte bitTest = 0x80, bitset = 0x01; 
....................    for(i=0;i<8;i++){ 
0F9B:  CLRF   2B
0F9C:  CLRF   2A
0F9D:  MOVF   2B,F
0F9E:  BTFSS  03.2
0F9F:  GOTO   7B2
0FA0:  MOVF   2A,W
0FA1:  SUBLW  07
0FA2:  BTFSS  03.0
0FA3:  GOTO   7B2
....................       if((bt&bitTest) != 0) 
0FA4:  MOVF   3D,W
0FA5:  ANDWF  3F,W
0FA6:  BTFSC  03.2
0FA7:  GOTO   7AA
....................          btInvert |= bitset;  
0FA8:  MOVF   40,W
0FA9:  IORWF  3E,F
....................       bitTest>>=1; 
0FAA:  BCF    03.0
0FAB:  RRF    3F,F
....................       bitset<<=1; 
0FAC:  BCF    03.0
0FAD:  RLF    40,F
....................    } 
0FAE:  INCF   2A,F
0FAF:  BTFSC  03.2
0FB0:  INCF   2B,F
0FB1:  GOTO   79D
....................    return btInvert;    
0FB2:  MOVF   3E,W
0FB3:  MOVWF  78
.................... } 
....................  
.................... void printChar8x12(char cvar){ 
*
0768:  CLRF   3B
0769:  CLRF   3D
076A:  CLRF   3C
*
077B:  MOVLW  80
077C:  MOVWF  4E
077D:  MOVLW  01
077E:  MOVWF  4F
....................    int i, j, inc = 0; 
....................    long pos = 0; 
....................    char c[16] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; 
*
076B:  CLRF   3E
076C:  CLRF   3F
076D:  CLRF   40
076E:  CLRF   41
076F:  CLRF   42
0770:  CLRF   43
0771:  CLRF   44
0772:  CLRF   45
0773:  CLRF   46
0774:  CLRF   47
0775:  CLRF   48
0776:  CLRF   49
0777:  CLRF   4A
0778:  CLRF   4B
0779:  CLRF   4C
077A:  CLRF   4D
....................    
....................    Byte bitTest = 0x80, bitset = 0x01; 
....................  
....................    if ((cvar<0x20) || (cvar>0x7F)) return; 
*
077F:  MOVF   38,W
0780:  SUBLW  1F
0781:  BTFSC  03.0
0782:  GOTO   786
0783:  MOVF   38,W
0784:  SUBLW  7F
0785:  BTFSS  03.0
0786:  GOTO   7FB
....................    pos = cvar-0x20; 
0787:  MOVLW  20
0788:  SUBWF  38,W
0789:  MOVWF  3C
078A:  CLRF   3D
....................    for(i=0;i<12;i++){ 
078B:  CLRF   39
078C:  MOVF   39,W
078D:  SUBLW  0B
078E:  BTFSS  03.0
078F:  GOTO   7C7
....................       for(j=0;j<8;j++){       
0790:  CLRF   3A
0791:  MOVF   3A,W
0792:  SUBLW  07
0793:  BTFSS  03.0
0794:  GOTO   7B9
....................         if((font8x12[pos][i]&bitTest) != 0) 
0795:  MOVF   3D,W
0796:  MOVWF  51
0797:  MOVF   3C,W
0798:  MOVWF  50
0799:  CLRF   53
079A:  MOVLW  0C
079B:  MOVWF  52
079C:  CALL   753
079D:  MOVF   79,W
079E:  MOVWF  51
079F:  MOVF   78,W
07A0:  MOVWF  50
07A1:  MOVF   39,W
07A2:  ADDWF  50,W
07A3:  MOVWF  78
07A4:  MOVF   51,W
07A5:  MOVWF  7A
07A6:  BTFSC  03.0
07A7:  INCF   7A,F
07A8:  MOVF   78,W
07A9:  CALL   033
07AA:  ANDWF  4E,W
07AB:  BTFSC  03.2
07AC:  GOTO   7B5
....................           c[j+inc] |= bitset; 
07AD:  MOVF   3B,W
07AE:  ADDWF  3A,W
07AF:  ADDLW  3E
07B0:  MOVWF  04
07B1:  BCF    03.7
07B2:  MOVF   00,W
07B3:  IORWF  4F,W
07B4:  MOVWF  00
....................         bitTest>>=1; 
07B5:  BCF    03.0
07B6:  RRF    4E,F
....................       } 
07B7:  INCF   3A,F
07B8:  GOTO   791
....................       bitTest = 0x80; 
07B9:  MOVLW  80
07BA:  MOVWF  4E
....................       bitset<<=1; 
07BB:  BCF    03.0
07BC:  RLF    4F,F
....................       if(i==7){ 
07BD:  MOVF   39,W
07BE:  SUBLW  07
07BF:  BTFSS  03.2
07C0:  GOTO   7C5
....................          inc=8; 
07C1:  MOVLW  08
07C2:  MOVWF  3B
....................          bitset = 0x01;          
07C3:  MOVLW  01
07C4:  MOVWF  4F
....................       }       
....................    } 
07C5:  INCF   39,F
07C6:  GOTO   78C
....................    for(i=0;i<8;i++){ 
07C7:  CLRF   39
07C8:  MOVF   39,W
07C9:  SUBLW  07
07CA:  BTFSS  03.0
07CB:  GOTO   7D6
....................      // if(((c[i]!=0x00) && (c[i+8]!=0x00)) || (cvar==0x20)) 
....................          WriteDisplay(c[i]); 
07CC:  MOVLW  3E
07CD:  ADDWF  39,W
07CE:  MOVWF  04
07CF:  BCF    03.7
07D0:  MOVF   00,W
07D1:  MOVWF  50
07D2:  MOVWF  51
07D3:  CALL   71A
....................    } 
07D4:  INCF   39,F
07D5:  GOTO   7C8
....................    WriteDisplay(0x00);    
07D6:  CLRF   51
07D7:  CALL   71A
....................    GotoXRow(XX,YY+1); 
07D8:  MOVLW  01
07D9:  ADDWF  2D,W
07DA:  MOVWF  50
07DB:  MOVF   2C,W
07DC:  MOVWF  51
07DD:  MOVF   50,W
07DE:  MOVWF  52
07DF:  CALL   708
....................    for(i=0;i<8;i++){ 
07E0:  CLRF   39
07E1:  MOVF   39,W
07E2:  SUBLW  07
07E3:  BTFSS  03.0
07E4:  GOTO   7F1
....................       //if(((c[i]!=0x00) && (c[i+8]!=0x00)) || (cvar==0x20)){     
....................          WriteDisplay(c[i+8]);  
07E5:  MOVLW  08
07E6:  ADDWF  39,W
07E7:  ADDLW  3E
07E8:  MOVWF  04
07E9:  BCF    03.7
07EA:  MOVF   00,W
07EB:  MOVWF  50
07EC:  MOVWF  51
07ED:  CALL   71A
....................       //} 
....................          XX++;  
07EE:  INCF   2C,F
....................    } 
07EF:  INCF   39,F
07F0:  GOTO   7E1
....................    WriteDisplay(0x00); 
07F1:  CLRF   51
07F2:  CALL   71A
....................    GotoXRow(XX,YY-1);    
07F3:  MOVLW  01
07F4:  SUBWF  2D,W
07F5:  MOVWF  50
07F6:  MOVF   2C,W
07F7:  MOVWF  51
07F8:  MOVF   50,W
07F9:  MOVWF  52
07FA:  CALL   708
.................... } 
07FB:  RETURN
....................  
....................  
....................  
.................... #define LED_STATUS   pin_a1 
.................... #define SPI_MODE_0  (SPI_L_TO_H | SPI_XMIT_L_TO_H) 
.................... #define SPI_MODE_1  (SPI_L_TO_H) 
.................... #define SPI_MODE_2  (SPI_H_TO_L) 
.................... #define SPI_MODE_3  (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... int tempo; 
....................  
.................... #int_TIMER0 
.................... void  TIMER0_isr(void){ 
....................    tempo++; 
*
063C:  INCF   2F,F
....................    if(tempo == 45){   //  46 * 21,8ms =~ 1002,8ms ou 1,002 segundos  
063D:  MOVF   2F,W
063E:  SUBLW  2D
063F:  BTFSS  03.2
0640:  GOTO   647
....................       tempo=0; 
0641:  CLRF   2F
....................       output_toggle(LED_STATUS); 
0642:  BSF    03.5
0643:  BCF    05.1
0644:  MOVLW  02
0645:  BCF    03.5
0646:  XORWF  05,F
....................    } 
.................... } 
0647:  BCF    0B.2
0648:  BCF    0A.3
0649:  BCF    0A.4
064A:  GOTO   01D
.................... void main(){ 
*
104E:  CLRF   04
104F:  BCF    03.7
1050:  MOVLW  1F
1051:  ANDWF  03,F
1052:  CLRF   2C
1053:  CLRF   2D
1054:  MOVLW  FF
1055:  MOVWF  2E
1056:  BSF    03.5
1057:  BSF    1F.0
1058:  BSF    1F.1
1059:  BSF    1F.2
105A:  BCF    1F.3
....................    double amp; 
....................    int i;   
....................    setup_spi(SPI_MASTER | SPI_MODE_0 | SPI_CLK_DIV_16);    
*
105E:  BCF    14.5
105F:  BCF    2E.5
1060:  MOVF   2E,W
1061:  BSF    03.5
1062:  MOVWF  07
1063:  BCF    03.5
1064:  BSF    2E.4
1065:  MOVF   2E,W
1066:  BSF    03.5
1067:  MOVWF  07
1068:  BCF    03.5
1069:  BCF    2E.3
106A:  MOVF   2E,W
106B:  BSF    03.5
106C:  MOVWF  07
106D:  MOVLW  21
106E:  BCF    03.5
106F:  MOVWF  14
1070:  MOVLW  40
1071:  BSF    03.5
1072:  MOVWF  14
....................    //setup_spi(SPI_SS_DISABLED); 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //21.8 ms overflow 
1073:  MOVF   01,W
1074:  ANDLW  C0
1075:  IORLW  07
1076:  MOVWF  01
....................    setup_adc_ports(AN0_VREF_VREF); 
1077:  BSF    1F.0
1078:  BSF    1F.1
1079:  BSF    1F.2
107A:  BSF    1F.3
....................    setup_adc(ADC_CLOCK_DIV_32); 
107B:  BCF    03.5
107C:  BCF    1F.6
107D:  BSF    1F.7
107E:  BSF    03.5
107F:  BSF    1F.7
1080:  BCF    03.5
1081:  BSF    1F.0
....................    enable_interrupts(INT_TIMER0); 
1082:  BSF    0B.5
....................    enable_interrupts(GLOBAL); 
1083:  MOVLW  C0
1084:  IORWF  0B,F
....................    set_adc_channel(0);    
1085:  MOVLW  00
1086:  MOVWF  78
1087:  MOVF   1F,W
1088:  ANDLW  C7
1089:  IORWF  78,W
108A:  MOVWF  1F
....................    delay_ms(500); 
108B:  MOVLW  02
108C:  MOVWF  35
108D:  MOVLW  FA
108E:  MOVWF  36
108F:  BCF    0A.4
1090:  GOTO   66B
1091:  BSF    0A.4
1092:  DECFSZ 35,F
1093:  GOTO   08D
....................    Init_LCD(); 
1094:  BCF    0A.4
1095:  GOTO   6AB
1096:  BSF    0A.4
....................    ClearDisplay(); 
1097:  BCF    0A.4
1098:  GOTO   73A
1099:  BSF    0A.4
....................    GotoXRow(0,0); 
109A:  CLRF   51
109B:  CLRF   52
109C:  BCF    0A.4
109D:  CALL   708
109E:  BSF    0A.4
....................    //PaintCharC64('z');  
....................    //printf(PaintCharC64, "012 3456789"); 
....................   
....................    printf(printChar8x12, "A70 PCF8812!"); 
109F:  MOVLW  4B
10A0:  BSF    03.6
10A1:  MOVWF  0D
10A2:  MOVLW  06
10A3:  MOVWF  0F
10A4:  BCF    0A.4
10A5:  BSF    0A.3
10A6:  BCF    03.6
10A7:  CALL   692
10A8:  BSF    0A.4
10A9:  BCF    0A.3
....................    GotoXRow(0,2); 
10AA:  CLRF   51
10AB:  MOVLW  02
10AC:  MOVWF  52
10AD:  BCF    0A.4
10AE:  CALL   708
10AF:  BSF    0A.4
....................    printf(printChar5x8, "Test Char 5x8"); 
10B0:  MOVLW  52
10B1:  BSF    03.6
10B2:  MOVWF  0D
10B3:  MOVLW  06
10B4:  MOVWF  0F
10B5:  BCF    0A.4
10B6:  BSF    0A.3
10B7:  BCF    03.6
10B8:  GOTO   717
10B9:  BSF    0A.4
10BA:  BCF    0A.3
....................    GotoXRow(0,3); 
10BB:  CLRF   51
10BC:  MOVLW  03
10BD:  MOVWF  52
10BE:  BCF    0A.4
10BF:  CALL   708
10C0:  BSF    0A.4
....................    printf(printChar8x8, "Char 8x8 Test"); 
10C1:  MOVLW  59
10C2:  BSF    03.6
10C3:  MOVWF  0D
10C4:  MOVLW  06
10C5:  MOVWF  0F
10C6:  BCF    03.6
10C7:  CALL   000
....................    GotoXRow(0,4); 
10C8:  CLRF   51
10C9:  MOVLW  04
10CA:  MOVWF  52
10CB:  BCF    0A.4
10CC:  CALL   708
10CD:  BSF    0A.4
....................    printf(printChar8x8, "Marlon test"); 
10CE:  MOVLW  60
10CF:  BSF    03.6
10D0:  MOVWF  0D
10D1:  MOVLW  06
10D2:  MOVWF  0F
10D3:  BCF    03.6
10D4:  CALL   000
....................    GotoXRow(0,6); 
10D5:  CLRF   51
10D6:  MOVLW  06
10D7:  MOVWF  52
10D8:  BCF    0A.4
10D9:  CALL   708
10DA:  BSF    0A.4
....................    printf(printChar8x12, "Char 8x12"); 
10DB:  MOVLW  66
10DC:  BSF    03.6
10DD:  MOVWF  0D
10DE:  MOVLW  06
10DF:  MOVWF  0F
10E0:  BCF    0A.4
10E1:  BSF    0A.3
10E2:  BCF    03.6
10E3:  CALL   692
10E4:  BSF    0A.4
10E5:  BCF    0A.3
....................    while(true){ 
....................       /*delay_ms(100); 
....................       GotoXRow(0,4); 
....................       printf(lcd_printChar, "    ADC: %Lu  ", read_adc()); 
....................       amp = read_adc()*0.0341; 
....................       GotoXRow(0,5); 
....................       printf(lcd_printChar, "  I: %1.4f   ", amp);*/ 
....................    } 
10E6:  GOTO   0E6
.................... } 
....................  
.................... //--------------------------------------------------------------------------------- 
10E7:  SLEEP

Configuration Fuses:
   Word  1: 3D3A   HS NOWDT NOPUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
