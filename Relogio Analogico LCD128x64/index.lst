CCS PCH C Compiler, Version 4.114, 93463165               11-jan-15 20:46

               Filename: D:\SkyDrive\Eletronica\PROJETOS PIC CCS\Relogio Analogico LCD128x64\index.lst

               ROM used: 13718 bytes (42%)
                         Largest free fragment is 19050
               RAM used: 1039 (51%) at main() level
                         1184 (58%) worst case
               Stack:    9 locations

*
0000:  GOTO   350A
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #use delay(clock=48000000) 
*
041E:  MOVLW  04
0420:  MOVWF  FEA
0422:  MOVLW  35
0424:  MOVWF  FE9
0426:  MOVF   FEF,W
0428:  BZ    0446
042A:  MOVLW  0F
042C:  MOVWF  01
042E:  CLRF   00
0430:  DECFSZ 00,F
0432:  BRA    0430
0434:  DECFSZ 01,F
0436:  BRA    042E
0438:  MOVLW  8F
043A:  MOVWF  00
043C:  DECFSZ 00,F
043E:  BRA    043C
0440:  NOP   
0442:  DECFSZ FEF,F
0444:  BRA    042A
0446:  RETLW  00
.................... //#fuses HS, PUT, NOWDT, NOBROWNOUT, NOLVP 
.................... #fuses HSPLL, PLL4, CPUDIV1, PUT, NOWDT, NOBROWNOUT, NOLVP 
.................... #include "DriverPE12864LRF.c" 
.................... // Driver teste para o LCD 128x64 (PowerTip PE12864LRF-004-H/* 
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x00, 0x41, 0x49, 0x49, 0x36, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x00, 0x27, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x00, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x7e, 0x00, // A      34 
....................                          0x7F, 0x49, 0x49, 0x36, 0x00, // B 
....................                          0x3E, 0x41, 0x41, 0x22, 0x00, // C 
....................                          0x7F, 0x41, 0x41, 0x3e, 0x00, // D      37 
....................                          0x7F, 0x49, 0x49, 0x41, 0x00, // E 
....................                          0x7F, 0x09, 0x09, 0x01, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x08, 0x7f, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x3f, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x3e, 0x00, // O 
....................                          0x7F, 0x09, 0x09, 0x06, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x09, 0x76, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x32, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x40, 0x3f, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x08, 0x04, 0x78, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x04, 0x78, 0x00, // n 
....................                          0x38, 0x44, 0x44, 0x38, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x00, 0x3c, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x3c, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... #define PE12864_A0    pin_A0 
.................... #define PE12864_RES   pin_A1 
.................... #define PE12864_CS1   pin_A2 
.................... #define PE12864_CLK   pin_B0 
.................... #define PE12864_DATA  pin_B1 
....................  
.................... #define ON   1 
.................... #define OFF  0 
....................  
.................... int8 CurrentLine = 0; 
.................... int8 QuantChrLine = 0; 
.................... int8 OffsetX = 0; 
.................... byte Buffer[128][8]; 
....................  
.................... void    PE12864_InitLcd(void); 
.................... void    PE12864_Write_command(char byte_command); 
.................... void    PE12864_Write_data(char byte_data); 
.................... void    PE12864_Gotoxy(int8 x, int y); 
.................... void    PE12864_Printchar(char cvar); 
.................... void    PE12864_PutPixel(int8 x,int8 y, int1 COLOR); 
.................... void    PE12864_SerialOut(char byteDC); 
.................... void    clear_screen(void); 
.................... void    newLine(void); 
.................... void    PE12864_circle(int x, int y, int radius, int1 fill, int1 COLOR); 
.................... void    PE12864_line(int x1, int y1, int x2, int y2, int1 COLOR); 
.................... //void    linexy(int8 x1,int8 y1,int8 x2,int8 y2, int1 COLOR); 
....................  
.................... void    PE12864_InitLcd(void){ 
....................     
....................    output_low(PE12864_CS1); // Chip Enabled 
*
0606:  BCF    F92.2
0608:  BCF    F89.2
....................    output_low(PE12864_RES); 
060A:  BCF    F92.1
060C:  BCF    F89.1
....................    delay_ms(5); 
060E:  MOVLW  05
0610:  MOVLB  4
0612:  MOVWF  x35
0614:  MOVLB  0
0616:  RCALL  041E
....................    output_high(PE12864_RES);    
0618:  BCF    F92.1
061A:  BSF    F89.1
....................  
....................    // LCD BIAS SET 
....................    //- PAG 45 - 1010001-BIT    0: 1/9 ou 1: 1/7 ST7565S 
....................    PE12864_Write_command(0xa2); 
061C:  MOVLW  A2
061E:  MOVLB  4
0620:  MOVWF  x62
0622:  MOVLB  0
0624:  RCALL  047E
....................    //1010011-BIT  Display Fill  0: Normal  1: Reverse 
....................    PE12864_Write_command(0xa6); // Normal 
0626:  MOVLW  A6
0628:  MOVLB  4
062A:  MOVWF  x62
062C:  MOVLB  0
062E:  RCALL  047E
....................    // Commom Output mode Select 
....................    //- PAG 46 -  1100-BIT      0: Normal Direction    1: Reverse Direction    (Ex: 11000*** - Normal Direction) 
....................    PE12864_Write_command(0xc8); 
0630:  MOVLW  C8
0632:  MOVLB  4
0634:  MOVWF  x62
0636:  MOVLB  0
0638:  RCALL  047E
....................    // LCD ADC Select 0:normal  1: Reverse 
....................    PE12864_Write_command(0xa0);    
063A:  MOVLW  A0
063C:  MOVLB  4
063E:  MOVWF  x62
0640:  MOVLB  0
0642:  RCALL  047E
....................    // CMD Set Start Line  
....................    PE12864_Write_command(0x40);    
0644:  MOVLW  40
0646:  MOVLB  4
0648:  MOVWF  x62
064A:  MOVLB  0
064C:  RCALL  047E
....................     
....................    PE12864_Write_command(0x28 | 0x4);  
064E:  MOVLW  2C
0650:  MOVLB  4
0652:  MOVWF  x62
0654:  MOVLB  0
0656:  RCALL  047E
....................    PE12864_Write_command(0x28 | 0x6);     
0658:  MOVLW  2E
065A:  MOVLB  4
065C:  MOVWF  x62
065E:  MOVLB  0
0660:  RCALL  047E
....................    PE12864_Write_command(0x28 | 0x7);     
0662:  MOVLW  2F
0664:  MOVLB  4
0666:  MOVWF  x62
0668:  MOVLB  0
066A:  RCALL  047E
....................    delay_us(5);    
066C:  MOVLW  13
066E:  MOVWF  00
0670:  DECFSZ 00,F
0672:  BRA    0670
0674:  BRA    0676
....................    PE12864_Write_command(0x20 | 0x6);  // resistor Ratio 
0676:  MOVLW  26
0678:  MOVLB  4
067A:  MOVWF  x62
067C:  MOVLB  0
067E:  RCALL  047E
....................    clear_screen(); 
0680:  BRA    059A
....................    PE12864_Write_command(0xaf); // Display ON 
0682:  MOVLW  AF
0684:  MOVLB  4
0686:  MOVWF  x62
0688:  MOVLB  0
068A:  RCALL  047E
....................    PE12864_Write_command(0xa4); // all points Normal 
068C:  MOVLW  A4
068E:  MOVLB  4
0690:  MOVWF  x62
0692:  MOVLB  0
0694:  RCALL  047E
....................  
....................    //Set Brightness   
....................    PE12864_Write_command(0x81);  
0696:  MOVLW  81
0698:  MOVLB  4
069A:  MOVWF  x62
069C:  MOVLB  0
069E:  RCALL  047E
....................    PE12864_Write_command(0x1a); 
06A0:  MOVLW  1A
06A2:  MOVLB  4
06A4:  MOVWF  x62
06A6:  MOVLB  0
06A8:  RCALL  047E
.................... } 
06AA:  GOTO   3534 (RETURN)
....................  
.................... void PE12864_SerialOut(char byteDC){ 
....................   int i; 
....................   output_low(PE12864_CS1);   
*
0448:  BCF    F92.2
044A:  BCF    F89.2
....................   for (i=8; i>0; i--) { 
044C:  MOVLW  08
044E:  MOVLB  4
0450:  MOVWF  x64
0452:  MOVF   x64,F
0454:  BZ    0476
....................     output_low(PE12864_CLK); 
0456:  BCF    F93.0
0458:  BCF    F8A.0
....................     if ((byteDC&0x80)==0) 
045A:  MOVF   x63,W
045C:  ANDLW  80
045E:  BNZ   0466
....................       output_low(PE12864_DATA); 
0460:  BCF    F93.1
0462:  BCF    F8A.1
....................     else 
0464:  BRA    046A
....................       output_high(PE12864_DATA); 
0466:  BCF    F93.1
0468:  BSF    F8A.1
....................     output_high(PE12864_CLK); 
046A:  BCF    F93.0
046C:  BSF    F8A.0
....................     byteDC<<=0x01; 
046E:  BCF    FD8.0
0470:  RLCF   x63,F
....................   } 
0472:  DECF   x64,F
0474:  BRA    0452
....................   output_high(PE12864_CS1); 
0476:  BCF    F92.2
0478:  BSF    F89.2
.................... } 
047A:  MOVLB  0
047C:  RETLW  00
.................... void    PE12864_Write_command(char byte_command){ 
....................   output_low(PE12864_A0);          // Write Command Enabled 
047E:  BCF    F92.0
0480:  BCF    F89.0
....................   PE12864_SerialOut(byte_command); 
0482:  MOVFF  462,463
0486:  RCALL  0448
.................... } 
0488:  RETLW  00
.................... void    PE12864_Write_data(char byte_data){ 
....................   output_high(PE12864_A0);         // Write data Enabled 
*
054C:  BCF    F92.0
054E:  BSF    F89.0
....................   PE12864_SerialOut(byte_data); 
0550:  MOVFF  45D,463
0554:  RCALL  0448
....................   Buffer[OffsetX][CurrentLine] = byte_data;   
0556:  MOVLB  4
0558:  CLRF   x5F
055A:  MOVFF  06,45E
055E:  CLRF   x61
0560:  MOVLW  08
0562:  MOVWF  x60
0564:  MOVLB  0
0566:  RCALL  052A
0568:  MOVFF  01,45E
056C:  MOVF   04,W
056E:  MOVLB  4
0570:  ADDWF  01,W
0572:  MOVWF  01
0574:  MOVLW  00
0576:  ADDWFC 02,W
0578:  MOVWF  03
057A:  MOVF   01,W
057C:  ADDLW  07
057E:  MOVWF  FE9
0580:  MOVLW  00
0582:  ADDWFC 03,W
0584:  MOVWF  FEA
0586:  MOVFF  45D,FEF
....................   OffsetX++; 
058A:  INCF   06,F
....................   PE12864_Gotoxy(OffsetX,CurrentLine); 
058C:  MOVFF  06,45E
0590:  MOVFF  04,45F
0594:  MOVLB  0
0596:  RCALL  04B6
.................... } 
0598:  RETLW  00
.................... void newLine(){ 
....................   if(CurrentLine < 7){  // New Line Command 
*
07E8:  MOVF   04,W
07EA:  SUBLW  06
07EC:  BNC   0814
....................       PE12864_Write_command((CurrentLine+1)|0xb0);  // Set Page Address to 0 (0 a 7) 
07EE:  MOVLW  01
07F0:  ADDWF  04,W
07F2:  IORLW  B0
07F4:  MOVLB  4
07F6:  MOVWF  x1D
07F8:  MOVWF  x62
07FA:  MOVLB  0
07FC:  RCALL  047E
....................       PE12864_Write_command(0x00);  // Set LSB for index Column 
07FE:  MOVLB  4
0800:  CLRF   x62
0802:  MOVLB  0
0804:  RCALL  047E
....................       PE12864_Write_command(0x10);  // Set MSB for index Column    
0806:  MOVLW  10
0808:  MOVLB  4
080A:  MOVWF  x62
080C:  MOVLB  0
080E:  RCALL  047E
....................       CurrentLine+=1; 
0810:  MOVLW  01
0812:  ADDWF  04,F
....................   } 
....................   QuantChrLine = 1; 
0814:  MOVLW  01
0816:  MOVWF  05
....................   OffsetX = 0; 
0818:  CLRF   06
.................... } 
081A:  GOTO   082A (RETURN)
.................... void clear_screen(void) { 
....................    int p, c; 
....................    for(p = 0; p < 8; p++) { 
*
059A:  MOVLB  4
059C:  CLRF   x19
059E:  MOVF   x19,W
05A0:  SUBLW  07
05A2:  BNC   05FA
....................       for(c = 0; c < 128; c++) { 
05A4:  CLRF   x1A
05A6:  MOVF   x1A,W
05A8:  SUBLW  7F
05AA:  BNC   05F6
....................          PE12864_Gotoxy(c,p); 
05AC:  MOVFF  41A,45E
05B0:  MOVFF  419,45F
05B4:  MOVLB  0
05B6:  RCALL  04B6
....................          PE12864_Write_data(0x00); 
05B8:  MOVLB  4
05BA:  CLRF   x5D
05BC:  MOVLB  0
05BE:  RCALL  054C
....................          Buffer[c][p] = 0x00;         
05C0:  MOVLB  4
05C2:  CLRF   x5F
05C4:  MOVFF  41A,45E
05C8:  CLRF   x61
05CA:  MOVLW  08
05CC:  MOVWF  x60
05CE:  MOVLB  0
05D0:  RCALL  052A
05D2:  MOVFF  01,41B
05D6:  MOVLB  4
05D8:  MOVF   x19,W
05DA:  ADDWF  01,W
05DC:  MOVWF  01
05DE:  MOVLW  00
05E0:  ADDWFC 02,W
05E2:  MOVWF  03
05E4:  MOVF   01,W
05E6:  ADDLW  07
05E8:  MOVWF  FE9
05EA:  MOVLW  00
05EC:  ADDWFC 03,W
05EE:  MOVWF  FEA
05F0:  CLRF   FEF
....................       } 
05F2:  INCF   x1A,F
05F4:  BRA    05A6
....................    } 
05F6:  INCF   x19,F
05F8:  BRA    059E
....................    PE12864_Gotoxy(0,0);    
05FA:  CLRF   x5E
05FC:  CLRF   x5F
05FE:  MOVLB  0
0600:  RCALL  04B6
.................... } 
0602:  GOTO   0682 (RETURN)
.................... void    PE12864_Gotoxy(int x, int y){ 
*
04B6:  MOVLB  4
04B8:  CLRF   x60
....................    int8 OffsetChr = 0; 
....................     
....................    PE12864_Write_command(0xb0 | y); 
04BA:  MOVF   x5F,W
04BC:  IORLW  B0
04BE:  MOVWF  x61
04C0:  MOVWF  x62
04C2:  MOVLB  0
04C4:  RCALL  047E
....................    PE12864_Write_command((0x00 | x) & 0x0f); 
04C6:  MOVLB  4
04C8:  MOVF   x5E,W
04CA:  ANDLW  0F
04CC:  MOVWF  x61
04CE:  MOVWF  x62
04D0:  MOVLB  0
04D2:  RCALL  047E
....................    PE12864_Write_command(0x10|(x>>4)); 
04D4:  MOVLB  4
04D6:  SWAPF  x5E,W
04D8:  MOVWF  00
04DA:  MOVLW  0F
04DC:  ANDWF  00,F
04DE:  MOVF   00,W
04E0:  IORLW  10
04E2:  MOVWF  x61
04E4:  MOVWF  x62
04E6:  MOVLB  0
04E8:  RCALL  047E
....................     
....................    OffsetChr = (x+1)/6; 
04EA:  MOVLW  01
04EC:  MOVLB  4
04EE:  ADDWF  x5E,W
04F0:  MOVWF  x62
04F2:  MOVWF  x63
04F4:  MOVLW  06
04F6:  MOVWF  x64
04F8:  MOVLB  0
04FA:  RCALL  048A
04FC:  MOVFF  01,460
....................    if((x+1)%6) 
0500:  MOVLW  01
0502:  MOVLB  4
0504:  ADDWF  x5E,W
0506:  MOVWF  x62
0508:  MOVWF  x63
050A:  MOVLW  06
050C:  MOVWF  x64
050E:  MOVLB  0
0510:  RCALL  048A
0512:  MOVF   00,W
0514:  BZ    051C
....................       OffsetChr++;    
0516:  MOVLB  4
0518:  INCF   x60,F
051A:  MOVLB  0
....................    CurrentLine = y; 
051C:  MOVFF  45F,04
....................    QuantChrLine = OffsetChr; 
0520:  MOVFF  460,05
....................    OffsetX = x; 
0524:  MOVFF  45E,06
.................... } 
0528:  RETLW  00
.................... /*void    PE12864_Printchar(char cvar){ 
....................    int i; 
....................    if (QuantChrLine > 21)   
....................        newLine();  
....................    else 
....................        QuantChrLine++;     
....................    for(i=0;i<5;i++){ 
....................       if (cvar < 0x53) 
....................          PE12864_Write_data(TEXT[cvar-0x20][i]);       
....................       else  
....................          PE12864_Write_data(TEXT2[cvar-0x53][i]);                
....................    } 
....................    PE12864_Write_data(0x00); 
.................... }*/ 
....................  
.................... void    PE12864_Printchar(char cvar){ 
....................    int i; 
....................    if (QuantChrLine > 21)   
*
081E:  MOVF   05,W
0820:  SUBLW  15
0822:  BC    0828
....................        newLine();  
0824:  BRA    07E8
....................    else 
0826:  BRA    082A
....................        QuantChrLine++;     
0828:  INCF   05,F
....................    if(cvar == 0x20) 
082A:  MOVLB  4
082C:  MOVF   x1B,W
082E:  SUBLW  20
0830:  BNZ   0848
....................       for(i=0;i<2;i++) 
0832:  CLRF   x1C
0834:  MOVF   x1C,W
0836:  SUBLW  01
0838:  BNC   0846
....................          PE12864_Write_data(0x00); 
083A:  CLRF   x5D
083C:  MOVLB  0
083E:  RCALL  054C
0840:  MOVLB  4
0842:  INCF   x1C,F
0844:  BRA    0834
....................    else{ 
0846:  BRA    0900
....................       for(i=0;i<5;i++){ 
0848:  CLRF   x1C
084A:  MOVF   x1C,W
084C:  SUBLW  04
084E:  BNC   0900
....................          if (cvar < 0x53){ 
0850:  MOVF   x1B,W
0852:  SUBLW  52
0854:  BNC   08AC
....................             if(TEXT[cvar-0x20][i])          
0856:  MOVLW  20
0858:  SUBWF  x1B,W
085A:  MULLW  05
085C:  MOVF   FF3,W
085E:  CLRF   x1E
0860:  MOVWF  x1D
0862:  CLRF   03
0864:  MOVF   x1C,W
0866:  ADDWF  x1D,W
0868:  MOVWF  01
086A:  MOVF   x1E,W
086C:  ADDWFC 03,F
086E:  MOVF   01,W
0870:  MOVLB  0
0872:  CALL   0004
0876:  MOVWF  01
0878:  MOVF   01,F
087A:  BZ    08A8
....................                PE12864_Write_data(TEXT[cvar-0x20][i]);       
087C:  MOVLW  20
087E:  MOVLB  4
0880:  SUBWF  x1B,W
0882:  MULLW  05
0884:  MOVF   FF3,W
0886:  CLRF   x1E
0888:  MOVWF  x1D
088A:  CLRF   03
088C:  MOVF   x1C,W
088E:  ADDWF  x1D,W
0890:  MOVWF  01
0892:  MOVF   x1E,W
0894:  ADDWFC 03,F
0896:  MOVF   01,W
0898:  MOVLB  0
089A:  CALL   0004
089E:  MOVLB  4
08A0:  MOVWF  x1D
08A2:  MOVWF  x5D
08A4:  MOVLB  0
08A6:  RCALL  054C
....................          } 
....................          else { 
08A8:  BRA    08FA
08AA:  MOVLB  4
....................             if(TEXT2[cvar-0x53][i])                
08AC:  MOVLW  53
08AE:  SUBWF  x1B,W
08B0:  MULLW  05
08B2:  MOVF   FF3,W
08B4:  CLRF   x1E
08B6:  MOVWF  x1D
08B8:  CLRF   03
08BA:  MOVF   x1C,W
08BC:  ADDWF  x1D,W
08BE:  MOVWF  01
08C0:  MOVF   x1E,W
08C2:  ADDWFC 03,F
08C4:  MOVF   01,W
08C6:  MOVLB  0
08C8:  RCALL  0114
08CA:  MOVWF  01
08CC:  MOVF   01,F
08CE:  BZ    08FA
....................                PE12864_Write_data(TEXT2[cvar-0x53][i]);                
08D0:  MOVLW  53
08D2:  MOVLB  4
08D4:  SUBWF  x1B,W
08D6:  MULLW  05
08D8:  MOVF   FF3,W
08DA:  CLRF   x1E
08DC:  MOVWF  x1D
08DE:  CLRF   03
08E0:  MOVF   x1C,W
08E2:  ADDWF  x1D,W
08E4:  MOVWF  01
08E6:  MOVF   x1E,W
08E8:  ADDWFC 03,F
08EA:  MOVF   01,W
08EC:  MOVLB  0
08EE:  RCALL  0114
08F0:  MOVLB  4
08F2:  MOVWF  x1D
08F4:  MOVWF  x5D
08F6:  MOVLB  0
08F8:  RCALL  054C
....................          } 
....................       } 
08FA:  MOVLB  4
08FC:  INCF   x1C,F
08FE:  BRA    084A
....................    } 
....................    PE12864_Write_data(0x00); 
0900:  CLRF   x5D
0902:  MOVLB  0
0904:  RCALL  054C
.................... } 
0906:  GOTO   091E (RETURN)
....................  
....................  
.................... void PE12864_PutPixel(int x, int y, int1 COLOR){ 
....................    byte BytePlot, tempByte; 
....................    if((x > 127)||(y > 63)) 
*
1644:  MOVLB  4
1646:  MOVF   x51,W
1648:  SUBLW  7F
164A:  BNC   1652
164C:  MOVF   x52,W
164E:  SUBLW  3F
1650:  BC    1654
....................       return; 
1652:  BRA    16DE
....................    BytePlot = 0; 
1654:  CLRF   x54
....................    BytePlot |= 1; 
1656:  BSF    x54.0
....................    PE12864_Gotoxy(x,(y/8)); 
1658:  RRCF   x52,W
165A:  MOVWF  x56
165C:  RRCF   x56,F
165E:  RRCF   x56,F
1660:  MOVLW  1F
1662:  ANDWF  x56,F
1664:  MOVFF  451,45E
1668:  MOVFF  456,45F
166C:  MOVLB  0
166E:  CALL   04B6
....................    BytePlot<<=(y%8); 
1672:  MOVLB  4
1674:  MOVF   x52,W
1676:  ANDLW  07
1678:  MOVWF  01
167A:  MOVF   01,F
167C:  BZ    1686
167E:  BCF    FD8.0
1680:  RLCF   x54,F
1682:  DECFSZ 01,F
1684:  BRA    167E
....................    tempByte = BytePlot;    
1686:  MOVFF  454,455
....................    BytePlot|=Buffer[x][y/8];       
168A:  CLRF   x5F
168C:  MOVFF  451,45E
1690:  CLRF   x61
1692:  MOVLW  08
1694:  MOVWF  x60
1696:  MOVLB  0
1698:  CALL   052A
169C:  MOVFF  01,456
16A0:  MOVLB  4
16A2:  RRCF   x52,W
16A4:  MOVWF  00
16A6:  RRCF   00,F
16A8:  RRCF   00,F
16AA:  MOVLW  1F
16AC:  ANDWF  00,F
16AE:  MOVF   00,W
16B0:  ADDWF  01,W
16B2:  MOVWF  01
16B4:  MOVLW  00
16B6:  ADDWFC 02,W
16B8:  MOVWF  03
16BA:  MOVF   01,W
16BC:  ADDLW  07
16BE:  MOVWF  FE9
16C0:  MOVLW  00
16C2:  ADDWFC 03,W
16C4:  MOVWF  FEA
16C6:  MOVF   FEF,W
16C8:  IORWF  x54,F
....................    if(COLOR == OFF) 
16CA:  MOVF   x53,F
16CC:  BNZ   16D2
....................       BytePlot-=tempByte; 
16CE:  MOVF   x55,W
16D0:  SUBWF  x54,F
....................    PE12864_Write_data(BytePlot); 
16D2:  MOVFF  454,45D
16D6:  MOVLB  0
16D8:  CALL   054C
16DC:  MOVLB  4
....................     
....................    /*   if(COLOR == ON) 
....................       BytePlot|=Buffer[x][y/8];       
....................    else{ 
....................       tempByte = BytePlot; 
....................       BytePlot|=Buffer[x][y/8];        
....................       BytePlot-=tempByte; 
....................       //BytePlot = ((BytePlot | Buffer[x][y/8]) - BytePlot);  
....................    }*/ 
.................... } 
16DE:  MOVLB  0
16E0:  RETLW  00
....................  
.................... void PE12864_circle(int x, int y, int radius, int1 fill, int1 COLOR){ 
....................    signed int a, b, P; 
....................    a = 0; 
*
2652:  MOVLB  4
2654:  CLRF   x3A
....................    b = radius; 
2656:  MOVFF  437,43B
....................    P = 1 - radius; 
265A:  MOVLW  01
265C:  BSF    FD8.0
265E:  SUBFWB x37,W
2660:  MOVWF  x3C
....................    do{ 
....................       if(fill){ 
2662:  MOVF   x38,F
2664:  BZ    2728
....................          PE12864_line(x-a, y+b, x+a, y+b, color); 
2666:  MOVF   x3A,W
2668:  SUBWF  x35,W
266A:  MOVWF  x3D
266C:  MOVF   x3B,W
266E:  ADDWF  x36,W
2670:  MOVWF  x3E
2672:  MOVF   x3A,W
2674:  ADDWF  x35,W
2676:  MOVWF  x3F
2678:  MOVF   x3B,W
267A:  ADDWF  x36,W
267C:  MOVWF  x40
267E:  MOVFF  43D,443
2682:  MOVFF  43E,444
2686:  MOVFF  43F,445
268A:  MOVWF  x46
268C:  MOVFF  439,447
2690:  MOVLB  0
2692:  RCALL  24A6
....................          PE12864_line(x-a, y-b, x+a, y-b, color); 
2694:  MOVLB  4
2696:  MOVF   x3A,W
2698:  SUBWF  x35,W
269A:  MOVWF  x3D
269C:  MOVF   x3B,W
269E:  SUBWF  x36,W
26A0:  MOVWF  x3E
26A2:  MOVF   x3A,W
26A4:  ADDWF  x35,W
26A6:  MOVWF  x3F
26A8:  MOVF   x3B,W
26AA:  SUBWF  x36,W
26AC:  MOVWF  x40
26AE:  MOVFF  43D,443
26B2:  MOVFF  43E,444
26B6:  MOVFF  43F,445
26BA:  MOVWF  x46
26BC:  MOVFF  439,447
26C0:  MOVLB  0
26C2:  RCALL  24A6
....................          PE12864_line(x-b, y+a, x+b, y+a, color); 
26C4:  MOVLB  4
26C6:  MOVF   x3B,W
26C8:  SUBWF  x35,W
26CA:  MOVWF  x3D
26CC:  MOVF   x3A,W
26CE:  ADDWF  x36,W
26D0:  MOVWF  x3E
26D2:  MOVF   x3B,W
26D4:  ADDWF  x35,W
26D6:  MOVWF  x3F
26D8:  MOVF   x3A,W
26DA:  ADDWF  x36,W
26DC:  MOVWF  x40
26DE:  MOVFF  43D,443
26E2:  MOVFF  43E,444
26E6:  MOVFF  43F,445
26EA:  MOVWF  x46
26EC:  MOVFF  439,447
26F0:  MOVLB  0
26F2:  RCALL  24A6
....................          PE12864_line(x-b, y-a, x+b, y-a, color); 
26F4:  MOVLB  4
26F6:  MOVF   x3B,W
26F8:  SUBWF  x35,W
26FA:  MOVWF  x3D
26FC:  MOVF   x3A,W
26FE:  SUBWF  x36,W
2700:  MOVWF  x3E
2702:  MOVF   x3B,W
2704:  ADDWF  x35,W
2706:  MOVWF  x3F
2708:  MOVF   x3A,W
270A:  SUBWF  x36,W
270C:  MOVWF  x40
270E:  MOVFF  43D,443
2712:  MOVFF  43E,444
2716:  MOVFF  43F,445
271A:  MOVWF  x46
271C:  MOVFF  439,447
2720:  MOVLB  0
2722:  RCALL  24A6
....................       } 
....................       else{ 
2724:  BRA    2816
2726:  MOVLB  4
....................          PE12864_PutPixel(a+x, b+y, color); 
2728:  MOVF   x35,W
272A:  ADDWF  x3A,W
272C:  MOVWF  x3D
272E:  MOVF   x36,W
2730:  ADDWF  x3B,W
2732:  MOVWF  x3E
2734:  MOVFF  43D,451
2738:  MOVWF  x52
273A:  MOVFF  439,453
273E:  MOVLB  0
2740:  CALL   1644
....................          PE12864_PutPixel(b+x, a+y, color); 
2744:  MOVLB  4
2746:  MOVF   x35,W
2748:  ADDWF  x3B,W
274A:  MOVWF  x3D
274C:  MOVF   x36,W
274E:  ADDWF  x3A,W
2750:  MOVWF  x3E
2752:  MOVFF  43D,451
2756:  MOVWF  x52
2758:  MOVFF  439,453
275C:  MOVLB  0
275E:  CALL   1644
....................          PE12864_PutPixel(x-a, b+y, color); 
2762:  MOVLB  4
2764:  MOVF   x3A,W
2766:  SUBWF  x35,W
2768:  MOVWF  x3D
276A:  MOVF   x36,W
276C:  ADDWF  x3B,W
276E:  MOVWF  x3E
2770:  MOVFF  43D,451
2774:  MOVWF  x52
2776:  MOVFF  439,453
277A:  MOVLB  0
277C:  CALL   1644
....................          PE12864_PutPixel(x-b, a+y, color); 
2780:  MOVLB  4
2782:  MOVF   x3B,W
2784:  SUBWF  x35,W
2786:  MOVWF  x3D
2788:  MOVF   x36,W
278A:  ADDWF  x3A,W
278C:  MOVWF  x3E
278E:  MOVFF  43D,451
2792:  MOVWF  x52
2794:  MOVFF  439,453
2798:  MOVLB  0
279A:  CALL   1644
....................          PE12864_PutPixel(b+x, y-a, color); 
279E:  MOVLB  4
27A0:  MOVF   x35,W
27A2:  ADDWF  x3B,W
27A4:  MOVWF  x3D
27A6:  MOVF   x3A,W
27A8:  SUBWF  x36,W
27AA:  MOVWF  x3E
27AC:  MOVFF  43D,451
27B0:  MOVWF  x52
27B2:  MOVFF  439,453
27B6:  MOVLB  0
27B8:  CALL   1644
....................          PE12864_PutPixel(a+x, y-b, color); 
27BC:  MOVLB  4
27BE:  MOVF   x35,W
27C0:  ADDWF  x3A,W
27C2:  MOVWF  x3D
27C4:  MOVF   x3B,W
27C6:  SUBWF  x36,W
27C8:  MOVWF  x3E
27CA:  MOVFF  43D,451
27CE:  MOVWF  x52
27D0:  MOVFF  439,453
27D4:  MOVLB  0
27D6:  CALL   1644
....................          PE12864_PutPixel(x-a, y-b, color); 
27DA:  MOVLB  4
27DC:  MOVF   x3A,W
27DE:  SUBWF  x35,W
27E0:  MOVWF  x3D
27E2:  MOVF   x3B,W
27E4:  SUBWF  x36,W
27E6:  MOVWF  x3E
27E8:  MOVFF  43D,451
27EC:  MOVWF  x52
27EE:  MOVFF  439,453
27F2:  MOVLB  0
27F4:  CALL   1644
....................          PE12864_PutPixel(x-b, y-a, color); 
27F8:  MOVLB  4
27FA:  MOVF   x3B,W
27FC:  SUBWF  x35,W
27FE:  MOVWF  x3D
2800:  MOVF   x3A,W
2802:  SUBWF  x36,W
2804:  MOVWF  x3E
2806:  MOVFF  43D,451
280A:  MOVWF  x52
280C:  MOVFF  439,453
2810:  MOVLB  0
2812:  CALL   1644
....................       } 
....................       if(P < 0) 
2816:  MOVLB  4
2818:  BTFSC  x3C.7
281A:  BRA    281E
281C:  BRA    283A
....................          P+= 3 + 2*a++; 
281E:  MOVF   x3A,W
2820:  INCF   x3A,F
2822:  MOVWF  x3D
2824:  MOVLW  02
2826:  MOVWF  x52
2828:  MOVFF  43D,453
282C:  MOVLB  0
282E:  RCALL  2458
2830:  MOVF   01,W
2832:  ADDLW  03
2834:  MOVLB  4
2836:  ADDWF  x3C,F
....................       else 
2838:  BRA    285C
....................          P+= 5 + 2*(a++ - b--); 
283A:  MOVF   x3A,W
283C:  INCF   x3A,F
283E:  MOVWF  x3D
2840:  MOVF   x3B,W
2842:  DECF   x3B,F
2844:  SUBWF  x3D,W
2846:  MOVWF  x3D
2848:  MOVLW  02
284A:  MOVWF  x52
284C:  MOVFF  43D,453
2850:  MOVLB  0
2852:  RCALL  2458
2854:  MOVF   01,W
2856:  ADDLW  05
2858:  MOVLB  4
285A:  ADDWF  x3C,F
....................     } while(a <= b); 
285C:  MOVF   x3A,W
285E:  XORLW  80
2860:  MOVWF  00
2862:  MOVF   x3B,W
2864:  XORLW  80
2866:  SUBWF  00,W
2868:  BTFSC  FD8.2
286A:  BRA    2662
286C:  BTFSS  FD8.0
286E:  BRA    2662
.................... } 
2870:  MOVLB  0
2872:  GOTO   2B16 (RETURN)
....................  
.................... void PE12864_line(int x1, int y1, int x2, int y2, int1 COLOR){ 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
*
24A6:  MOVLB  4
24A8:  MOVF   x43,W
24AA:  SUBWF  x45,W
24AC:  MOVWF  x51
24AE:  MOVF   x51,W
24B0:  BTFSS  x51.7
24B2:  BRA    24BA
24B4:  MOVLW  00
24B6:  BSF    FD8.0
24B8:  SUBFWB x51,W
24BA:  MOVWF  x4C
....................    dy = abs((signed int)(y2 - y1)); 
24BC:  MOVF   x44,W
24BE:  SUBWF  x46,W
24C0:  MOVWF  x51
24C2:  MOVF   x51,W
24C4:  BTFSS  x51.7
24C6:  BRA    24CE
24C8:  MOVLW  00
24CA:  BSF    FD8.0
24CC:  SUBFWB x51,W
24CE:  MOVWF  x4D
....................    x = x1; 
24D0:  MOVFF  443,448
....................    y = y1; 
24D4:  MOVFF  444,449
....................  
....................    if(x1 > x2) 
24D8:  MOVF   x43,W
24DA:  SUBWF  x45,W
24DC:  BC    24E4
....................       addx = -1; 
24DE:  MOVLW  FF
24E0:  MOVWF  x4A
....................    else 
24E2:  BRA    24E8
....................       addx = 1; 
24E4:  MOVLW  01
24E6:  MOVWF  x4A
....................    if(y1 > y2) 
24E8:  MOVF   x44,W
24EA:  SUBWF  x46,W
24EC:  BC    24F4
....................       addy = -1; 
24EE:  MOVLW  FF
24F0:  MOVWF  x4B
....................    else 
24F2:  BRA    24F8
....................       addy = 1; 
24F4:  MOVLW  01
24F6:  MOVWF  x4B
....................    if(dx >= dy){ 
24F8:  MOVF   x4D,W
24FA:  XORLW  80
24FC:  MOVWF  00
24FE:  MOVF   x4C,W
2500:  XORLW  80
2502:  SUBWF  00,W
2504:  BZ    2508
2506:  BC    25AC
....................       P = 2*dy - dx; 
2508:  MOVLW  02
250A:  MOVWF  x52
250C:  MOVFF  44D,453
2510:  MOVLB  0
2512:  RCALL  2458
2514:  MOVLB  4
2516:  MOVF   x4C,W
2518:  SUBWF  01,W
251A:  CLRF   03
251C:  BTFSC  FE8.7
251E:  DECF   03,F
2520:  MOVWF  x4E
2522:  MOVFF  03,44F
....................       for(i=0; i<=dx; ++i){ 
2526:  CLRF   x50
2528:  BTFSC  x4C.7
252A:  BRA    25AA
252C:  MOVF   x50,W
252E:  SUBWF  x4C,W
2530:  BNC   25AA
....................          PE12864_PutPixel(x, y, COLOR); 
2532:  MOVFF  448,451
2536:  MOVFF  449,452
253A:  MOVFF  447,453
253E:  MOVLB  0
2540:  CALL   1644
....................          if(P < 0){ 
2544:  MOVLB  4
2546:  BTFSC  x4F.7
2548:  BRA    254C
254A:  BRA    256E
....................             P += 2*dy; 
254C:  MOVLW  02
254E:  MOVWF  x52
2550:  MOVFF  44D,453
2554:  MOVLB  0
2556:  RCALL  2458
2558:  MOVF   01,W
255A:  CLRF   03
255C:  BTFSC  FE8.7
255E:  DECF   03,F
2560:  MOVLB  4
2562:  ADDWF  x4E,F
2564:  MOVF   03,W
2566:  ADDWFC x4F,F
....................             x += addx; 
2568:  MOVF   x4A,W
256A:  ADDWF  x48,F
....................          } 
....................          else{ 
256C:  BRA    25A6
....................             P += 2*dy - 2*dx; 
256E:  MOVLW  02
2570:  MOVWF  x52
2572:  MOVFF  44D,453
2576:  MOVLB  0
2578:  RCALL  2458
257A:  MOVFF  01,451
257E:  MOVLW  02
2580:  MOVLB  4
2582:  MOVWF  x52
2584:  MOVFF  44C,453
2588:  MOVLB  0
258A:  RCALL  2458
258C:  MOVF   01,W
258E:  MOVLB  4
2590:  SUBWF  x51,W
2592:  CLRF   03
2594:  BTFSC  FE8.7
2596:  DECF   03,F
2598:  ADDWF  x4E,F
259A:  MOVF   03,W
259C:  ADDWFC x4F,F
....................             x += addx; 
259E:  MOVF   x4A,W
25A0:  ADDWF  x48,F
....................             y += addy; 
25A2:  MOVF   x4B,W
25A4:  ADDWF  x49,F
....................          } 
....................       } 
25A6:  INCF   x50,F
25A8:  BRA    2528
....................    } 
....................    else{ 
25AA:  BRA    264E
....................       P = 2*dx - dy; 
25AC:  MOVLW  02
25AE:  MOVWF  x52
25B0:  MOVFF  44C,453
25B4:  MOVLB  0
25B6:  RCALL  2458
25B8:  MOVLB  4
25BA:  MOVF   x4D,W
25BC:  SUBWF  01,W
25BE:  CLRF   03
25C0:  BTFSC  FE8.7
25C2:  DECF   03,F
25C4:  MOVWF  x4E
25C6:  MOVFF  03,44F
....................       for(i=0; i<=dy; ++i){ 
25CA:  CLRF   x50
25CC:  BTFSC  x4D.7
25CE:  BRA    264E
25D0:  MOVF   x50,W
25D2:  SUBWF  x4D,W
25D4:  BNC   264E
....................          PE12864_PutPixel(x, y, COLOR); 
25D6:  MOVFF  448,451
25DA:  MOVFF  449,452
25DE:  MOVFF  447,453
25E2:  MOVLB  0
25E4:  CALL   1644
....................  
....................          if(P < 0){ 
25E8:  MOVLB  4
25EA:  BTFSC  x4F.7
25EC:  BRA    25F0
25EE:  BRA    2612
....................             P += 2*dx; 
25F0:  MOVLW  02
25F2:  MOVWF  x52
25F4:  MOVFF  44C,453
25F8:  MOVLB  0
25FA:  RCALL  2458
25FC:  MOVF   01,W
25FE:  CLRF   03
2600:  BTFSC  FE8.7
2602:  DECF   03,F
2604:  MOVLB  4
2606:  ADDWF  x4E,F
2608:  MOVF   03,W
260A:  ADDWFC x4F,F
....................             y += addy; 
260C:  MOVF   x4B,W
260E:  ADDWF  x49,F
....................          } 
....................          else{ 
2610:  BRA    264A
....................             P += 2*dx - 2*dy; 
2612:  MOVLW  02
2614:  MOVWF  x52
2616:  MOVFF  44C,453
261A:  MOVLB  0
261C:  RCALL  2458
261E:  MOVFF  01,451
2622:  MOVLW  02
2624:  MOVLB  4
2626:  MOVWF  x52
2628:  MOVFF  44D,453
262C:  MOVLB  0
262E:  RCALL  2458
2630:  MOVF   01,W
2632:  MOVLB  4
2634:  SUBWF  x51,W
2636:  CLRF   03
2638:  BTFSC  FE8.7
263A:  DECF   03,F
263C:  ADDWF  x4E,F
263E:  MOVF   03,W
2640:  ADDWFC x4F,F
....................             x += addx; 
2642:  MOVF   x4A,W
2644:  ADDWF  x48,F
....................             y += addy; 
2646:  MOVF   x4B,W
2648:  ADDWF  x49,F
....................          } 
....................       } 
264A:  INCF   x50,F
264C:  BRA    25CC
....................    } 
.................... } 
264E:  MOVLB  0
2650:  RETLW  00
....................  
.................... /*void linexy(int8 x1,int8 y1,int8 x2,int8 y2, int1 COLOR){ 
....................    int length_x, length_y, i; 
....................    float divResult; 
....................    length_x = abs((signed int)(x2 - x1)); 
....................    length_y = abs((signed int)(y2 - y1)); 
....................     
....................    if(length_x < length_y){ 
....................       divResult = (float)(length_x / length_y); 
....................       for(i = 0; i < length_y+1;i++) 
....................          PE12864_Putpixel(x1+ceil(divResult*i), y1+i, ON); 
....................    } 
....................    else{ 
....................       divResult = (float)(length_y / length_x); 
....................       for(i = 0; i < length_x+1;i++) 
....................          PE12864_Putpixel(x1+i, y1+ceil(divResult*i), ON); 
....................    }    
.................... } 
.................... */ 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
12C4:  MOVLB  4
12C6:  BCF    x49.0
....................    y = x; 
12C8:  MOVFF  43D,442
12CC:  MOVFF  43C,441
12D0:  MOVFF  43B,440
12D4:  MOVFF  43A,43F
....................  
....................    if (x < 0) 
12D8:  MOVFF  43D,48F
12DC:  MOVFF  43C,48E
12E0:  MOVFF  43B,48D
12E4:  MOVFF  43A,48C
12E8:  CLRF   x93
12EA:  CLRF   x92
12EC:  CLRF   x91
12EE:  CLRF   x90
12F0:  MOVLB  0
12F2:  RCALL  0E2C
12F4:  BNC   1300
....................    { 
....................       s = 1; 
12F6:  MOVLB  4
12F8:  BSF    x49.0
....................       y = -y; 
12FA:  MOVF   x40,W
12FC:  XORLW  80
12FE:  MOVWF  x40
....................    } 
....................  
....................    if (y <= 32768.0) 
1300:  MOVFF  442,48F
1304:  MOVFF  441,48E
1308:  MOVFF  440,48D
130C:  MOVFF  43F,48C
1310:  MOVLB  4
1312:  CLRF   x93
1314:  CLRF   x92
1316:  CLRF   x91
1318:  MOVLW  8E
131A:  MOVWF  x90
131C:  MOVLB  0
131E:  RCALL  0E2C
1320:  BC    1324
1322:  BNZ   1354
....................       res = (float32)(unsigned int16)y; 
1324:  MOVFF  442,48F
1328:  MOVFF  441,48E
132C:  MOVFF  440,48D
1330:  MOVFF  43F,48C
1334:  RCALL  0EA6
1336:  MOVFF  02,491
133A:  MOVFF  01,490
133E:  CALL   092A
1342:  MOVFF  03,446
1346:  MOVFF  02,445
134A:  MOVFF  01,444
134E:  MOVFF  00,443
....................  
....................  else if (y < 10000000.0) 
1352:  BRA    14F4
1354:  MOVFF  442,48F
1358:  MOVFF  441,48E
135C:  MOVFF  440,48D
1360:  MOVFF  43F,48C
1364:  MOVLW  80
1366:  MOVLB  4
1368:  MOVWF  x93
136A:  MOVLW  96
136C:  MOVWF  x92
136E:  MOVLW  18
1370:  MOVWF  x91
1372:  MOVLW  96
1374:  MOVWF  x90
1376:  MOVLB  0
1378:  RCALL  0E2C
137A:  BTFSS  FD8.0
137C:  BRA    14E4
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
137E:  MOVFF  442,493
1382:  MOVFF  441,492
1386:  MOVFF  440,491
138A:  MOVFF  43F,490
138E:  MOVLB  4
1390:  CLRF   x97
1392:  CLRF   x96
1394:  CLRF   x95
1396:  MOVLW  70
1398:  MOVWF  x94
139A:  MOVLB  0
139C:  CALL   0960
13A0:  MOVFF  03,48F
13A4:  MOVFF  02,48E
13A8:  MOVFF  01,48D
13AC:  MOVFF  00,48C
13B0:  RCALL  0EA6
13B2:  MOVFF  02,448
13B6:  MOVFF  01,447
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
13BA:  MOVFF  442,493
13BE:  MOVFF  441,492
13C2:  MOVFF  440,491
13C6:  MOVFF  43F,490
13CA:  MOVLB  4
13CC:  CLRF   x97
13CE:  CLRF   x96
13D0:  CLRF   x95
13D2:  MOVLW  70
13D4:  MOVWF  x94
13D6:  MOVLB  0
13D8:  CALL   0960
13DC:  MOVFF  00,44A
13E0:  MOVFF  01,44B
13E4:  MOVFF  02,44C
13E8:  MOVFF  03,44D
13EC:  MOVFF  448,491
13F0:  MOVFF  447,490
13F4:  CALL   092A
13F8:  BSF    FD8.1
13FA:  MOVFF  44D,493
13FE:  MOVFF  44C,492
1402:  MOVFF  44B,491
1406:  MOVFF  44A,490
140A:  MOVFF  03,497
140E:  MOVFF  02,496
1412:  MOVFF  01,495
1416:  MOVFF  00,494
141A:  CALL   0BB4
141E:  MOVLB  4
1420:  CLRF   x93
1422:  CLRF   x92
1424:  CLRF   x91
1426:  MOVLW  8E
1428:  MOVWF  x90
142A:  MOVFF  03,497
142E:  MOVFF  02,496
1432:  MOVFF  01,495
1436:  MOVFF  00,494
143A:  MOVLB  0
143C:  CALL   0960
1440:  MOVFF  03,442
1444:  MOVFF  02,441
1448:  MOVFF  01,440
144C:  MOVFF  00,43F
....................       res = 32768.0*(float32)l; 
1450:  MOVFF  448,491
1454:  MOVFF  447,490
1458:  CALL   092A
145C:  MOVLB  4
145E:  CLRF   x93
1460:  CLRF   x92
1462:  CLRF   x91
1464:  MOVLW  8E
1466:  MOVWF  x90
1468:  MOVFF  03,497
146C:  MOVFF  02,496
1470:  MOVFF  01,495
1474:  MOVFF  00,494
1478:  MOVLB  0
147A:  CALL   0960
147E:  MOVFF  03,446
1482:  MOVFF  02,445
1486:  MOVFF  01,444
148A:  MOVFF  00,443
....................       res += (float32)(unsigned int16)y; 
148E:  MOVFF  442,48F
1492:  MOVFF  441,48E
1496:  MOVFF  440,48D
149A:  MOVFF  43F,48C
149E:  RCALL  0EA6
14A0:  MOVFF  02,491
14A4:  MOVFF  01,490
14A8:  CALL   092A
14AC:  BCF    FD8.1
14AE:  MOVFF  446,493
14B2:  MOVFF  445,492
14B6:  MOVFF  444,491
14BA:  MOVFF  443,490
14BE:  MOVFF  03,497
14C2:  MOVFF  02,496
14C6:  MOVFF  01,495
14CA:  MOVFF  00,494
14CE:  CALL   0BB4
14D2:  MOVFF  03,446
14D6:  MOVFF  02,445
14DA:  MOVFF  01,444
14DE:  MOVFF  00,443
....................    } 
....................  
....................  else 
14E2:  BRA    14F4
....................   res = y; 
14E4:  MOVFF  442,446
14E8:  MOVFF  441,445
14EC:  MOVFF  440,444
14F0:  MOVFF  43F,443
....................  
....................  y = y - (float32)(unsigned int16)y; 
14F4:  MOVFF  442,48F
14F8:  MOVFF  441,48E
14FC:  MOVFF  440,48D
1500:  MOVFF  43F,48C
1504:  RCALL  0EA6
1506:  MOVFF  02,491
150A:  MOVFF  01,490
150E:  CALL   092A
1512:  BSF    FD8.1
1514:  MOVFF  442,493
1518:  MOVFF  441,492
151C:  MOVFF  440,491
1520:  MOVFF  43F,490
1524:  MOVFF  03,497
1528:  MOVFF  02,496
152C:  MOVFF  01,495
1530:  MOVFF  00,494
1534:  CALL   0BB4
1538:  MOVFF  03,442
153C:  MOVFF  02,441
1540:  MOVFF  01,440
1544:  MOVFF  00,43F
....................  
....................  if (s) 
1548:  MOVLB  4
154A:  BTFSS  x49.0
154C:  BRA    1554
....................   res = -res; 
154E:  MOVF   x44,W
1550:  XORLW  80
1552:  MOVWF  x44
....................  
....................  if (y != 0) 
1554:  MOVFF  442,48F
1558:  MOVFF  441,48E
155C:  MOVFF  440,48D
1560:  MOVFF  43F,48C
1564:  CLRF   x93
1566:  CLRF   x92
1568:  CLRF   x91
156A:  CLRF   x90
156C:  MOVLB  0
156E:  RCALL  0E2C
1570:  BZ    15EA
....................  { 
....................   if (s == 1 && n == 0) 
1572:  MOVLB  4
1574:  BTFSS  x49.0
1576:  BRA    15B0
1578:  MOVF   x3E,F
157A:  BNZ   15B0
....................    res -= 1.0; 
157C:  BSF    FD8.1
157E:  MOVFF  446,493
1582:  MOVFF  445,492
1586:  MOVFF  444,491
158A:  MOVFF  443,490
158E:  CLRF   x97
1590:  CLRF   x96
1592:  CLRF   x95
1594:  MOVLW  7F
1596:  MOVWF  x94
1598:  MOVLB  0
159A:  CALL   0BB4
159E:  MOVFF  03,446
15A2:  MOVFF  02,445
15A6:  MOVFF  01,444
15AA:  MOVFF  00,443
15AE:  MOVLB  4
....................  
....................   if (s == 0 && n == 1) 
15B0:  BTFSC  x49.0
15B2:  BRA    15EC
15B4:  DECFSZ x3E,W
15B6:  BRA    15EC
....................    res += 1.0; 
15B8:  BCF    FD8.1
15BA:  MOVFF  446,493
15BE:  MOVFF  445,492
15C2:  MOVFF  444,491
15C6:  MOVFF  443,490
15CA:  CLRF   x97
15CC:  CLRF   x96
15CE:  CLRF   x95
15D0:  MOVLW  7F
15D2:  MOVWF  x94
15D4:  MOVLB  0
15D6:  CALL   0BB4
15DA:  MOVFF  03,446
15DE:  MOVFF  02,445
15E2:  MOVFF  01,444
15E6:  MOVFF  00,443
15EA:  MOVLB  4
....................  } 
....................  if (x == 0) 
15EC:  MOVFF  43D,48F
15F0:  MOVFF  43C,48E
15F4:  MOVFF  43B,48D
15F8:  MOVFF  43A,48C
15FC:  CLRF   x93
15FE:  CLRF   x92
1600:  CLRF   x91
1602:  CLRF   x90
1604:  MOVLB  0
1606:  RCALL  0E2C
1608:  BNZ   1616
....................     res = 0; 
160A:  MOVLB  4
160C:  CLRF   x46
160E:  CLRF   x45
1610:  CLRF   x44
1612:  CLRF   x43
1614:  MOVLB  0
....................  
....................  return (res); 
1616:  MOVFF  443,00
161A:  MOVFF  444,01
161E:  MOVFF  445,02
1622:  MOVFF  446,03
.................... } 
1626:  GOTO   1642 (RETURN)
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
162A:  MOVFF  439,43D
162E:  MOVFF  438,43C
1632:  MOVFF  437,43B
1636:  MOVFF  436,43A
163A:  MOVLB  4
163C:  CLRF   x3E
163E:  MOVLB  0
1640:  BRA    12C4
.................... } 
1642:  RETLW  00
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
*
0EE2:  MOVLB  4
0EE4:  CLRF   x6D
0EE6:  CLRF   x6C
0EE8:  CLRF   x6B
0EEA:  MOVLW  7F
0EEC:  MOVWF  x6A
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
0EEE:  MOVLW  7E
0EF0:  MOVWF  x74
0EF2:  MOVLW  80
0EF4:  MOVWF  x75
0EF6:  CLRF   x76
0EF8:  CLRF   x77
0EFA:  MOVLW  7A
0EFC:  MOVWF  x78
0EFE:  MOVLW  2A
0F00:  MOVWF  x79
0F02:  MOVLW  AA
0F04:  MOVWF  x7A
0F06:  MOVLW  AB
0F08:  MOVWF  x7B
0F0A:  MOVLW  75
0F0C:  MOVWF  x7C
0F0E:  MOVLW  B6
0F10:  MOVWF  x7D
0F12:  MOVLW  0B
0F14:  MOVWF  x7E
0F16:  MOVLW  61
0F18:  MOVWF  x7F
0F1A:  MOVLW  6F
0F1C:  MOVWF  x80
0F1E:  MOVLW  50
0F20:  MOVWF  x81
0F22:  MOVLW  0D
0F24:  MOVWF  x82
0F26:  MOVLW  01
0F28:  MOVWF  x83
0F2A:  MOVLW  69
0F2C:  MOVWF  x84
0F2E:  MOVLW  93
0F30:  MOVWF  x85
0F32:  MOVLW  F2
0F34:  MOVWF  x86
0F36:  MOVLW  7E
0F38:  MOVWF  x87
0F3A:  MOVLW  62
0F3C:  MOVWF  x88
0F3E:  MOVLW  0F
0F40:  MOVWF  x89
0F42:  MOVLW  76
0F44:  MOVWF  x8A
0F46:  MOVLW  AE
0F48:  MOVWF  x8B
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0F4A:  MOVFF  461,48F
0F4E:  MOVFF  460,48E
0F52:  MOVFF  45F,48D
0F56:  MOVFF  45E,48C
0F5A:  CLRF   x93
0F5C:  CLRF   x92
0F5E:  CLRF   x91
0F60:  CLRF   x90
0F62:  MOVLB  0
0F64:  RCALL  0E2C
0F66:  BNC   0F70
0F68:  MOVLB  4
0F6A:  MOVF   x5F,W
0F6C:  XORLW  80
0F6E:  MOVWF  x5F
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0F70:  MOVFF  461,493
0F74:  MOVFF  460,492
0F78:  MOVFF  45F,491
0F7C:  MOVFF  45E,490
0F80:  MOVLW  83
0F82:  MOVLB  4
0F84:  MOVWF  x97
0F86:  MOVLW  F9
0F88:  MOVWF  x96
0F8A:  MOVLW  22
0F8C:  MOVWF  x95
0F8E:  MOVLW  7E
0F90:  MOVWF  x94
0F92:  MOVLB  0
0F94:  RCALL  0960
0F96:  MOVFF  03,48F
0F9A:  MOVFF  02,48E
0F9E:  MOVFF  01,48D
0FA2:  MOVFF  00,48C
0FA6:  RCALL  0EA6
0FA8:  MOVFF  01,46E
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0FAC:  MOVFF  461,493
0FB0:  MOVFF  460,492
0FB4:  MOVFF  45F,491
0FB8:  MOVFF  45E,490
0FBC:  MOVLW  83
0FBE:  MOVLB  4
0FC0:  MOVWF  x97
0FC2:  MOVLW  F9
0FC4:  MOVWF  x96
0FC6:  MOVLW  22
0FC8:  MOVWF  x95
0FCA:  MOVLW  7E
0FCC:  MOVWF  x94
0FCE:  MOVLB  0
0FD0:  RCALL  0960
0FD2:  MOVFF  00,48C
0FD6:  MOVFF  01,48D
0FDA:  MOVFF  02,48E
0FDE:  MOVFF  03,48F
0FE2:  MOVLB  4
0FE4:  CLRF   x91
0FE6:  MOVFF  46E,490
0FEA:  MOVLB  0
0FEC:  RCALL  092A
0FEE:  BSF    FD8.1
0FF0:  MOVFF  48F,493
0FF4:  MOVFF  48E,492
0FF8:  MOVFF  48D,491
0FFC:  MOVFF  48C,490
1000:  MOVFF  03,497
1004:  MOVFF  02,496
1008:  MOVFF  01,495
100C:  MOVFF  00,494
1010:  RCALL  0BB4
1012:  MOVFF  03,473
1016:  MOVFF  02,472
101A:  MOVFF  01,471
101E:  MOVFF  00,470
....................    quad = quad % 4;                    // quadrant (0 to 3) 
1022:  MOVLW  03
1024:  MOVLB  4
1026:  ANDWF  x6E,F
....................  
....................    if (quad == 0 || quad == 2) 
1028:  MOVF   x6E,F
102A:  BZ    1032
102C:  MOVF   x6E,W
102E:  SUBLW  02
1030:  BNZ   106A
....................       t = frac * PI_DIV_BY_TWO; 
1032:  MOVFF  473,493
1036:  MOVFF  472,492
103A:  MOVFF  471,491
103E:  MOVFF  470,490
1042:  MOVLW  DB
1044:  MOVWF  x97
1046:  MOVLW  0F
1048:  MOVWF  x96
104A:  MOVLW  49
104C:  MOVWF  x95
104E:  MOVLW  7F
1050:  MOVWF  x94
1052:  MOVLB  0
1054:  RCALL  0960
1056:  MOVFF  03,469
105A:  MOVFF  02,468
105E:  MOVFF  01,467
1062:  MOVFF  00,466
....................    else if (quad == 1) 
1066:  BRA    113E
1068:  MOVLB  4
106A:  DECFSZ x6E,W
106C:  BRA    10D8
....................       t = (1-frac) * PI_DIV_BY_TWO; 
106E:  BSF    FD8.1
1070:  CLRF   x93
1072:  CLRF   x92
1074:  CLRF   x91
1076:  MOVLW  7F
1078:  MOVWF  x90
107A:  MOVFF  473,497
107E:  MOVFF  472,496
1082:  MOVFF  471,495
1086:  MOVFF  470,494
108A:  MOVLB  0
108C:  RCALL  0BB4
108E:  MOVFF  00,48C
1092:  MOVFF  01,48D
1096:  MOVFF  02,48E
109A:  MOVFF  03,48F
109E:  MOVFF  03,493
10A2:  MOVFF  02,492
10A6:  MOVFF  01,491
10AA:  MOVFF  00,490
10AE:  MOVLW  DB
10B0:  MOVLB  4
10B2:  MOVWF  x97
10B4:  MOVLW  0F
10B6:  MOVWF  x96
10B8:  MOVLW  49
10BA:  MOVWF  x95
10BC:  MOVLW  7F
10BE:  MOVWF  x94
10C0:  MOVLB  0
10C2:  RCALL  0960
10C4:  MOVFF  03,469
10C8:  MOVFF  02,468
10CC:  MOVFF  01,467
10D0:  MOVFF  00,466
....................    else // should be 3 
10D4:  BRA    113E
10D6:  MOVLB  4
....................       t = (frac-1) * PI_DIV_BY_TWO; 
10D8:  BSF    FD8.1
10DA:  MOVFF  473,493
10DE:  MOVFF  472,492
10E2:  MOVFF  471,491
10E6:  MOVFF  470,490
10EA:  CLRF   x97
10EC:  CLRF   x96
10EE:  CLRF   x95
10F0:  MOVLW  7F
10F2:  MOVWF  x94
10F4:  MOVLB  0
10F6:  RCALL  0BB4
10F8:  MOVFF  00,48C
10FC:  MOVFF  01,48D
1100:  MOVFF  02,48E
1104:  MOVFF  03,48F
1108:  MOVFF  03,493
110C:  MOVFF  02,492
1110:  MOVFF  01,491
1114:  MOVFF  00,490
1118:  MOVLW  DB
111A:  MOVLB  4
111C:  MOVWF  x97
111E:  MOVLW  0F
1120:  MOVWF  x96
1122:  MOVLW  49
1124:  MOVWF  x95
1126:  MOVLW  7F
1128:  MOVWF  x94
112A:  MOVLB  0
112C:  RCALL  0960
112E:  MOVFF  03,469
1132:  MOVFF  02,468
1136:  MOVFF  01,467
113A:  MOVFF  00,466
....................  
....................    y = 1.0; 
113E:  MOVLB  4
1140:  CLRF   x65
1142:  CLRF   x64
1144:  CLRF   x63
1146:  MOVLW  7F
1148:  MOVWF  x62
....................    t = t * t; 
114A:  MOVFF  469,493
114E:  MOVFF  468,492
1152:  MOVFF  467,491
1156:  MOVFF  466,490
115A:  MOVFF  469,497
115E:  MOVFF  468,496
1162:  MOVFF  467,495
1166:  MOVFF  466,494
116A:  MOVLB  0
116C:  CALL   0960
1170:  MOVFF  03,469
1174:  MOVFF  02,468
1178:  MOVFF  01,467
117C:  MOVFF  00,466
....................    for (i = 0; i <= 5; i++) 
1180:  MOVLB  4
1182:  CLRF   x6F
1184:  MOVF   x6F,W
1186:  SUBLW  05
1188:  BNC   1254
....................    { 
....................       t2 = t2 * t; 
118A:  MOVFF  46D,493
118E:  MOVFF  46C,492
1192:  MOVFF  46B,491
1196:  MOVFF  46A,490
119A:  MOVFF  469,497
119E:  MOVFF  468,496
11A2:  MOVFF  467,495
11A6:  MOVFF  466,494
11AA:  MOVLB  0
11AC:  CALL   0960
11B0:  MOVFF  03,46D
11B4:  MOVFF  02,46C
11B8:  MOVFF  01,46B
11BC:  MOVFF  00,46A
....................       y = y + p[i] * t2; 
11C0:  MOVLB  4
11C2:  MOVF   x6F,W
11C4:  MULLW  04
11C6:  MOVF   FF3,W
11C8:  CLRF   03
11CA:  ADDLW  74
11CC:  MOVWF  FE9
11CE:  MOVLW  04
11D0:  ADDWFC 03,W
11D2:  MOVWF  FEA
11D4:  MOVFF  FEF,48C
11D8:  MOVFF  FEC,48D
11DC:  MOVFF  FEC,48E
11E0:  MOVFF  FEC,48F
11E4:  MOVFF  48F,493
11E8:  MOVFF  48E,492
11EC:  MOVFF  48D,491
11F0:  MOVFF  48C,490
11F4:  MOVFF  46D,497
11F8:  MOVFF  46C,496
11FC:  MOVFF  46B,495
1200:  MOVFF  46A,494
1204:  MOVLB  0
1206:  CALL   0960
120A:  MOVFF  FEA,48D
120E:  MOVFF  FE9,48C
1212:  BCF    FD8.1
1214:  MOVFF  465,493
1218:  MOVFF  464,492
121C:  MOVFF  463,491
1220:  MOVFF  462,490
1224:  MOVFF  03,497
1228:  MOVFF  02,496
122C:  MOVFF  01,495
1230:  MOVFF  00,494
1234:  RCALL  0BB4
1236:  MOVFF  48D,FEA
123A:  MOVFF  48C,FE9
123E:  MOVFF  03,465
1242:  MOVFF  02,464
1246:  MOVFF  01,463
124A:  MOVFF  00,462
....................    } 
124E:  MOVLB  4
1250:  INCF   x6F,F
1252:  BRA    1184
....................  
....................    if (quad == 2 || quad == 1) 
1254:  MOVF   x6E,W
1256:  SUBLW  02
1258:  BZ    125E
125A:  DECFSZ x6E,W
125C:  BRA    1264
....................       y = -y;  // correct sign 
125E:  MOVF   x63,W
1260:  XORLW  80
1262:  MOVWF  x63
....................  
....................    return (y); 
1264:  MOVFF  462,00
1268:  MOVFF  463,01
126C:  MOVFF  464,02
1270:  MOVFF  465,03
.................... } 
1274:  MOVLB  0
1276:  RETLW  00
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
1278:  BSF    FD8.1
127A:  MOVFF  459,493
127E:  MOVFF  458,492
1282:  MOVFF  457,491
1286:  MOVFF  456,490
128A:  MOVLW  DB
128C:  MOVLB  4
128E:  MOVWF  x97
1290:  MOVLW  0F
1292:  MOVWF  x96
1294:  MOVLW  49
1296:  MOVWF  x95
1298:  MOVLW  7F
129A:  MOVWF  x94
129C:  MOVLB  0
129E:  RCALL  0BB4
12A0:  MOVFF  00,45A
12A4:  MOVFF  01,45B
12A8:  MOVFF  02,45C
12AC:  MOVFF  03,45D
12B0:  MOVFF  03,461
12B4:  MOVFF  02,460
12B8:  MOVFF  01,45F
12BC:  MOVFF  00,45E
12C0:  RCALL  0EE2
.................... } 
12C2:  RETLW  00
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
06F0:  MOVFF  45E,460
06F4:  MOVFF  45D,45F
06F8:  MOVFF  460,03
06FC:  MOVLB  4
06FE:  MOVFF  45F,FE9
0702:  MOVFF  460,FEA
0706:  MOVF   FEF,F
0708:  BZ    0716
070A:  INCF   x5F,F
070C:  BTFSC  FD8.2
070E:  INCF   x60,F
0710:  MOVLB  0
0712:  BRA    06F8
0714:  MOVLB  4
....................    return(sc - s); 
0716:  MOVF   x5D,W
0718:  SUBWF  x5F,W
071A:  MOVWF  00
071C:  MOVF   x5E,W
071E:  SUBWFB x60,W
0720:  MOVWF  03
0722:  MOVFF  00,01
.................... } 
0726:  MOVLB  0
0728:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... char const bigNumber[11][45] = { 
.................... //0 
.................... 0x00, 0xf0, 0xfc, 0xfe, 0x0e, 0x07, 0x03, 0x03, 0x07, 0x1f, 0xfe, 0xfe, 0x3c, 0xf0, 0x00,  
.................... 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00,  
.................... 0x00, 0x1f, 0x3f, 0x7f, 0x70, 0xe0, 0xc0, 0xc0, 0xc0, 0xf0, 0x7f, 0x7f, 0x30, 0x1f, 0x00,  
....................  
.................... //1 
.................... 0x00, 0x80, 0xc0, 0xf0, 0x78, 0x3e, 0xff, 0xff, 0x05, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,  
.................... 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,  
.................... 0x00, 0x80, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff, 0xd0, 0xff, 0xc0, 0xc0, 0xc0, 0x80, 0x00, 
....................  
.................... //2 
.................... 0x00, 0xe0, 0x78, 0x3c, 0x1e, 0x0e, 0x0f, 0x0f, 0x1f, 0x3f, 0xfe, 0xfc, 0x38, 0xe0, 0x00,  
.................... 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x00, 0xff, 0x00,  
.................... 0x00, 0xc0, 0xe0, 0xf0, 0xf0, 0xf8, 0xdc, 0xce, 0xcf, 0xc7, 0xc7, 0xc3, 0xe1, 0xf1, 0x00,  
....................  
.................... //3 
.................... 0x00, 0x1e, 0x0f, 0x07, 0x03, 0x03, 0x03, 0x83, 0xc3, 0xe3, 0xfb, 0x7f, 0x3e, 0x00, 0x00,  
.................... 0x00, 0x00, 0x00, 0x00, 0x06, 0x0f, 0x0f, 0x0f, 0x0f, 0x1d, 0xf8, 0xb8, 0xe0, 0x80, 0x00,  
.................... 0x00, 0x1c, 0x78, 0x70, 0xe0, 0xe0, 0xc0, 0xc0, 0xe0, 0xf8, 0x7f, 0x27, 0x31, 0x0f, 0x00,  
....................  
.................... //4 
.................... 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0x78, 0xfc, 0xfe, 0x0b, 0xff, 0x00, 0x00, 0x00, 0x00,   
.................... 0x1c, 0x7f, 0x7f, 0x73, 0x71, 0x70, 0x70, 0xff, 0xff, 0x00, 0xff, 0x70, 0x70, 0x78, 0x00,  
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xff, 0xff, 0xd0, 0xff, 0xc0, 0x80, 0x00, 0x00,  
....................  
.................... //5 
.................... 0x00, 0xfe, 0xff, 0x0f, 0x07, 0x83, 0x83, 0x83, 0x83, 0x83, 0x07, 0x07, 0x0f, 0x00, 0x00,  
.................... 0x00, 0x1f, 0x0f, 0x06, 0x03, 0x01, 0x01, 0x01, 0x01, 0x03, 0xff, 0xfe, 0x5c, 0xf0, 0x00,  
.................... 0x00, 0x18, 0x70, 0x60, 0xe0, 0xc0, 0xc0, 0xc0, 0xe0, 0xe0, 0x7f, 0x37, 0x30, 0x1f, 0x00,   
....................  
.................... //6 
.................... 0x00, 0x80, 0xf0, 0xf8, 0x7c, 0x3e, 0x0f, 0x07, 0x03, 0x03, 0x03, 0x07, 0x0e, 0x3c, 0x00, 
.................... 0x00, 0xff, 0xff, 0xc3, 0xe0, 0x30, 0x38, 0x18, 0x1c, 0x1c, 0x38, 0xf8, 0xf0, 0x60, 0x80,  
.................... 0x00, 0x07, 0x1f, 0x3f, 0x7f, 0xf0, 0xe0, 0xc0, 0x80, 0xc0, 0xe0, 0xff, 0xff, 0x69, 0x1f,  
....................  
.................... //7 
.................... 0x00, 0x3e, 0x1f, 0x07, 0x07, 0x07, 0x07, 0x07, 0x87, 0xf7, 0xff, 0xff, 0x3f, 0x0f, 0x00,  
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x78, 0x9f, 0x77, 0x0f, 0x01, 0x00, 0x00, 0x00,  
.................... 0x00, 0x00, 0x80, 0xe0, 0xf8, 0xdf, 0x73, 0x0e, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
....................  
.................... //8 
.................... 0x00, 0xf0, 0xfc, 0xfe, 0x0f, 0x07, 0x03, 0x03, 0x03, 0x07, 0x0f, 0xfe, 0x0c, 0xf0, 0x00,  
.................... 0x00, 0x03, 0x8f, 0xdf, 0xfc, 0x38, 0x18, 0x18, 0x18, 0x3c, 0xfe, 0xdd, 0x8e, 0x07, 0x00, 
.................... 0x00, 0x1f, 0x7f, 0x7f, 0xf0, 0xe0, 0xc0, 0xc0, 0xc0, 0xe0, 0xf8, 0x7f, 0x73, 0x1e, 0x00,   
....................  
.................... //9 
.................... 0x00, 0xf8, 0xfc, 0xfe, 0x0e, 0x07, 0x07, 0x03, 0x03, 0x07, 0x0f, 0x7f, 0x7f, 0xf8, 0x00,  
.................... 0x00, 0x0f, 0x0f, 0x1f, 0x38, 0x30, 0x30, 0x20, 0x30, 0x30, 0xfc, 0xff, 0x05, 0xff, 0x00,  
.................... 0x00, 0x38, 0x70, 0xe0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xff, 0x7f, 0x38, 0x0f, 0x00,  
....................  
.................... //: 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xe0, 0xe0, 0xe0, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0xc7, 0xc7, 0xc7, 0xc7, 0x83, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0f, 0x0f, 0x0f, 0x0f, 0x07, 0x00, 0x00, 0x00, 0x00}; 
....................  
....................  
....................  
.................... void PE12864_TextXy(int x, int y, char* cvar); 
.................... void circulo(float aC, float bC, float r); 
.................... void circuloMenor(float aC, float bC, float r); 
.................... void circuloPonteiro(float aC, float bC, float r); 
.................... void circuloNumerico(float aC, float bC, float r); 
....................  
....................  
.................... void circulo(float aC, float bC, float r){ 
*
16E2:  MOVLB  4
16E4:  CLRF   x26
16E6:  CLRF   x25
....................    int16 i = 0; 
....................    float y, x; 
....................    while(i <= 360){ 
16E8:  MOVF   x26,W
16EA:  SUBLW  01
16EC:  BTFSS  FD8.0
16EE:  BRA    19DA
16F0:  BNZ   16FA
16F2:  MOVF   x25,W
16F4:  SUBLW  68
16F6:  BTFSS  FD8.0
16F8:  BRA    19DA
....................       y = (sin(i*pi/180)*r)+bC; 
16FA:  MOVFF  426,491
16FE:  MOVFF  425,490
1702:  MOVLB  0
1704:  CALL   092A
1708:  MOVFF  03,493
170C:  MOVFF  02,492
1710:  MOVFF  01,491
1714:  MOVFF  00,490
1718:  MOVLW  DB
171A:  MOVLB  4
171C:  MOVWF  x97
171E:  MOVLW  0F
1720:  MOVWF  x96
1722:  MOVLW  49
1724:  MOVWF  x95
1726:  MOVLW  80
1728:  MOVWF  x94
172A:  MOVLB  0
172C:  CALL   0960
1730:  MOVFF  00,42F
1734:  MOVFF  01,430
1738:  MOVFF  02,431
173C:  MOVFF  03,432
1740:  MOVFF  03,459
1744:  MOVFF  02,458
1748:  MOVFF  01,457
174C:  MOVFF  00,456
1750:  MOVLB  4
1752:  CLRF   x5D
1754:  CLRF   x5C
1756:  MOVLW  34
1758:  MOVWF  x5B
175A:  MOVLW  86
175C:  MOVWF  x5A
175E:  MOVLB  0
1760:  CALL   0A56
1764:  MOVFF  00,42F
1768:  MOVFF  01,430
176C:  MOVFF  02,431
1770:  MOVFF  03,432
1774:  MOVFF  03,459
1778:  MOVFF  02,458
177C:  MOVFF  01,457
1780:  MOVFF  00,456
1784:  RCALL  1278
1786:  MOVFF  00,42F
178A:  MOVFF  01,430
178E:  MOVFF  02,431
1792:  MOVFF  03,432
1796:  MOVFF  03,493
179A:  MOVFF  02,492
179E:  MOVFF  01,491
17A2:  MOVFF  00,490
17A6:  MOVFF  424,497
17AA:  MOVFF  423,496
17AE:  MOVFF  422,495
17B2:  MOVFF  421,494
17B6:  CALL   0960
17BA:  MOVFF  00,42F
17BE:  MOVFF  01,430
17C2:  MOVFF  02,431
17C6:  MOVFF  03,432
17CA:  MOVFF  FEA,434
17CE:  MOVFF  FE9,433
17D2:  BCF    FD8.1
17D4:  MOVFF  03,493
17D8:  MOVFF  02,492
17DC:  MOVFF  01,491
17E0:  MOVFF  00,490
17E4:  MOVFF  420,497
17E8:  MOVFF  41F,496
17EC:  MOVFF  41E,495
17F0:  MOVFF  41D,494
17F4:  CALL   0BB4
17F8:  MOVFF  434,FEA
17FC:  MOVFF  433,FE9
1800:  MOVFF  03,42A
1804:  MOVFF  02,429
1808:  MOVFF  01,428
180C:  MOVFF  00,427
....................       x = (cos(i*pi/180)*r)+aC;       
1810:  MOVFF  426,491
1814:  MOVFF  425,490
1818:  CALL   092A
181C:  MOVFF  03,493
1820:  MOVFF  02,492
1824:  MOVFF  01,491
1828:  MOVFF  00,490
182C:  MOVLW  DB
182E:  MOVLB  4
1830:  MOVWF  x97
1832:  MOVLW  0F
1834:  MOVWF  x96
1836:  MOVLW  49
1838:  MOVWF  x95
183A:  MOVLW  80
183C:  MOVWF  x94
183E:  MOVLB  0
1840:  CALL   0960
1844:  MOVFF  00,42F
1848:  MOVFF  01,430
184C:  MOVFF  02,431
1850:  MOVFF  03,432
1854:  MOVFF  03,459
1858:  MOVFF  02,458
185C:  MOVFF  01,457
1860:  MOVFF  00,456
1864:  MOVLB  4
1866:  CLRF   x5D
1868:  CLRF   x5C
186A:  MOVLW  34
186C:  MOVWF  x5B
186E:  MOVLW  86
1870:  MOVWF  x5A
1872:  MOVLB  0
1874:  CALL   0A56
1878:  MOVFF  00,42F
187C:  MOVFF  01,430
1880:  MOVFF  02,431
1884:  MOVFF  03,432
1888:  MOVFF  03,461
188C:  MOVFF  02,460
1890:  MOVFF  01,45F
1894:  MOVFF  00,45E
1898:  CALL   0EE2
189C:  MOVFF  00,42F
18A0:  MOVFF  01,430
18A4:  MOVFF  02,431
18A8:  MOVFF  03,432
18AC:  MOVFF  03,493
18B0:  MOVFF  02,492
18B4:  MOVFF  01,491
18B8:  MOVFF  00,490
18BC:  MOVFF  424,497
18C0:  MOVFF  423,496
18C4:  MOVFF  422,495
18C8:  MOVFF  421,494
18CC:  CALL   0960
18D0:  MOVFF  00,42F
18D4:  MOVFF  01,430
18D8:  MOVFF  02,431
18DC:  MOVFF  03,432
18E0:  MOVFF  FEA,434
18E4:  MOVFF  FE9,433
18E8:  BCF    FD8.1
18EA:  MOVFF  03,493
18EE:  MOVFF  02,492
18F2:  MOVFF  01,491
18F6:  MOVFF  00,490
18FA:  MOVFF  41C,497
18FE:  MOVFF  41B,496
1902:  MOVFF  41A,495
1906:  MOVFF  419,494
190A:  CALL   0BB4
190E:  MOVFF  434,FEA
1912:  MOVFF  433,FE9
1916:  MOVFF  03,42E
191A:  MOVFF  02,42D
191E:  MOVFF  01,42C
1922:  MOVFF  00,42B
....................       PE12864_Putpixel(floor(x), floor(64-y), ON); 
1926:  MOVFF  42E,439
192A:  MOVFF  42D,438
192E:  MOVFF  42C,437
1932:  MOVFF  42B,436
1936:  RCALL  162A
1938:  MOVFF  03,48F
193C:  MOVFF  02,48E
1940:  MOVFF  01,48D
1944:  MOVFF  00,48C
1948:  CALL   0EA6
194C:  MOVFF  01,42F
1950:  MOVFF  FEA,431
1954:  MOVFF  FE9,430
1958:  BSF    FD8.1
195A:  MOVLB  4
195C:  CLRF   x93
195E:  CLRF   x92
1960:  CLRF   x91
1962:  MOVLW  85
1964:  MOVWF  x90
1966:  MOVFF  42A,497
196A:  MOVFF  429,496
196E:  MOVFF  428,495
1972:  MOVFF  427,494
1976:  MOVLB  0
1978:  CALL   0BB4
197C:  MOVFF  431,FEA
1980:  MOVFF  430,FE9
1984:  MOVFF  00,432
1988:  MOVFF  01,433
198C:  MOVFF  02,434
1990:  MOVFF  03,435
1994:  MOVFF  03,439
1998:  MOVFF  02,438
199C:  MOVFF  01,437
19A0:  MOVFF  00,436
19A4:  RCALL  162A
19A6:  MOVFF  03,48F
19AA:  MOVFF  02,48E
19AE:  MOVFF  01,48D
19B2:  MOVFF  00,48C
19B6:  CALL   0EA6
19BA:  MOVFF  01,432
19BE:  MOVFF  42F,451
19C2:  MOVFF  01,452
19C6:  MOVLW  01
19C8:  MOVLB  4
19CA:  MOVWF  x53
19CC:  MOVLB  0
19CE:  RCALL  1644
....................       i++; 
19D0:  MOVLB  4
19D2:  INCF   x25,F
19D4:  BTFSC  FD8.2
19D6:  INCF   x26,F
....................    } 
19D8:  BRA    16E8
.................... } 
19DA:  MOVLB  0
19DC:  GOTO   3486 (RETURN)
.................... void circuloMenor(float aC, float bC, float r){ 
19E0:  MOVLB  4
19E2:  CLRF   x26
19E4:  CLRF   x25
....................    int16 i = 0; 
....................    float y, x; 
....................    while(i <= 360){ 
19E6:  MOVF   x26,W
19E8:  SUBLW  01
19EA:  BTFSS  FD8.0
19EC:  BRA    1CDC
19EE:  BNZ   19F8
19F0:  MOVF   x25,W
19F2:  SUBLW  68
19F4:  BTFSS  FD8.0
19F6:  BRA    1CDC
....................       y = (sin(i*pi/180)*r)+bC; 
19F8:  MOVFF  426,491
19FC:  MOVFF  425,490
1A00:  MOVLB  0
1A02:  CALL   092A
1A06:  MOVFF  03,493
1A0A:  MOVFF  02,492
1A0E:  MOVFF  01,491
1A12:  MOVFF  00,490
1A16:  MOVLW  DB
1A18:  MOVLB  4
1A1A:  MOVWF  x97
1A1C:  MOVLW  0F
1A1E:  MOVWF  x96
1A20:  MOVLW  49
1A22:  MOVWF  x95
1A24:  MOVLW  80
1A26:  MOVWF  x94
1A28:  MOVLB  0
1A2A:  CALL   0960
1A2E:  MOVFF  00,42F
1A32:  MOVFF  01,430
1A36:  MOVFF  02,431
1A3A:  MOVFF  03,432
1A3E:  MOVFF  03,459
1A42:  MOVFF  02,458
1A46:  MOVFF  01,457
1A4A:  MOVFF  00,456
1A4E:  MOVLB  4
1A50:  CLRF   x5D
1A52:  CLRF   x5C
1A54:  MOVLW  34
1A56:  MOVWF  x5B
1A58:  MOVLW  86
1A5A:  MOVWF  x5A
1A5C:  MOVLB  0
1A5E:  CALL   0A56
1A62:  MOVFF  00,42F
1A66:  MOVFF  01,430
1A6A:  MOVFF  02,431
1A6E:  MOVFF  03,432
1A72:  MOVFF  03,459
1A76:  MOVFF  02,458
1A7A:  MOVFF  01,457
1A7E:  MOVFF  00,456
1A82:  CALL   1278
1A86:  MOVFF  00,42F
1A8A:  MOVFF  01,430
1A8E:  MOVFF  02,431
1A92:  MOVFF  03,432
1A96:  MOVFF  03,493
1A9A:  MOVFF  02,492
1A9E:  MOVFF  01,491
1AA2:  MOVFF  00,490
1AA6:  MOVFF  424,497
1AAA:  MOVFF  423,496
1AAE:  MOVFF  422,495
1AB2:  MOVFF  421,494
1AB6:  CALL   0960
1ABA:  MOVFF  00,42F
1ABE:  MOVFF  01,430
1AC2:  MOVFF  02,431
1AC6:  MOVFF  03,432
1ACA:  MOVFF  FEA,434
1ACE:  MOVFF  FE9,433
1AD2:  BCF    FD8.1
1AD4:  MOVFF  03,493
1AD8:  MOVFF  02,492
1ADC:  MOVFF  01,491
1AE0:  MOVFF  00,490
1AE4:  MOVFF  420,497
1AE8:  MOVFF  41F,496
1AEC:  MOVFF  41E,495
1AF0:  MOVFF  41D,494
1AF4:  CALL   0BB4
1AF8:  MOVFF  434,FEA
1AFC:  MOVFF  433,FE9
1B00:  MOVFF  03,42A
1B04:  MOVFF  02,429
1B08:  MOVFF  01,428
1B0C:  MOVFF  00,427
....................       x = (cos(i*pi/180)*r)+aC;       
1B10:  MOVFF  426,491
1B14:  MOVFF  425,490
1B18:  CALL   092A
1B1C:  MOVFF  03,493
1B20:  MOVFF  02,492
1B24:  MOVFF  01,491
1B28:  MOVFF  00,490
1B2C:  MOVLW  DB
1B2E:  MOVLB  4
1B30:  MOVWF  x97
1B32:  MOVLW  0F
1B34:  MOVWF  x96
1B36:  MOVLW  49
1B38:  MOVWF  x95
1B3A:  MOVLW  80
1B3C:  MOVWF  x94
1B3E:  MOVLB  0
1B40:  CALL   0960
1B44:  MOVFF  00,42F
1B48:  MOVFF  01,430
1B4C:  MOVFF  02,431
1B50:  MOVFF  03,432
1B54:  MOVFF  03,459
1B58:  MOVFF  02,458
1B5C:  MOVFF  01,457
1B60:  MOVFF  00,456
1B64:  MOVLB  4
1B66:  CLRF   x5D
1B68:  CLRF   x5C
1B6A:  MOVLW  34
1B6C:  MOVWF  x5B
1B6E:  MOVLW  86
1B70:  MOVWF  x5A
1B72:  MOVLB  0
1B74:  CALL   0A56
1B78:  MOVFF  00,42F
1B7C:  MOVFF  01,430
1B80:  MOVFF  02,431
1B84:  MOVFF  03,432
1B88:  MOVFF  03,461
1B8C:  MOVFF  02,460
1B90:  MOVFF  01,45F
1B94:  MOVFF  00,45E
1B98:  CALL   0EE2
1B9C:  MOVFF  00,42F
1BA0:  MOVFF  01,430
1BA4:  MOVFF  02,431
1BA8:  MOVFF  03,432
1BAC:  MOVFF  03,493
1BB0:  MOVFF  02,492
1BB4:  MOVFF  01,491
1BB8:  MOVFF  00,490
1BBC:  MOVFF  424,497
1BC0:  MOVFF  423,496
1BC4:  MOVFF  422,495
1BC8:  MOVFF  421,494
1BCC:  CALL   0960
1BD0:  MOVFF  00,42F
1BD4:  MOVFF  01,430
1BD8:  MOVFF  02,431
1BDC:  MOVFF  03,432
1BE0:  MOVFF  FEA,434
1BE4:  MOVFF  FE9,433
1BE8:  BCF    FD8.1
1BEA:  MOVFF  03,493
1BEE:  MOVFF  02,492
1BF2:  MOVFF  01,491
1BF6:  MOVFF  00,490
1BFA:  MOVFF  41C,497
1BFE:  MOVFF  41B,496
1C02:  MOVFF  41A,495
1C06:  MOVFF  419,494
1C0A:  CALL   0BB4
1C0E:  MOVFF  434,FEA
1C12:  MOVFF  433,FE9
1C16:  MOVFF  03,42E
1C1A:  MOVFF  02,42D
1C1E:  MOVFF  01,42C
1C22:  MOVFF  00,42B
....................       PE12864_Putpixel(floor(x), floor(64-y), ON); 
1C26:  MOVFF  42E,439
1C2A:  MOVFF  42D,438
1C2E:  MOVFF  42C,437
1C32:  MOVFF  42B,436
1C36:  RCALL  162A
1C38:  MOVFF  03,48F
1C3C:  MOVFF  02,48E
1C40:  MOVFF  01,48D
1C44:  MOVFF  00,48C
1C48:  CALL   0EA6
1C4C:  MOVFF  01,42F
1C50:  MOVFF  FEA,431
1C54:  MOVFF  FE9,430
1C58:  BSF    FD8.1
1C5A:  MOVLB  4
1C5C:  CLRF   x93
1C5E:  CLRF   x92
1C60:  CLRF   x91
1C62:  MOVLW  85
1C64:  MOVWF  x90
1C66:  MOVFF  42A,497
1C6A:  MOVFF  429,496
1C6E:  MOVFF  428,495
1C72:  MOVFF  427,494
1C76:  MOVLB  0
1C78:  CALL   0BB4
1C7C:  MOVFF  431,FEA
1C80:  MOVFF  430,FE9
1C84:  MOVFF  00,432
1C88:  MOVFF  01,433
1C8C:  MOVFF  02,434
1C90:  MOVFF  03,435
1C94:  MOVFF  03,439
1C98:  MOVFF  02,438
1C9C:  MOVFF  01,437
1CA0:  MOVFF  00,436
1CA4:  RCALL  162A
1CA6:  MOVFF  03,48F
1CAA:  MOVFF  02,48E
1CAE:  MOVFF  01,48D
1CB2:  MOVFF  00,48C
1CB6:  CALL   0EA6
1CBA:  MOVFF  01,432
1CBE:  MOVFF  42F,451
1CC2:  MOVFF  01,452
1CC6:  MOVLW  01
1CC8:  MOVLB  4
1CCA:  MOVWF  x53
1CCC:  MOVLB  0
1CCE:  RCALL  1644
....................       i+=6; 
1CD0:  MOVLW  06
1CD2:  MOVLB  4
1CD4:  ADDWF  x25,F
1CD6:  MOVLW  00
1CD8:  ADDWFC x26,F
....................    } 
1CDA:  BRA    19E6
.................... } 
1CDC:  MOVLB  0
1CDE:  GOTO   34B0 (RETURN)
.................... void circuloPonteiro(float aC, float bC, float r){ 
*
2876:  MOVLB  4
2878:  CLRF   x26
287A:  CLRF   x25
287C:  CLRF   x28
287E:  CLRF   x27
2880:  MOVLW  0F
2882:  MOVWF  x29
2884:  MOVLW  29
2886:  MOVWF  x2A
2888:  MOVLW  0F
288A:  MOVWF  x2B
288C:  CLRF   x2C
....................    int16 i = 0, mS = 0; 
....................   // char chr[14]; 
....................    int H = 15, M = 41, S = 15, test = 0; 
....................    float y, x; 
....................    while(i <= 360){ 
288E:  MOVF   x26,W
2890:  SUBLW  01
2892:  BTFSS  FD8.0
2894:  GOTO   345A
2898:  BNZ   28A4
289A:  MOVF   x25,W
289C:  SUBLW  68
289E:  BTFSS  FD8.0
28A0:  GOTO   345A
....................       y = (sin(i*pi/180)*r)+bC; 
28A4:  MOVFF  426,491
28A8:  MOVFF  425,490
28AC:  MOVLB  0
28AE:  CALL   092A
28B2:  MOVFF  03,493
28B6:  MOVFF  02,492
28BA:  MOVFF  01,491
28BE:  MOVFF  00,490
28C2:  MOVLW  DB
28C4:  MOVLB  4
28C6:  MOVWF  x97
28C8:  MOVLW  0F
28CA:  MOVWF  x96
28CC:  MOVLW  49
28CE:  MOVWF  x95
28D0:  MOVLW  80
28D2:  MOVWF  x94
28D4:  MOVLB  0
28D6:  CALL   0960
28DA:  MOVFF  00,435
28DE:  MOVFF  01,436
28E2:  MOVFF  02,437
28E6:  MOVFF  03,438
28EA:  MOVFF  03,459
28EE:  MOVFF  02,458
28F2:  MOVFF  01,457
28F6:  MOVFF  00,456
28FA:  MOVLB  4
28FC:  CLRF   x5D
28FE:  CLRF   x5C
2900:  MOVLW  34
2902:  MOVWF  x5B
2904:  MOVLW  86
2906:  MOVWF  x5A
2908:  MOVLB  0
290A:  CALL   0A56
290E:  MOVFF  00,435
2912:  MOVFF  01,436
2916:  MOVFF  02,437
291A:  MOVFF  03,438
291E:  MOVFF  03,459
2922:  MOVFF  02,458
2926:  MOVFF  01,457
292A:  MOVFF  00,456
292E:  CALL   1278
2932:  MOVFF  00,435
2936:  MOVFF  01,436
293A:  MOVFF  02,437
293E:  MOVFF  03,438
2942:  MOVFF  03,493
2946:  MOVFF  02,492
294A:  MOVFF  01,491
294E:  MOVFF  00,490
2952:  MOVFF  424,497
2956:  MOVFF  423,496
295A:  MOVFF  422,495
295E:  MOVFF  421,494
2962:  CALL   0960
2966:  MOVFF  00,435
296A:  MOVFF  01,436
296E:  MOVFF  02,437
2972:  MOVFF  03,438
2976:  MOVFF  FEA,43A
297A:  MOVFF  FE9,439
297E:  BCF    FD8.1
2980:  MOVFF  03,493
2984:  MOVFF  02,492
2988:  MOVFF  01,491
298C:  MOVFF  00,490
2990:  MOVFF  420,497
2994:  MOVFF  41F,496
2998:  MOVFF  41E,495
299C:  MOVFF  41D,494
29A0:  CALL   0BB4
29A4:  MOVFF  43A,FEA
29A8:  MOVFF  439,FE9
29AC:  MOVFF  03,430
29B0:  MOVFF  02,42F
29B4:  MOVFF  01,42E
29B8:  MOVFF  00,42D
....................       x = (cos(i*pi/180)*r)+aC; 
29BC:  MOVFF  426,491
29C0:  MOVFF  425,490
29C4:  CALL   092A
29C8:  MOVFF  03,493
29CC:  MOVFF  02,492
29D0:  MOVFF  01,491
29D4:  MOVFF  00,490
29D8:  MOVLW  DB
29DA:  MOVLB  4
29DC:  MOVWF  x97
29DE:  MOVLW  0F
29E0:  MOVWF  x96
29E2:  MOVLW  49
29E4:  MOVWF  x95
29E6:  MOVLW  80
29E8:  MOVWF  x94
29EA:  MOVLB  0
29EC:  CALL   0960
29F0:  MOVFF  00,435
29F4:  MOVFF  01,436
29F8:  MOVFF  02,437
29FC:  MOVFF  03,438
2A00:  MOVFF  03,459
2A04:  MOVFF  02,458
2A08:  MOVFF  01,457
2A0C:  MOVFF  00,456
2A10:  MOVLB  4
2A12:  CLRF   x5D
2A14:  CLRF   x5C
2A16:  MOVLW  34
2A18:  MOVWF  x5B
2A1A:  MOVLW  86
2A1C:  MOVWF  x5A
2A1E:  MOVLB  0
2A20:  CALL   0A56
2A24:  MOVFF  00,435
2A28:  MOVFF  01,436
2A2C:  MOVFF  02,437
2A30:  MOVFF  03,438
2A34:  MOVFF  03,461
2A38:  MOVFF  02,460
2A3C:  MOVFF  01,45F
2A40:  MOVFF  00,45E
2A44:  CALL   0EE2
2A48:  MOVFF  00,435
2A4C:  MOVFF  01,436
2A50:  MOVFF  02,437
2A54:  MOVFF  03,438
2A58:  MOVFF  03,493
2A5C:  MOVFF  02,492
2A60:  MOVFF  01,491
2A64:  MOVFF  00,490
2A68:  MOVFF  424,497
2A6C:  MOVFF  423,496
2A70:  MOVFF  422,495
2A74:  MOVFF  421,494
2A78:  CALL   0960
2A7C:  MOVFF  00,435
2A80:  MOVFF  01,436
2A84:  MOVFF  02,437
2A88:  MOVFF  03,438
2A8C:  MOVFF  FEA,43A
2A90:  MOVFF  FE9,439
2A94:  BCF    FD8.1
2A96:  MOVFF  03,493
2A9A:  MOVFF  02,492
2A9E:  MOVFF  01,491
2AA2:  MOVFF  00,490
2AA6:  MOVFF  41C,497
2AAA:  MOVFF  41B,496
2AAE:  MOVFF  41A,495
2AB2:  MOVFF  419,494
2AB6:  CALL   0BB4
2ABA:  MOVFF  43A,FEA
2ABE:  MOVFF  439,FE9
2AC2:  MOVFF  03,434
2AC6:  MOVFF  02,433
2ACA:  MOVFF  01,432
2ACE:  MOVFF  00,431
....................       circuloNumerico(94, 29, 26); 
2AD2:  MOVLB  4
2AD4:  CLRF   x38
2AD6:  CLRF   x37
2AD8:  MOVLW  3C
2ADA:  MOVWF  x36
2ADC:  MOVLW  85
2ADE:  MOVWF  x35
2AE0:  CLRF   x3C
2AE2:  CLRF   x3B
2AE4:  MOVLW  68
2AE6:  MOVWF  x3A
2AE8:  MOVLW  83
2AEA:  MOVWF  x39
2AEC:  CLRF   x40
2AEE:  CLRF   x3F
2AF0:  MOVLW  50
2AF2:  MOVWF  x3E
2AF4:  MOVLW  83
2AF6:  MOVWF  x3D
2AF8:  MOVLB  0
2AFA:  CALL   2002
....................       PE12864_circle(96,32,3,1,ON); 
2AFE:  MOVLW  60
2B00:  MOVLB  4
2B02:  MOVWF  x35
2B04:  MOVLW  20
2B06:  MOVWF  x36
2B08:  MOVLW  03
2B0A:  MOVWF  x37
2B0C:  MOVLW  01
2B0E:  MOVWF  x38
2B10:  MOVWF  x39
2B12:  MOVLB  0
2B14:  BRA    2652
....................       PE12864_line(aC, bC, (cos(0*pi/180)*(r-11))+aC, (sin(0*pi/180)*(r-11))+bC, ON);  // hora 
2B16:  MOVFF  41C,48F
2B1A:  MOVFF  41B,48E
2B1E:  MOVFF  41A,48D
2B22:  MOVFF  419,48C
2B26:  CALL   0EA6
2B2A:  MOVFF  01,435
2B2E:  MOVFF  420,48F
2B32:  MOVFF  41F,48E
2B36:  MOVFF  41E,48D
2B3A:  MOVFF  41D,48C
2B3E:  CALL   0EA6
2B42:  MOVFF  01,436
2B46:  MOVLB  4
2B48:  CLRF   x61
2B4A:  CLRF   x60
2B4C:  CLRF   x5F
2B4E:  CLRF   x5E
2B50:  MOVLB  0
2B52:  CALL   0EE2
2B56:  MOVFF  00,437
2B5A:  MOVFF  01,438
2B5E:  MOVFF  02,439
2B62:  MOVFF  03,43A
2B66:  MOVFF  FEA,43C
2B6A:  MOVFF  FE9,43B
2B6E:  BSF    FD8.1
2B70:  MOVFF  424,493
2B74:  MOVFF  423,492
2B78:  MOVFF  422,491
2B7C:  MOVFF  421,490
2B80:  MOVLB  4
2B82:  CLRF   x97
2B84:  CLRF   x96
2B86:  MOVLW  30
2B88:  MOVWF  x95
2B8A:  MOVLW  82
2B8C:  MOVWF  x94
2B8E:  MOVLB  0
2B90:  CALL   0BB4
2B94:  MOVFF  43C,FEA
2B98:  MOVFF  43B,FE9
2B9C:  MOVFF  43A,493
2BA0:  MOVFF  439,492
2BA4:  MOVFF  438,491
2BA8:  MOVFF  437,490
2BAC:  MOVFF  03,497
2BB0:  MOVFF  02,496
2BB4:  MOVFF  01,495
2BB8:  MOVFF  00,494
2BBC:  CALL   0960
2BC0:  MOVFF  00,437
2BC4:  MOVFF  01,438
2BC8:  MOVFF  02,439
2BCC:  MOVFF  03,43A
2BD0:  MOVFF  FEA,43E
2BD4:  MOVFF  FE9,43D
2BD8:  BCF    FD8.1
2BDA:  MOVFF  03,493
2BDE:  MOVFF  02,492
2BE2:  MOVFF  01,491
2BE6:  MOVFF  00,490
2BEA:  MOVFF  41C,497
2BEE:  MOVFF  41B,496
2BF2:  MOVFF  41A,495
2BF6:  MOVFF  419,494
2BFA:  CALL   0BB4
2BFE:  MOVFF  43E,FEA
2C02:  MOVFF  43D,FE9
2C06:  MOVFF  03,48F
2C0A:  MOVFF  02,48E
2C0E:  MOVFF  01,48D
2C12:  MOVFF  00,48C
2C16:  CALL   0EA6
2C1A:  MOVFF  01,437
2C1E:  MOVLB  4
2C20:  CLRF   x59
2C22:  CLRF   x58
2C24:  CLRF   x57
2C26:  CLRF   x56
2C28:  MOVLB  0
2C2A:  CALL   1278
2C2E:  MOVFF  00,438
2C32:  MOVFF  01,439
2C36:  MOVFF  02,43A
2C3A:  MOVFF  03,43B
2C3E:  MOVFF  FEA,440
2C42:  MOVFF  FE9,43F
2C46:  BSF    FD8.1
2C48:  MOVFF  424,493
2C4C:  MOVFF  423,492
2C50:  MOVFF  422,491
2C54:  MOVFF  421,490
2C58:  MOVLB  4
2C5A:  CLRF   x97
2C5C:  CLRF   x96
2C5E:  MOVLW  30
2C60:  MOVWF  x95
2C62:  MOVLW  82
2C64:  MOVWF  x94
2C66:  MOVLB  0
2C68:  CALL   0BB4
2C6C:  MOVFF  440,FEA
2C70:  MOVFF  43F,FE9
2C74:  MOVFF  43B,493
2C78:  MOVFF  43A,492
2C7C:  MOVFF  439,491
2C80:  MOVFF  438,490
2C84:  MOVFF  03,497
2C88:  MOVFF  02,496
2C8C:  MOVFF  01,495
2C90:  MOVFF  00,494
2C94:  CALL   0960
2C98:  MOVFF  00,438
2C9C:  MOVFF  01,439
2CA0:  MOVFF  02,43A
2CA4:  MOVFF  03,43B
2CA8:  MOVFF  FEA,442
2CAC:  MOVFF  FE9,441
2CB0:  BCF    FD8.1
2CB2:  MOVFF  03,493
2CB6:  MOVFF  02,492
2CBA:  MOVFF  01,491
2CBE:  MOVFF  00,490
2CC2:  MOVFF  420,497
2CC6:  MOVFF  41F,496
2CCA:  MOVFF  41E,495
2CCE:  MOVFF  41D,494
2CD2:  CALL   0BB4
2CD6:  MOVFF  442,FEA
2CDA:  MOVFF  441,FE9
2CDE:  MOVFF  03,48F
2CE2:  MOVFF  02,48E
2CE6:  MOVFF  01,48D
2CEA:  MOVFF  00,48C
2CEE:  CALL   0EA6
2CF2:  MOVFF  01,438
2CF6:  MOVFF  435,443
2CFA:  MOVFF  436,444
2CFE:  MOVFF  437,445
2D02:  MOVFF  01,446
2D06:  MOVLW  01
2D08:  MOVLB  4
2D0A:  MOVWF  x47
2D0C:  MOVLB  0
2D0E:  CALL   24A6
....................       PE12864_line(aC, bC, (cos((156+test)*pi/180)*(r-7))+aC, (sin((156+test)*pi/180)*(r-7))+bC, ON); // minuto      
2D12:  MOVFF  41C,48F
2D16:  MOVFF  41B,48E
2D1A:  MOVFF  41A,48D
2D1E:  MOVFF  419,48C
2D22:  CALL   0EA6
2D26:  MOVFF  01,435
2D2A:  MOVFF  420,48F
2D2E:  MOVFF  41F,48E
2D32:  MOVFF  41E,48D
2D36:  MOVFF  41D,48C
2D3A:  CALL   0EA6
2D3E:  MOVFF  01,436
2D42:  MOVLW  9C
2D44:  MOVLB  4
2D46:  ADDWF  x2C,W
2D48:  CLRF   x91
2D4A:  MOVWF  x90
2D4C:  MOVLB  0
2D4E:  CALL   092A
2D52:  MOVFF  03,493
2D56:  MOVFF  02,492
2D5A:  MOVFF  01,491
2D5E:  MOVFF  00,490
2D62:  MOVLW  DB
2D64:  MOVLB  4
2D66:  MOVWF  x97
2D68:  MOVLW  0F
2D6A:  MOVWF  x96
2D6C:  MOVLW  49
2D6E:  MOVWF  x95
2D70:  MOVLW  80
2D72:  MOVWF  x94
2D74:  MOVLB  0
2D76:  CALL   0960
2D7A:  MOVFF  00,437
2D7E:  MOVFF  01,438
2D82:  MOVFF  02,439
2D86:  MOVFF  03,43A
2D8A:  MOVFF  03,459
2D8E:  MOVFF  02,458
2D92:  MOVFF  01,457
2D96:  MOVFF  00,456
2D9A:  MOVLB  4
2D9C:  CLRF   x5D
2D9E:  CLRF   x5C
2DA0:  MOVLW  34
2DA2:  MOVWF  x5B
2DA4:  MOVLW  86
2DA6:  MOVWF  x5A
2DA8:  MOVLB  0
2DAA:  CALL   0A56
2DAE:  MOVFF  00,437
2DB2:  MOVFF  01,438
2DB6:  MOVFF  02,439
2DBA:  MOVFF  03,43A
2DBE:  MOVFF  03,461
2DC2:  MOVFF  02,460
2DC6:  MOVFF  01,45F
2DCA:  MOVFF  00,45E
2DCE:  CALL   0EE2
2DD2:  MOVFF  00,437
2DD6:  MOVFF  01,438
2DDA:  MOVFF  02,439
2DDE:  MOVFF  03,43A
2DE2:  MOVFF  FEA,43C
2DE6:  MOVFF  FE9,43B
2DEA:  BSF    FD8.1
2DEC:  MOVFF  424,493
2DF0:  MOVFF  423,492
2DF4:  MOVFF  422,491
2DF8:  MOVFF  421,490
2DFC:  MOVLB  4
2DFE:  CLRF   x97
2E00:  CLRF   x96
2E02:  MOVLW  60
2E04:  MOVWF  x95
2E06:  MOVLW  81
2E08:  MOVWF  x94
2E0A:  MOVLB  0
2E0C:  CALL   0BB4
2E10:  MOVFF  43C,FEA
2E14:  MOVFF  43B,FE9
2E18:  MOVFF  43A,493
2E1C:  MOVFF  439,492
2E20:  MOVFF  438,491
2E24:  MOVFF  437,490
2E28:  MOVFF  03,497
2E2C:  MOVFF  02,496
2E30:  MOVFF  01,495
2E34:  MOVFF  00,494
2E38:  CALL   0960
2E3C:  MOVFF  00,437
2E40:  MOVFF  01,438
2E44:  MOVFF  02,439
2E48:  MOVFF  03,43A
2E4C:  MOVFF  FEA,43E
2E50:  MOVFF  FE9,43D
2E54:  BCF    FD8.1
2E56:  MOVFF  03,493
2E5A:  MOVFF  02,492
2E5E:  MOVFF  01,491
2E62:  MOVFF  00,490
2E66:  MOVFF  41C,497
2E6A:  MOVFF  41B,496
2E6E:  MOVFF  41A,495
2E72:  MOVFF  419,494
2E76:  CALL   0BB4
2E7A:  MOVFF  43E,FEA
2E7E:  MOVFF  43D,FE9
2E82:  MOVFF  03,48F
2E86:  MOVFF  02,48E
2E8A:  MOVFF  01,48D
2E8E:  MOVFF  00,48C
2E92:  CALL   0EA6
2E96:  MOVFF  01,437
2E9A:  MOVLW  9C
2E9C:  MOVLB  4
2E9E:  ADDWF  x2C,W
2EA0:  CLRF   x91
2EA2:  MOVWF  x90
2EA4:  MOVLB  0
2EA6:  CALL   092A
2EAA:  MOVFF  03,493
2EAE:  MOVFF  02,492
2EB2:  MOVFF  01,491
2EB6:  MOVFF  00,490
2EBA:  MOVLW  DB
2EBC:  MOVLB  4
2EBE:  MOVWF  x97
2EC0:  MOVLW  0F
2EC2:  MOVWF  x96
2EC4:  MOVLW  49
2EC6:  MOVWF  x95
2EC8:  MOVLW  80
2ECA:  MOVWF  x94
2ECC:  MOVLB  0
2ECE:  CALL   0960
2ED2:  MOVFF  00,438
2ED6:  MOVFF  01,439
2EDA:  MOVFF  02,43A
2EDE:  MOVFF  03,43B
2EE2:  MOVFF  03,459
2EE6:  MOVFF  02,458
2EEA:  MOVFF  01,457
2EEE:  MOVFF  00,456
2EF2:  MOVLB  4
2EF4:  CLRF   x5D
2EF6:  CLRF   x5C
2EF8:  MOVLW  34
2EFA:  MOVWF  x5B
2EFC:  MOVLW  86
2EFE:  MOVWF  x5A
2F00:  MOVLB  0
2F02:  CALL   0A56
2F06:  MOVFF  00,438
2F0A:  MOVFF  01,439
2F0E:  MOVFF  02,43A
2F12:  MOVFF  03,43B
2F16:  MOVFF  03,459
2F1A:  MOVFF  02,458
2F1E:  MOVFF  01,457
2F22:  MOVFF  00,456
2F26:  CALL   1278
2F2A:  MOVFF  00,438
2F2E:  MOVFF  01,439
2F32:  MOVFF  02,43A
2F36:  MOVFF  03,43B
2F3A:  MOVFF  FEA,440
2F3E:  MOVFF  FE9,43F
2F42:  BSF    FD8.1
2F44:  MOVFF  424,493
2F48:  MOVFF  423,492
2F4C:  MOVFF  422,491
2F50:  MOVFF  421,490
2F54:  MOVLB  4
2F56:  CLRF   x97
2F58:  CLRF   x96
2F5A:  MOVLW  60
2F5C:  MOVWF  x95
2F5E:  MOVLW  81
2F60:  MOVWF  x94
2F62:  MOVLB  0
2F64:  CALL   0BB4
2F68:  MOVFF  440,FEA
2F6C:  MOVFF  43F,FE9
2F70:  MOVFF  43B,493
2F74:  MOVFF  43A,492
2F78:  MOVFF  439,491
2F7C:  MOVFF  438,490
2F80:  MOVFF  03,497
2F84:  MOVFF  02,496
2F88:  MOVFF  01,495
2F8C:  MOVFF  00,494
2F90:  CALL   0960
2F94:  MOVFF  00,438
2F98:  MOVFF  01,439
2F9C:  MOVFF  02,43A
2FA0:  MOVFF  03,43B
2FA4:  MOVFF  FEA,442
2FA8:  MOVFF  FE9,441
2FAC:  BCF    FD8.1
2FAE:  MOVFF  03,493
2FB2:  MOVFF  02,492
2FB6:  MOVFF  01,491
2FBA:  MOVFF  00,490
2FBE:  MOVFF  420,497
2FC2:  MOVFF  41F,496
2FC6:  MOVFF  41E,495
2FCA:  MOVFF  41D,494
2FCE:  CALL   0BB4
2FD2:  MOVFF  442,FEA
2FD6:  MOVFF  441,FE9
2FDA:  MOVFF  03,48F
2FDE:  MOVFF  02,48E
2FE2:  MOVFF  01,48D
2FE6:  MOVFF  00,48C
2FEA:  CALL   0EA6
2FEE:  MOVFF  01,438
2FF2:  MOVFF  435,443
2FF6:  MOVFF  436,444
2FFA:  MOVFF  437,445
2FFE:  MOVFF  01,446
3002:  MOVLW  01
3004:  MOVLB  4
3006:  MOVWF  x47
3008:  MOVLB  0
300A:  CALL   24A6
....................       PE12864_line(aC, bC, x, y, ON); 
300E:  MOVFF  41C,48F
3012:  MOVFF  41B,48E
3016:  MOVFF  41A,48D
301A:  MOVFF  419,48C
301E:  CALL   0EA6
3022:  MOVFF  01,435
3026:  MOVFF  420,48F
302A:  MOVFF  41F,48E
302E:  MOVFF  41E,48D
3032:  MOVFF  41D,48C
3036:  CALL   0EA6
303A:  MOVFF  01,436
303E:  MOVFF  434,48F
3042:  MOVFF  433,48E
3046:  MOVFF  432,48D
304A:  MOVFF  431,48C
304E:  CALL   0EA6
3052:  MOVFF  01,437
3056:  MOVFF  430,48F
305A:  MOVFF  42F,48E
305E:  MOVFF  42E,48D
3062:  MOVFF  42D,48C
3066:  CALL   0EA6
306A:  MOVFF  01,438
306E:  MOVFF  435,443
3072:  MOVFF  436,444
3076:  MOVFF  437,445
307A:  MOVFF  01,446
307E:  MOVLW  01
3080:  MOVLB  4
3082:  MOVWF  x47
3084:  MOVLB  0
3086:  CALL   24A6
....................       mS = 0; 
308A:  MOVLB  4
308C:  CLRF   x28
308E:  CLRF   x27
....................       while(mS < 1000){ 
3090:  MOVF   x28,W
3092:  SUBLW  03
3094:  BNC   30C0
3096:  BNZ   309E
3098:  MOVF   x27,W
309A:  SUBLW  E7
309C:  BNC   30C0
....................          /*sprintf(chr,"%u:%u:%u %lu", H, M, S, mS); 
....................          PE12864_TextXy(3,5,chr);  */  
....................          PE12864_Gotoxy(0,0); 
309E:  CLRF   x5E
30A0:  CLRF   x5F
30A2:  MOVLB  0
30A4:  CALL   04B6
....................          /*if(S > 9) 
....................             printf(PE12864_Printchar,"%u:%u:%u", H, M, S); 
....................          else 
....................             printf(PE12864_Printchar,"%u:%u:0%u", H, M, S);*/ 
....................          mS+=1; 
30A8:  MOVLW  01
30AA:  MOVLB  4
30AC:  ADDWF  x27,F
30AE:  MOVLW  00
30B0:  ADDWFC x28,F
....................          delay_ms(1); 
30B2:  MOVLW  01
30B4:  MOVWF  x35
30B6:  MOVLB  0
30B8:  CALL   041E
....................       } 
30BC:  MOVLB  4
30BE:  BRA    3090
....................       S++; 
30C0:  INCF   x2B,F
....................       if(S>59){ 
30C2:  MOVF   x2B,W
30C4:  SUBLW  3B
30C6:  BTFSC  FD8.0
30C8:  BRA    33D0
....................          S=0; 
30CA:  CLRF   x2B
....................          M++; 
30CC:  INCF   x2A,F
....................          PE12864_line(aC, bC, (cos((156+test)*pi/180)*(r-7))+aC, (sin((156+test)*pi/180)*(r-7))+bC, OFF); // minuto               
30CE:  MOVFF  41C,48F
30D2:  MOVFF  41B,48E
30D6:  MOVFF  41A,48D
30DA:  MOVFF  419,48C
30DE:  MOVLB  0
30E0:  CALL   0EA6
30E4:  MOVFF  01,435
30E8:  MOVFF  420,48F
30EC:  MOVFF  41F,48E
30F0:  MOVFF  41E,48D
30F4:  MOVFF  41D,48C
30F8:  CALL   0EA6
30FC:  MOVFF  01,436
3100:  MOVLW  9C
3102:  MOVLB  4
3104:  ADDWF  x2C,W
3106:  CLRF   x91
3108:  MOVWF  x90
310A:  MOVLB  0
310C:  CALL   092A
3110:  MOVFF  03,493
3114:  MOVFF  02,492
3118:  MOVFF  01,491
311C:  MOVFF  00,490
3120:  MOVLW  DB
3122:  MOVLB  4
3124:  MOVWF  x97
3126:  MOVLW  0F
3128:  MOVWF  x96
312A:  MOVLW  49
312C:  MOVWF  x95
312E:  MOVLW  80
3130:  MOVWF  x94
3132:  MOVLB  0
3134:  CALL   0960
3138:  MOVFF  00,437
313C:  MOVFF  01,438
3140:  MOVFF  02,439
3144:  MOVFF  03,43A
3148:  MOVFF  03,459
314C:  MOVFF  02,458
3150:  MOVFF  01,457
3154:  MOVFF  00,456
3158:  MOVLB  4
315A:  CLRF   x5D
315C:  CLRF   x5C
315E:  MOVLW  34
3160:  MOVWF  x5B
3162:  MOVLW  86
3164:  MOVWF  x5A
3166:  MOVLB  0
3168:  CALL   0A56
316C:  MOVFF  00,437
3170:  MOVFF  01,438
3174:  MOVFF  02,439
3178:  MOVFF  03,43A
317C:  MOVFF  03,461
3180:  MOVFF  02,460
3184:  MOVFF  01,45F
3188:  MOVFF  00,45E
318C:  CALL   0EE2
3190:  MOVFF  00,437
3194:  MOVFF  01,438
3198:  MOVFF  02,439
319C:  MOVFF  03,43A
31A0:  MOVFF  FEA,43C
31A4:  MOVFF  FE9,43B
31A8:  BSF    FD8.1
31AA:  MOVFF  424,493
31AE:  MOVFF  423,492
31B2:  MOVFF  422,491
31B6:  MOVFF  421,490
31BA:  MOVLB  4
31BC:  CLRF   x97
31BE:  CLRF   x96
31C0:  MOVLW  60
31C2:  MOVWF  x95
31C4:  MOVLW  81
31C6:  MOVWF  x94
31C8:  MOVLB  0
31CA:  CALL   0BB4
31CE:  MOVFF  43C,FEA
31D2:  MOVFF  43B,FE9
31D6:  MOVFF  43A,493
31DA:  MOVFF  439,492
31DE:  MOVFF  438,491
31E2:  MOVFF  437,490
31E6:  MOVFF  03,497
31EA:  MOVFF  02,496
31EE:  MOVFF  01,495
31F2:  MOVFF  00,494
31F6:  CALL   0960
31FA:  MOVFF  00,437
31FE:  MOVFF  01,438
3202:  MOVFF  02,439
3206:  MOVFF  03,43A
320A:  MOVFF  FEA,43E
320E:  MOVFF  FE9,43D
3212:  BCF    FD8.1
3214:  MOVFF  03,493
3218:  MOVFF  02,492
321C:  MOVFF  01,491
3220:  MOVFF  00,490
3224:  MOVFF  41C,497
3228:  MOVFF  41B,496
322C:  MOVFF  41A,495
3230:  MOVFF  419,494
3234:  CALL   0BB4
3238:  MOVFF  43E,FEA
323C:  MOVFF  43D,FE9
3240:  MOVFF  03,48F
3244:  MOVFF  02,48E
3248:  MOVFF  01,48D
324C:  MOVFF  00,48C
3250:  CALL   0EA6
3254:  MOVFF  01,437
3258:  MOVLW  9C
325A:  MOVLB  4
325C:  ADDWF  x2C,W
325E:  CLRF   x91
3260:  MOVWF  x90
3262:  MOVLB  0
3264:  CALL   092A
3268:  MOVFF  03,493
326C:  MOVFF  02,492
3270:  MOVFF  01,491
3274:  MOVFF  00,490
3278:  MOVLW  DB
327A:  MOVLB  4
327C:  MOVWF  x97
327E:  MOVLW  0F
3280:  MOVWF  x96
3282:  MOVLW  49
3284:  MOVWF  x95
3286:  MOVLW  80
3288:  MOVWF  x94
328A:  MOVLB  0
328C:  CALL   0960
3290:  MOVFF  00,438
3294:  MOVFF  01,439
3298:  MOVFF  02,43A
329C:  MOVFF  03,43B
32A0:  MOVFF  03,459
32A4:  MOVFF  02,458
32A8:  MOVFF  01,457
32AC:  MOVFF  00,456
32B0:  MOVLB  4
32B2:  CLRF   x5D
32B4:  CLRF   x5C
32B6:  MOVLW  34
32B8:  MOVWF  x5B
32BA:  MOVLW  86
32BC:  MOVWF  x5A
32BE:  MOVLB  0
32C0:  CALL   0A56
32C4:  MOVFF  00,438
32C8:  MOVFF  01,439
32CC:  MOVFF  02,43A
32D0:  MOVFF  03,43B
32D4:  MOVFF  03,459
32D8:  MOVFF  02,458
32DC:  MOVFF  01,457
32E0:  MOVFF  00,456
32E4:  CALL   1278
32E8:  MOVFF  00,438
32EC:  MOVFF  01,439
32F0:  MOVFF  02,43A
32F4:  MOVFF  03,43B
32F8:  MOVFF  FEA,440
32FC:  MOVFF  FE9,43F
3300:  BSF    FD8.1
3302:  MOVFF  424,493
3306:  MOVFF  423,492
330A:  MOVFF  422,491
330E:  MOVFF  421,490
3312:  MOVLB  4
3314:  CLRF   x97
3316:  CLRF   x96
3318:  MOVLW  60
331A:  MOVWF  x95
331C:  MOVLW  81
331E:  MOVWF  x94
3320:  MOVLB  0
3322:  CALL   0BB4
3326:  MOVFF  440,FEA
332A:  MOVFF  43F,FE9
332E:  MOVFF  43B,493
3332:  MOVFF  43A,492
3336:  MOVFF  439,491
333A:  MOVFF  438,490
333E:  MOVFF  03,497
3342:  MOVFF  02,496
3346:  MOVFF  01,495
334A:  MOVFF  00,494
334E:  CALL   0960
3352:  MOVFF  00,438
3356:  MOVFF  01,439
335A:  MOVFF  02,43A
335E:  MOVFF  03,43B
3362:  MOVFF  FEA,442
3366:  MOVFF  FE9,441
336A:  BCF    FD8.1
336C:  MOVFF  03,493
3370:  MOVFF  02,492
3374:  MOVFF  01,491
3378:  MOVFF  00,490
337C:  MOVFF  420,497
3380:  MOVFF  41F,496
3384:  MOVFF  41E,495
3388:  MOVFF  41D,494
338C:  CALL   0BB4
3390:  MOVFF  442,FEA
3394:  MOVFF  441,FE9
3398:  MOVFF  03,48F
339C:  MOVFF  02,48E
33A0:  MOVFF  01,48D
33A4:  MOVFF  00,48C
33A8:  CALL   0EA6
33AC:  MOVFF  01,438
33B0:  MOVFF  435,443
33B4:  MOVFF  436,444
33B8:  MOVFF  437,445
33BC:  MOVFF  01,446
33C0:  MOVLB  4
33C2:  CLRF   x47
33C4:  MOVLB  0
33C6:  CALL   24A6
....................          test+=6; 
33CA:  MOVLW  06
33CC:  MOVLB  4
33CE:  ADDWF  x2C,F
....................       } 
....................       //delay_ms(1000); 
....................       PE12864_line(aC, bC, x, y, OFF); 
33D0:  MOVFF  41C,48F
33D4:  MOVFF  41B,48E
33D8:  MOVFF  41A,48D
33DC:  MOVFF  419,48C
33E0:  MOVLB  0
33E2:  CALL   0EA6
33E6:  MOVFF  01,435
33EA:  MOVFF  420,48F
33EE:  MOVFF  41F,48E
33F2:  MOVFF  41E,48D
33F6:  MOVFF  41D,48C
33FA:  CALL   0EA6
33FE:  MOVFF  01,436
3402:  MOVFF  434,48F
3406:  MOVFF  433,48E
340A:  MOVFF  432,48D
340E:  MOVFF  431,48C
3412:  CALL   0EA6
3416:  MOVFF  01,437
341A:  MOVFF  430,48F
341E:  MOVFF  42F,48E
3422:  MOVFF  42E,48D
3426:  MOVFF  42D,48C
342A:  CALL   0EA6
342E:  MOVFF  01,438
3432:  MOVFF  435,443
3436:  MOVFF  436,444
343A:  MOVFF  437,445
343E:  MOVFF  01,446
3442:  MOVLB  4
3444:  CLRF   x47
3446:  MOVLB  0
3448:  CALL   24A6
....................       i+=6; 
344C:  MOVLW  06
344E:  MOVLB  4
3450:  ADDWF  x25,F
3452:  MOVLW  00
3454:  ADDWFC x26,F
....................    }    
3456:  GOTO   288E
.................... } 
345A:  MOVLB  0
345C:  GOTO   3506 (RETURN)
.................... void circuloNumerico(float aC, float bC, float r){ 
*
2002:  MOVLB  4
2004:  CLRF   x42
2006:  CLRF   x41
2008:  CLRF   x44
200A:  MOVLW  03
200C:  MOVWF  x43
....................    int16 i = 0, val = 3; 
....................    char chr[5]; 
....................    float y, x; 
....................    while(i <= 360){ 
200E:  MOVF   x42,W
2010:  SUBLW  01
2012:  BTFSS  FD8.0
2014:  BRA    2454
2016:  BNZ   2020
2018:  MOVF   x41,W
201A:  SUBLW  68
201C:  BTFSS  FD8.0
201E:  BRA    2454
....................       y = (sin(i*pi/180)*r)+bC; 
2020:  MOVFF  442,491
2024:  MOVFF  441,490
2028:  MOVLB  0
202A:  CALL   092A
202E:  MOVFF  03,493
2032:  MOVFF  02,492
2036:  MOVFF  01,491
203A:  MOVFF  00,490
203E:  MOVLW  DB
2040:  MOVLB  4
2042:  MOVWF  x97
2044:  MOVLW  0F
2046:  MOVWF  x96
2048:  MOVLW  49
204A:  MOVWF  x95
204C:  MOVLW  80
204E:  MOVWF  x94
2050:  MOVLB  0
2052:  CALL   0960
2056:  MOVFF  00,452
205A:  MOVFF  01,453
205E:  MOVFF  02,454
2062:  MOVFF  03,455
2066:  MOVFF  03,459
206A:  MOVFF  02,458
206E:  MOVFF  01,457
2072:  MOVFF  00,456
2076:  MOVLB  4
2078:  CLRF   x5D
207A:  CLRF   x5C
207C:  MOVLW  34
207E:  MOVWF  x5B
2080:  MOVLW  86
2082:  MOVWF  x5A
2084:  MOVLB  0
2086:  CALL   0A56
208A:  MOVFF  00,452
208E:  MOVFF  01,453
2092:  MOVFF  02,454
2096:  MOVFF  03,455
209A:  MOVFF  03,459
209E:  MOVFF  02,458
20A2:  MOVFF  01,457
20A6:  MOVFF  00,456
20AA:  CALL   1278
20AE:  MOVFF  00,452
20B2:  MOVFF  01,453
20B6:  MOVFF  02,454
20BA:  MOVFF  03,455
20BE:  MOVFF  03,493
20C2:  MOVFF  02,492
20C6:  MOVFF  01,491
20CA:  MOVFF  00,490
20CE:  MOVFF  440,497
20D2:  MOVFF  43F,496
20D6:  MOVFF  43E,495
20DA:  MOVFF  43D,494
20DE:  CALL   0960
20E2:  MOVFF  00,452
20E6:  MOVFF  01,453
20EA:  MOVFF  02,454
20EE:  MOVFF  03,455
20F2:  MOVFF  FEA,457
20F6:  MOVFF  FE9,456
20FA:  BCF    FD8.1
20FC:  MOVFF  03,493
2100:  MOVFF  02,492
2104:  MOVFF  01,491
2108:  MOVFF  00,490
210C:  MOVFF  43C,497
2110:  MOVFF  43B,496
2114:  MOVFF  43A,495
2118:  MOVFF  439,494
211C:  CALL   0BB4
2120:  MOVFF  457,FEA
2124:  MOVFF  456,FE9
2128:  MOVFF  03,44D
212C:  MOVFF  02,44C
2130:  MOVFF  01,44B
2134:  MOVFF  00,44A
....................       x = (cos(i*pi/180)*r)+aC;        
2138:  MOVFF  442,491
213C:  MOVFF  441,490
2140:  CALL   092A
2144:  MOVFF  03,493
2148:  MOVFF  02,492
214C:  MOVFF  01,491
2150:  MOVFF  00,490
2154:  MOVLW  DB
2156:  MOVLB  4
2158:  MOVWF  x97
215A:  MOVLW  0F
215C:  MOVWF  x96
215E:  MOVLW  49
2160:  MOVWF  x95
2162:  MOVLW  80
2164:  MOVWF  x94
2166:  MOVLB  0
2168:  CALL   0960
216C:  MOVFF  00,452
2170:  MOVFF  01,453
2174:  MOVFF  02,454
2178:  MOVFF  03,455
217C:  MOVFF  03,459
2180:  MOVFF  02,458
2184:  MOVFF  01,457
2188:  MOVFF  00,456
218C:  MOVLB  4
218E:  CLRF   x5D
2190:  CLRF   x5C
2192:  MOVLW  34
2194:  MOVWF  x5B
2196:  MOVLW  86
2198:  MOVWF  x5A
219A:  MOVLB  0
219C:  CALL   0A56
21A0:  MOVFF  00,452
21A4:  MOVFF  01,453
21A8:  MOVFF  02,454
21AC:  MOVFF  03,455
21B0:  MOVFF  03,461
21B4:  MOVFF  02,460
21B8:  MOVFF  01,45F
21BC:  MOVFF  00,45E
21C0:  CALL   0EE2
21C4:  MOVFF  00,452
21C8:  MOVFF  01,453
21CC:  MOVFF  02,454
21D0:  MOVFF  03,455
21D4:  MOVFF  03,493
21D8:  MOVFF  02,492
21DC:  MOVFF  01,491
21E0:  MOVFF  00,490
21E4:  MOVFF  440,497
21E8:  MOVFF  43F,496
21EC:  MOVFF  43E,495
21F0:  MOVFF  43D,494
21F4:  CALL   0960
21F8:  MOVFF  00,452
21FC:  MOVFF  01,453
2200:  MOVFF  02,454
2204:  MOVFF  03,455
2208:  MOVFF  FEA,457
220C:  MOVFF  FE9,456
2210:  BCF    FD8.1
2212:  MOVFF  03,493
2216:  MOVFF  02,492
221A:  MOVFF  01,491
221E:  MOVFF  00,490
2222:  MOVFF  438,497
2226:  MOVFF  437,496
222A:  MOVFF  436,495
222E:  MOVFF  435,494
2232:  CALL   0BB4
2236:  MOVFF  457,FEA
223A:  MOVFF  456,FE9
223E:  MOVFF  03,451
2242:  MOVFF  02,450
2246:  MOVFF  01,44F
224A:  MOVFF  00,44E
....................       //PE12864_Putpixel(x, y, ON);       
....................       if(!(i%30)){ 
224E:  MOVFF  442,453
2252:  MOVFF  441,452
2256:  MOVLB  4
2258:  CLRF   x55
225A:  MOVLW  1E
225C:  MOVWF  x54
225E:  MOVLB  0
2260:  BRA    1CE2
2262:  MOVF   00,W
2264:  IORWF  03,W
2266:  BTFSS  FD8.2
2268:  BRA    2448
....................          sprintf(chr,"%lu", val); 
226A:  MOVLW  04
226C:  MOVLB  4
226E:  MOVWF  x0E
2270:  MOVLW  45
2272:  MOVWF  x0D
2274:  MOVLW  10
2276:  MOVWF  FE9
2278:  MOVFF  444,453
227C:  MOVFF  443,452
2280:  MOVLB  0
2282:  BRA    1D2A
....................          // -- Resolver Bugs :   Inicio  
....................          if(val == 9) 
2284:  MOVLB  4
2286:  MOVF   x43,W
2288:  SUBLW  09
228A:  BNZ   22C4
228C:  MOVF   x44,F
228E:  BNZ   22C4
....................             y+=1; 
2290:  BCF    FD8.1
2292:  MOVFF  44D,493
2296:  MOVFF  44C,492
229A:  MOVFF  44B,491
229E:  MOVFF  44A,490
22A2:  CLRF   x97
22A4:  CLRF   x96
22A6:  CLRF   x95
22A8:  MOVLW  7F
22AA:  MOVWF  x94
22AC:  MOVLB  0
22AE:  CALL   0BB4
22B2:  MOVFF  03,44D
22B6:  MOVFF  02,44C
22BA:  MOVFF  01,44B
22BE:  MOVFF  00,44A
22C2:  MOVLB  4
....................          if(val == 10){ 
22C4:  MOVF   x43,W
22C6:  SUBLW  0A
22C8:  BNZ   2336
22CA:  MOVF   x44,F
22CC:  BNZ   2336
....................             y+=2; 
22CE:  BCF    FD8.1
22D0:  MOVFF  44D,493
22D4:  MOVFF  44C,492
22D8:  MOVFF  44B,491
22DC:  MOVFF  44A,490
22E0:  CLRF   x97
22E2:  CLRF   x96
22E4:  CLRF   x95
22E6:  MOVLW  80
22E8:  MOVWF  x94
22EA:  MOVLB  0
22EC:  CALL   0BB4
22F0:  MOVFF  03,44D
22F4:  MOVFF  02,44C
22F8:  MOVFF  01,44B
22FC:  MOVFF  00,44A
....................             x-=1; 
2300:  BSF    FD8.1
2302:  MOVFF  451,493
2306:  MOVFF  450,492
230A:  MOVFF  44F,491
230E:  MOVFF  44E,490
2312:  MOVLB  4
2314:  CLRF   x97
2316:  CLRF   x96
2318:  CLRF   x95
231A:  MOVLW  7F
231C:  MOVWF  x94
231E:  MOVLB  0
2320:  CALL   0BB4
2324:  MOVFF  03,451
2328:  MOVFF  02,450
232C:  MOVFF  01,44F
2330:  MOVFF  00,44E
2334:  MOVLB  4
....................          } 
....................          if(val == 11){ 
2336:  MOVF   x43,W
2338:  SUBLW  0B
233A:  BNZ   23AA
233C:  MOVF   x44,F
233E:  BNZ   23AA
....................             y+=1; 
2340:  BCF    FD8.1
2342:  MOVFF  44D,493
2346:  MOVFF  44C,492
234A:  MOVFF  44B,491
234E:  MOVFF  44A,490
2352:  CLRF   x97
2354:  CLRF   x96
2356:  CLRF   x95
2358:  MOVLW  7F
235A:  MOVWF  x94
235C:  MOVLB  0
235E:  CALL   0BB4
2362:  MOVFF  03,44D
2366:  MOVFF  02,44C
236A:  MOVFF  01,44B
236E:  MOVFF  00,44A
....................             x-=3; 
2372:  BSF    FD8.1
2374:  MOVFF  451,493
2378:  MOVFF  450,492
237C:  MOVFF  44F,491
2380:  MOVFF  44E,490
2384:  MOVLB  4
2386:  CLRF   x97
2388:  CLRF   x96
238A:  MOVLW  40
238C:  MOVWF  x95
238E:  MOVLW  80
2390:  MOVWF  x94
2392:  MOVLB  0
2394:  CALL   0BB4
2398:  MOVFF  03,451
239C:  MOVFF  02,450
23A0:  MOVFF  01,44F
23A4:  MOVFF  00,44E
23A8:  MOVLB  4
....................          } 
....................          if(val == 12) 
23AA:  MOVF   x43,W
23AC:  SUBLW  0C
23AE:  BNZ   23E8
23B0:  MOVF   x44,F
23B2:  BNZ   23E8
....................             x-=3;             
23B4:  BSF    FD8.1
23B6:  MOVFF  451,493
23BA:  MOVFF  450,492
23BE:  MOVFF  44F,491
23C2:  MOVFF  44E,490
23C6:  CLRF   x97
23C8:  CLRF   x96
23CA:  MOVLW  40
23CC:  MOVWF  x95
23CE:  MOVLW  80
23D0:  MOVWF  x94
23D2:  MOVLB  0
23D4:  CALL   0BB4
23D8:  MOVFF  03,451
23DC:  MOVFF  02,450
23E0:  MOVFF  01,44F
23E4:  MOVFF  00,44E
....................          // -- Resolver Bugs :   Fim             
....................          PE12864_TextXy(x,y,chr); 
23E8:  MOVFF  451,48F
23EC:  MOVFF  450,48E
23F0:  MOVFF  44F,48D
23F4:  MOVFF  44E,48C
23F8:  MOVLB  0
23FA:  CALL   0EA6
23FE:  MOVFF  01,452
2402:  MOVFF  44D,48F
2406:  MOVFF  44C,48E
240A:  MOVFF  44B,48D
240E:  MOVFF  44A,48C
2412:  CALL   0EA6
2416:  MOVFF  01,453
241A:  MOVFF  452,454
241E:  MOVFF  01,455
2422:  MOVLW  04
2424:  MOVLB  4
2426:  MOVWF  x57
2428:  MOVLW  45
242A:  MOVWF  x56
242C:  MOVLB  0
242E:  BRA    1DEA
....................          val++; 
2430:  MOVLB  4
2432:  INCF   x43,F
2434:  BTFSC  FD8.2
2436:  INCF   x44,F
....................          if(val > 12)    // 9: 1B 0T || 10: 2B 1T || 11: 1B 1T || 12: 0B 3T 
2438:  MOVF   x44,F
243A:  BNZ   2442
243C:  MOVF   x43,W
243E:  SUBLW  0C
2440:  BC    2448
....................             val = 1; 
2442:  CLRF   x44
2444:  MOVLW  01
2446:  MOVWF  x43
....................       } 
....................       i+=30; 
2448:  MOVLW  1E
244A:  MOVLB  4
244C:  ADDWF  x41,F
244E:  MOVLW  00
2450:  ADDWFC x42,F
....................    } 
2452:  BRA    200E
.................... } 
2454:  MOVLB  0
2456:  RETLW  00
.................... void PE12864_TextXy(int x, int y, char* cvar){ 
*
1DEA:  MOVLB  4
1DEC:  CLRF   x59
....................    int i, loop = 0; 
....................    char c1, c2, chr; 
....................    while(loop < strlen(cvar)){  
1DEE:  MOVFF  457,45E
1DF2:  MOVFF  456,45D
1DF6:  MOVLB  0
1DF8:  CALL   06F0
1DFC:  MOVF   01,W
1DFE:  MOVLB  4
1E00:  SUBWF  x59,W
1E02:  BTFSC  FD8.0
1E04:  BRA    1FFC
....................       chr = cvar[loop]; 
1E06:  CLRF   03
1E08:  MOVF   x59,W
1E0A:  ADDWF  x56,W
1E0C:  MOVWF  FE9
1E0E:  MOVF   x57,W
1E10:  ADDWFC 03,W
1E12:  MOVWF  FEA
1E14:  MOVFF  FEF,45C
....................       for(i=0;i<5;i++){ 
1E18:  CLRF   x58
1E1A:  MOVF   x58,W
1E1C:  SUBLW  04
1E1E:  BTFSS  FD8.0
1E20:  BRA    1FF6
....................          if (chr < 0x53){ 
1E22:  MOVF   x5C,W
1E24:  SUBLW  52
1E26:  BNC   1EA2
....................             c1 = TEXT[chr-0x20][i] <<(y%8); 
1E28:  MOVLW  20
1E2A:  SUBWF  x5C,W
1E2C:  MULLW  05
1E2E:  MOVF   FF3,W
1E30:  CLRF   x5E
1E32:  MOVWF  x5D
1E34:  CLRF   03
1E36:  MOVF   x58,W
1E38:  ADDWF  x5D,W
1E3A:  MOVWF  01
1E3C:  MOVF   x5E,W
1E3E:  ADDWFC 03,F
1E40:  MOVF   01,W
1E42:  MOVLB  0
1E44:  CALL   0004
1E48:  MOVLB  4
1E4A:  MOVWF  x5D
1E4C:  MOVF   x55,W
1E4E:  ANDLW  07
1E50:  MOVWF  01
1E52:  MOVFF  45D,45A
1E56:  MOVF   01,F
1E58:  BZ    1E62
1E5A:  BCF    FD8.0
1E5C:  RLCF   x5A,F
1E5E:  DECFSZ 01,F
1E60:  BRA    1E5A
....................             c2 = TEXT[chr-0x20][i] >>(8-(y%8));                
1E62:  MOVLW  20
1E64:  SUBWF  x5C,W
1E66:  MULLW  05
1E68:  MOVF   FF3,W
1E6A:  CLRF   x5E
1E6C:  MOVWF  x5D
1E6E:  CLRF   03
1E70:  MOVF   x58,W
1E72:  ADDWF  x5D,W
1E74:  MOVWF  01
1E76:  MOVF   x5E,W
1E78:  ADDWFC 03,F
1E7A:  MOVF   01,W
1E7C:  MOVLB  0
1E7E:  CALL   0004
1E82:  MOVLB  4
1E84:  MOVWF  x5D
1E86:  MOVF   x55,W
1E88:  ANDLW  07
1E8A:  XORLW  FF
1E8C:  ADDLW  09
1E8E:  MOVWF  01
1E90:  MOVFF  45D,45B
1E94:  MOVF   01,F
1E96:  BZ    1EA0
1E98:  BCF    FD8.0
1E9A:  RRCF   x5B,F
1E9C:  DECFSZ 01,F
1E9E:  BRA    1E98
....................          } 
....................          else { 
1EA0:  BRA    1F1A
....................             c1 = TEXT2[chr-0x53][i] <<(y%8); 
1EA2:  MOVLW  53
1EA4:  SUBWF  x5C,W
1EA6:  MULLW  05
1EA8:  MOVF   FF3,W
1EAA:  CLRF   x5E
1EAC:  MOVWF  x5D
1EAE:  CLRF   03
1EB0:  MOVF   x58,W
1EB2:  ADDWF  x5D,W
1EB4:  MOVWF  01
1EB6:  MOVF   x5E,W
1EB8:  ADDWFC 03,F
1EBA:  MOVF   01,W
1EBC:  MOVLB  0
1EBE:  CALL   0114
1EC2:  MOVLB  4
1EC4:  MOVWF  x5D
1EC6:  MOVF   x55,W
1EC8:  ANDLW  07
1ECA:  MOVWF  01
1ECC:  MOVFF  45D,45A
1ED0:  MOVF   01,F
1ED2:  BZ    1EDC
1ED4:  BCF    FD8.0
1ED6:  RLCF   x5A,F
1ED8:  DECFSZ 01,F
1EDA:  BRA    1ED4
....................             c2 = TEXT2[chr-0x53][i] >>(8-(y%8)); 
1EDC:  MOVLW  53
1EDE:  SUBWF  x5C,W
1EE0:  MULLW  05
1EE2:  MOVF   FF3,W
1EE4:  CLRF   x5E
1EE6:  MOVWF  x5D
1EE8:  CLRF   03
1EEA:  MOVF   x58,W
1EEC:  ADDWF  x5D,W
1EEE:  MOVWF  01
1EF0:  MOVF   x5E,W
1EF2:  ADDWFC 03,F
1EF4:  MOVF   01,W
1EF6:  MOVLB  0
1EF8:  CALL   0114
1EFC:  MOVLB  4
1EFE:  MOVWF  x5D
1F00:  MOVF   x55,W
1F02:  ANDLW  07
1F04:  XORLW  FF
1F06:  ADDLW  09
1F08:  MOVWF  01
1F0A:  MOVFF  45D,45B
1F0E:  MOVF   01,F
1F10:  BZ    1F1A
1F12:  BCF    FD8.0
1F14:  RRCF   x5B,F
1F16:  DECFSZ 01,F
1F18:  BRA    1F12
....................          } 
....................          PE12864_Gotoxy(x,(y/8));       
1F1A:  RRCF   x55,W
1F1C:  MOVWF  x5D
1F1E:  RRCF   x5D,F
1F20:  RRCF   x5D,F
1F22:  MOVLW  1F
1F24:  ANDWF  x5D,F
1F26:  MOVFF  454,45E
1F2A:  MOVFF  45D,45F
1F2E:  MOVLB  0
1F30:  CALL   04B6
....................          c1 |= buffer[x][y/8];          
1F34:  MOVLB  4
1F36:  CLRF   x5F
1F38:  MOVFF  454,45E
1F3C:  CLRF   x61
1F3E:  MOVLW  08
1F40:  MOVWF  x60
1F42:  MOVLB  0
1F44:  CALL   052A
1F48:  MOVFF  01,45D
1F4C:  MOVLB  4
1F4E:  RRCF   x55,W
1F50:  MOVWF  00
1F52:  RRCF   00,F
1F54:  RRCF   00,F
1F56:  MOVLW  1F
1F58:  ANDWF  00,F
1F5A:  MOVF   00,W
1F5C:  ADDWF  01,W
1F5E:  MOVWF  01
1F60:  MOVLW  00
1F62:  ADDWFC 02,W
1F64:  MOVWF  03
1F66:  MOVF   01,W
1F68:  ADDLW  07
1F6A:  MOVWF  FE9
1F6C:  MOVLW  00
1F6E:  ADDWFC 03,W
1F70:  MOVWF  FEA
1F72:  MOVF   FEF,W
1F74:  IORWF  x5A,F
....................          PE12864_Write_data(c1);                
1F76:  MOVFF  45A,45D
1F7A:  MOVLB  0
1F7C:  CALL   054C
....................          PE12864_Gotoxy(x,(y/8)+1);       
1F80:  MOVLB  4
1F82:  RRCF   x55,W
1F84:  MOVWF  00
1F86:  RRCF   00,F
1F88:  RRCF   00,F
1F8A:  MOVLW  1F
1F8C:  ANDWF  00,F
1F8E:  MOVF   00,W
1F90:  ADDLW  01
1F92:  MOVWF  x5D
1F94:  MOVFF  454,45E
1F98:  MOVWF  x5F
1F9A:  MOVLB  0
1F9C:  CALL   04B6
....................          c2 |= buffer[x][(y/8)+1]; 
1FA0:  MOVLB  4
1FA2:  CLRF   x5F
1FA4:  MOVFF  454,45E
1FA8:  CLRF   x61
1FAA:  MOVLW  08
1FAC:  MOVWF  x60
1FAE:  MOVLB  0
1FB0:  CALL   052A
1FB4:  MOVFF  01,45D
1FB8:  MOVLB  4
1FBA:  RRCF   x55,W
1FBC:  MOVWF  00
1FBE:  RRCF   00,F
1FC0:  RRCF   00,F
1FC2:  MOVLW  1F
1FC4:  ANDWF  00,F
1FC6:  MOVF   00,W
1FC8:  ADDLW  01
1FCA:  ADDWF  01,W
1FCC:  MOVWF  01
1FCE:  MOVLW  00
1FD0:  ADDWFC 02,W
1FD2:  MOVWF  03
1FD4:  MOVF   01,W
1FD6:  ADDLW  07
1FD8:  MOVWF  FE9
1FDA:  MOVLW  00
1FDC:  ADDWFC 03,W
1FDE:  MOVWF  FEA
1FE0:  MOVF   FEF,W
1FE2:  IORWF  x5B,F
....................          PE12864_Write_data(c2); 
1FE4:  MOVFF  45B,45D
1FE8:  MOVLB  0
1FEA:  CALL   054C
....................          x++; 
1FEE:  MOVLB  4
1FF0:  INCF   x54,F
....................       } 
1FF2:  INCF   x58,F
1FF4:  BRA    1E1A
....................       x++; 
1FF6:  INCF   x54,F
....................       loop++; 
1FF8:  INCF   x59,F
....................    } 
1FFA:  BRA    1DEE
.................... } 
1FFC:  MOVLB  0
1FFE:  GOTO   2430 (RETURN)
.................... void PrintBigNumber(char* c){ 
*
072A:  MOVLB  4
072C:  CLRF   x1C
072E:  CLRF   x1D
0730:  CLRF   x1E
....................    int i, x = 0, loop = 0, l = 0; 
....................    char cvar; 
....................    while(loop < strlen(c)){    
0732:  MOVFF  41A,45E
0736:  MOVFF  419,45D
073A:  MOVLB  0
073C:  RCALL  06F0
073E:  MOVF   01,W
0740:  MOVLB  4
0742:  SUBWF  x1D,W
0744:  BC    07E2
....................       cvar = c[loop]; 
0746:  CLRF   03
0748:  MOVF   x1D,W
074A:  ADDWF  x19,W
074C:  MOVWF  FE9
074E:  MOVF   x1A,W
0750:  ADDWFC 03,W
0752:  MOVWF  FEA
0754:  MOVFF  FEF,41F
....................       for(i=0; i<45; i++){ 
0758:  CLRF   x1B
075A:  MOVF   x1B,W
075C:  SUBLW  2C
075E:  BNC   07D8
....................          if(!(i%15)) 
0760:  MOVFF  41B,463
0764:  MOVLW  0F
0766:  MOVWF  x64
0768:  MOVLB  0
076A:  RCALL  048A
076C:  MOVF   00,W
076E:  BNZ   0774
....................             x = l; 
0770:  MOVFF  41E,41C
....................          PE12864_Gotoxy(x,i/15); 
0774:  MOVFF  41B,463
0778:  MOVLW  0F
077A:  MOVLB  4
077C:  MOVWF  x64
077E:  MOVLB  0
0780:  RCALL  048A
0782:  MOVFF  01,420
0786:  MOVFF  41C,45E
078A:  MOVFF  01,45F
078E:  RCALL  04B6
....................          PE12864_Write_data(bigNumber[cvar-0x30][i]); 
0790:  MOVLW  30
0792:  MOVLB  4
0794:  SUBWF  x1F,W
0796:  MOVWF  x21
0798:  CLRF   x5F
079A:  MOVWF  x5E
079C:  CLRF   x61
079E:  MOVLW  2D
07A0:  MOVWF  x60
07A2:  MOVLB  0
07A4:  RCALL  052A
07A6:  MOVFF  02,421
07AA:  MOVFF  01,420
07AE:  MOVLB  4
07B0:  MOVF   x1B,W
07B2:  ADDWF  01,W
07B4:  MOVWF  01
07B6:  MOVLW  00
07B8:  ADDWFC 02,W
07BA:  MOVWF  03
07BC:  MOVF   01,W
07BE:  MOVFF  03,FF7
07C2:  MOVLB  0
07C4:  RCALL  0200
07C6:  MOVLB  4
07C8:  MOVWF  x20
07CA:  MOVWF  x5D
07CC:  MOVLB  0
07CE:  RCALL  054C
....................          x++; 
07D0:  MOVLB  4
07D2:  INCF   x1C,F
....................       } 
07D4:  INCF   x1B,F
07D6:  BRA    075A
....................       l+=14; 
07D8:  MOVLW  0E
07DA:  ADDWF  x1E,F
....................       x++; 
07DC:  INCF   x1C,F
....................       loop++; 
07DE:  INCF   x1D,F
....................    } 
07E0:  BRA    0732
.................... } 
07E2:  MOVLB  0
07E4:  GOTO   355C (RETURN)
.................... void circuloFechado(float aC, float bC, float r){ 
....................    int16 i = 0; 
....................    float y, x; 
....................    while(i <= 360){ 
....................       y = (sin(i*pi/180)*r)+bC; 
....................       x = (cos(i*pi/180)*r)+aC; 
....................       PE12864_line(aC, bC, x, y, ON);       
....................       i++; 
....................    }    
.................... } 
.................... void relogioAnalogico(){ 
....................    circulo(96, 32, 32); 
*
3460:  MOVLB  4
3462:  CLRF   x1C
3464:  CLRF   x1B
3466:  MOVLW  40
3468:  MOVWF  x1A
346A:  MOVLW  85
346C:  MOVWF  x19
346E:  CLRF   x20
3470:  CLRF   x1F
3472:  CLRF   x1E
3474:  MOVLW  84
3476:  MOVWF  x1D
3478:  CLRF   x24
347A:  CLRF   x23
347C:  CLRF   x22
347E:  MOVWF  x21
3480:  MOVLB  0
3482:  GOTO   16E2
....................    circuloMenor(96, 32, 30); 
3486:  MOVLB  4
3488:  CLRF   x1C
348A:  CLRF   x1B
348C:  MOVLW  40
348E:  MOVWF  x1A
3490:  MOVLW  85
3492:  MOVWF  x19
3494:  CLRF   x20
3496:  CLRF   x1F
3498:  CLRF   x1E
349A:  MOVLW  84
349C:  MOVWF  x1D
349E:  CLRF   x24
34A0:  CLRF   x23
34A2:  MOVLW  70
34A4:  MOVWF  x22
34A6:  MOVLW  83
34A8:  MOVWF  x21
34AA:  MOVLB  0
34AC:  GOTO   19E0
....................    circuloNumerico(94, 29, 26);  
34B0:  MOVLB  4
34B2:  CLRF   x38
34B4:  CLRF   x37
34B6:  MOVLW  3C
34B8:  MOVWF  x36
34BA:  MOVLW  85
34BC:  MOVWF  x35
34BE:  CLRF   x3C
34C0:  CLRF   x3B
34C2:  MOVLW  68
34C4:  MOVWF  x3A
34C6:  MOVLW  83
34C8:  MOVWF  x39
34CA:  CLRF   x40
34CC:  CLRF   x3F
34CE:  MOVLW  50
34D0:  MOVWF  x3E
34D2:  MOVLW  83
34D4:  MOVWF  x3D
34D6:  MOVLB  0
34D8:  CALL   2002
....................    circuloPonteiro(96, 32, 28); 
34DC:  MOVLB  4
34DE:  CLRF   x1C
34E0:  CLRF   x1B
34E2:  MOVLW  40
34E4:  MOVWF  x1A
34E6:  MOVLW  85
34E8:  MOVWF  x19
34EA:  CLRF   x20
34EC:  CLRF   x1F
34EE:  CLRF   x1E
34F0:  MOVLW  84
34F2:  MOVWF  x1D
34F4:  CLRF   x24
34F6:  CLRF   x23
34F8:  MOVLW  60
34FA:  MOVWF  x22
34FC:  MOVLW  83
34FE:  MOVWF  x21
3500:  MOVLB  0
3502:  GOTO   2876
....................    /*circulo(64, 32, 32); 
....................    circuloMenor(64, 32, 30); 
....................    circuloNumerico(62, 29, 26);  
....................    circuloPonteiro(64, 32, 28);*/ 
.................... } 
3506:  GOTO   3592 (RETURN)
.................... void main(void){ 
350A:  CLRF   FF8
350C:  BCF    FD0.7
350E:  CLRF   FEA
3510:  CLRF   FE9
3512:  CLRF   04
3514:  CLRF   05
3516:  CLRF   06
3518:  MOVLB  4
351A:  CLRF   x0E
351C:  CLRF   x0D
351E:  MOVF   FC1,W
3520:  ANDLW  C0
3522:  IORLW  0F
3524:  MOVWF  FC1
3526:  MOVLW  07
3528:  MOVWF  FB4
352A:  CLRF   x07
352C:  CLRF   x08
....................    PE12864_InitLcd(); 
352E:  MOVLB  0
3530:  GOTO   0606
....................    char chr[10]; 
....................    
....................    sprintf(chr,"15:41"); 
3534:  MOVLW  04
3536:  MOVLB  4
3538:  MOVWF  x0E
353A:  MOVLW  0F
353C:  MOVWF  x0D
353E:  MOVLW  FE
3540:  MOVWF  FF6
3542:  MOVLW  03
3544:  MOVWF  FF7
3546:  MOVLB  0
3548:  GOTO   06CE
....................    PrintBigNumber(chr); 
354C:  MOVLW  04
354E:  MOVLB  4
3550:  MOVWF  x1A
3552:  MOVLW  0F
3554:  MOVWF  x19
3556:  MOVLB  0
3558:  GOTO   072A
....................    PE12864_Gotoxy(0,6); 
355C:  MOVLB  4
355E:  CLRF   x5E
3560:  MOVLW  06
3562:  MOVWF  x5F
3564:  MOVLB  0
3566:  CALL   04B6
....................    printf(PE12864_Printchar, "21/07/2011");    
356A:  MOVLW  04
356C:  MOVWF  FF6
356E:  MOVLW  04
3570:  MOVWF  FF7
3572:  CALL   090A
....................    PE12864_Gotoxy(0,7); 
3576:  MOVLB  4
3578:  CLRF   x5E
357A:  MOVLW  07
357C:  MOVWF  x5F
357E:  MOVLB  0
3580:  CALL   04B6
....................    printf(PE12864_Printchar, "Quinta-feira!");       
3584:  MOVLW  10
3586:  MOVWF  FF6
3588:  MOVLW  04
358A:  MOVWF  FF7
358C:  CALL   090A
....................     
....................    relogioAnalogico(); 
3590:  BRA    3460
....................    while(true){} 
3592:  BRA    3592
.................... } 
3594:  SLEEP 

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV20 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICPRT NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
