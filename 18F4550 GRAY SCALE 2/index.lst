CCS PCH C Compiler, Version 4.114, 93460303               24-abr-13 15:36

               Filename: D:\SkyDrive\Eletronica\PROJETOS PIC CCS\18F4550 GRAY SCALE 2\index.lst

               ROM used: 2302 bytes (7%)
                         Largest free fragment is 30466
               RAM used: 233 (11%) at main() level
                         252 (12%) worst case
               Stack:    6 locations

*
0000:  GOTO   0582
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #use delay(clock=48000000) 
*
020A:  MOVLW  01
020C:  SUBWF  xE8,F
020E:  BNC   0228
0210:  CLRF   FEA
0212:  MOVLW  E8
0214:  MOVWF  FE9
0216:  MOVF   FEF,W
0218:  BZ    0228
021A:  MOVLW  02
021C:  MOVWF  00
021E:  DECFSZ 00,F
0220:  BRA    021E
0222:  BRA    0224
0224:  DECFSZ FEF,F
0226:  BRA    021A
0228:  RETLW  00
*
0252:  CLRF   FEA
0254:  MOVLW  E7
0256:  MOVWF  FE9
0258:  MOVF   FEF,W
025A:  BZ    0278
025C:  MOVLW  0F
025E:  MOVWF  01
0260:  CLRF   00
0262:  DECFSZ 00,F
0264:  BRA    0262
0266:  DECFSZ 01,F
0268:  BRA    0260
026A:  MOVLW  8F
026C:  MOVWF  00
026E:  DECFSZ 00,F
0270:  BRA    026E
0272:  NOP   
0274:  DECFSZ FEF,F
0276:  BRA    025C
0278:  RETLW  00
.................... #fuses HSPLL, PLL4, CPUDIV1, PUT, NOWDT, NOBROWNOUT, NOLVP 
.................... #include "HMF6598SYH-PY.c" 
.................... /*const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01\ 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x00, 0x41, 0x49, 0x49, 0x36, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x00, 0x27, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x00, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x7e, 0x00, // A      34 
....................                          0x7F, 0x49, 0x49, 0x36, 0x00, // B 
....................                          0x3E, 0x41, 0x41, 0x22, 0x00, // C 
....................                          0x7F, 0x41, 0x41, 0x3e, 0x00, // D      37 
....................                          0x7F, 0x49, 0x49, 0x41, 0x00, // E 
....................                          0x7F, 0x09, 0x09, 0x01, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x08, 0x7f, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x3f, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x3e, 0x00, // O 
....................                          0x7F, 0x09, 0x09, 0x06, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x09, 0x76, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x32, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x40, 0x3f, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x08, 0x04, 0x78, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x04, 0x78, 0x00, // n 
....................                          0x38, 0x44, 0x44, 0x38, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x00, 0x3c, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x3c, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... */ 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x41, 0x49, 0x49, 0x36, 0x00, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x27, 0x45, 0x45, 0x39, 0x00, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x71, 0x09, 0x09, 0x07, 0x00,  // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x7e, 0x00, 0x00, // A      34 
....................                          0x7F, 0x49, 0x36, 0x00, 0x00, // B 
....................                          0x3E, 0x41, 0x22, 0x00, 0x00, // C 
....................                          0x7F, 0x41, 0x3e, 0x00, 0x00, // D      37 
....................                          0x7F, 0x49, 0x41, 0x00, 0x00, // E 
....................                          0x7F, 0x09, 0x01, 0x00, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x7f, 0x00, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x3f, 0x00, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x3e, 0x00, 0x00, // O 
....................                          0x7F, 0x09, 0x06, 0x00, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x76, 0x00, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x32, 0x00, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x3f, 0x00, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x00, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x04, 0x78, 0x00, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x78, 0x00, 0x00, // n 
....................                          0x38, 0x44, 0x38, 0x00, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x3c, 0x40, 0x7c, 0x00, 0x00, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x3c, 0x00, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... #define HMF6598_RS    pin_A0 
.................... #define HMF6598_RES   pin_A1 
.................... #define HMF6598_CS1   pin_A2 
.................... #define HMF6598_RD    pin_A3 
.................... #define HMF6598_WR    pin_A4 
....................  
.................... #define ON   1 
.................... #define OFF  0 
....................  
.................... int8 CurrentLine = 0; 
.................... int8 QuantChrLine = 0; 
.................... int8 OffsetX = 0; 
....................  
.................... void    HMF6598_InitLcd(void); 
.................... void    HMF6598_Write_command(char byte_command); 
.................... void    HMF6598_Write_data(char byte_data); 
.................... char    HMF6598_Read_data(); 
.................... void    HMF6598_Gotoxy(int8 x, int y); 
.................... void    HMF6598_Printchar(char cvar); 
.................... void    HMF6598_PutPixel(int8 x,int8 y, int1 COLOR); 
.................... void    HMF6598_OutPort(char byteDC); 
.................... void    clear_screen(void); 
.................... void    newLine(void); 
.................... void    HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR); 
.................... void    HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR); 
....................  
.................... void    HMF6598_InitLcd(void){ 
....................     
....................    output_low(HMF6598_CS1); // Chip Enabled 
*
0346:  BCF    F92.2
0348:  BCF    F89.2
....................    output_low(HMF6598_RES); 
034A:  BCF    F92.1
034C:  BCF    F89.1
....................    delay_us(200); 
034E:  MOVLW  C8
0350:  MOVWF  xE8
0352:  RCALL  020A
....................    output_high(HMF6598_RES);  
0354:  BCF    F92.1
0356:  BSF    F89.1
....................    delay_us(200);    
0358:  MOVLW  C8
035A:  MOVWF  xE8
035C:  RCALL  020A
....................  
....................    HMF6598_Write_command(0xc8);   // Duty = 65    
035E:  MOVLW  C8
0360:  MOVWF  xF8
0362:  RCALL  0246
....................    HMF6598_Write_command(0xa3);   // BIAS 1/9 
0364:  MOVLW  A3
0366:  MOVWF  xF8
0368:  RCALL  0246
....................    HMF6598_Write_command(0xa0);   // ADC Select 
036A:  MOVLW  A0
036C:  MOVWF  xF8
036E:  RCALL  0246
....................    HMF6598_Write_command(0xa6);   // Normal display 0xa6:  Reverse Display :0xa7 
0370:  MOVLW  A6
0372:  MOVWF  xF8
0374:  RCALL  0246
....................    HMF6598_Write_command(0x2c);   //---------------------------------------------  
0376:  MOVLW  2C
0378:  MOVWF  xF8
037A:  RCALL  0246
....................    delay_ms(3);                   // 
037C:  MOVLW  03
037E:  MOVWF  xE7
0380:  RCALL  0252
....................    HMF6598_Write_command(0x2e);   // Power Control Set VR, VC, VF  
0382:  MOVLW  2E
0384:  MOVWF  xF8
0386:  RCALL  0246
....................    delay_ms(3);                   // 
0388:  MOVLW  03
038A:  MOVWF  xE7
038C:  RCALL  0252
....................    HMF6598_Write_command(0x2f);   //--------------------------------------------- 
038E:  MOVLW  2F
0390:  MOVWF  xF8
0392:  RCALL  0246
....................    HMF6598_Write_command(0x20);   // 1+Rb/Ra Ratio    
0394:  MOVLW  20
0396:  MOVWF  xF8
0398:  RCALL  0246
....................    HMF6598_Write_command(0x40);   // EVER register Set    
039A:  MOVLW  40
039C:  MOVWF  xF8
039E:  RCALL  0246
....................     
....................    //Set Brightness   
....................    HMF6598_Write_command(0x81);  
03A0:  MOVLW  81
03A2:  MOVWF  xF8
03A4:  RCALL  0246
....................    HMF6598_Write_command(0x32); 
03A6:  MOVLW  32
03A8:  MOVWF  xF8
03AA:  RCALL  0246
....................     
....................    HMF6598_Write_command(0xe0);   // Set Modify Read  0xee to cancel / 0xe0 to activate 
03AC:  MOVLW  E0
03AE:  MOVWF  xF8
03B0:  RCALL  0246
....................  
....................    clear_screen(); 
03B2:  BRA    0316
....................    HMF6598_Write_command(0xaf);   // Display ON 
03B4:  MOVLW  AF
03B6:  MOVWF  xF8
03B8:  RCALL  0246
.................... } 
03BA:  GOTO   07C0 (RETURN)
....................  
.................... void HMF6598_OutPort(char byteDC){ 
....................   set_tris_b(0x00); 
*
022A:  MOVLW  00
022C:  MOVWF  F93
....................   output_low(HMF6598_CS1); 
022E:  BCF    F92.2
0230:  BCF    F89.2
....................   output_high(HMF6598_RD);  
0232:  BCF    F92.3
0234:  BSF    F89.3
....................   output_low(HMF6598_WR);   
0236:  BCF    F92.4
0238:  BCF    F89.4
....................   output_b(byteDC); 
023A:  CLRF   F93
023C:  MOVFF  F9,F8A
....................   output_high(HMF6598_CS1);     
0240:  BCF    F92.2
0242:  BSF    F89.2
.................... } 
0244:  RETLW  00
.................... void    HMF6598_Write_command(char byte_command){ 
....................   output_low(HMF6598_RS);          // Write Command Enabled 
0246:  BCF    F92.0
0248:  BCF    F89.0
....................   HMF6598_OutPort(byte_command); 
024A:  MOVFF  F8,F9
024E:  RCALL  022A
.................... } 
0250:  RETLW  00
.................... void    HMF6598_Write_data(char byte_data){ 
....................   output_high(HMF6598_RS);         // Write data Enabled 
*
02FE:  BCF    F92.0
0300:  BSF    F89.0
....................   HMF6598_OutPort(byte_data); 
0302:  MOVFF  F3,F9
0306:  RCALL  022A
....................   OffsetX++; 
0308:  INCF   06,F
....................   HMF6598_Gotoxy(OffsetX,CurrentLine); 
030A:  MOVFF  06,F4
030E:  MOVFF  04,F5
0312:  RCALL  02A2
.................... } 
0314:  RETLW  00
....................  
.................... char    HMF6598_Read_data(){ 
....................  
.................... /*  set_tris_b(0xff); 
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................    
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1);    */  
....................    
....................   set_tris_b(0xff);     
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................   output_low(HMF6598_CS1); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1); 
.................... } 
....................  
.................... void newLine(){ 
....................   if(CurrentLine < 7){  // New Line Command 
*
03BE:  MOVF   04,W
03C0:  SUBLW  06
03C2:  BNC   03DE
....................       HMF6598_Write_command((CurrentLine+1)|0xb0);  // Set Page Address to 0 (0 a 7) 
03C4:  MOVLW  01
03C6:  ADDWF  04,W
03C8:  IORLW  B0
03CA:  MOVWF  xF2
03CC:  MOVWF  xF8
03CE:  RCALL  0246
....................       HMF6598_Write_command(0x00);  // Set LSB for index Column 
03D0:  CLRF   xF8
03D2:  RCALL  0246
....................       HMF6598_Write_command(0x10);  // Set MSB for index Column    
03D4:  MOVLW  10
03D6:  MOVWF  xF8
03D8:  RCALL  0246
....................       CurrentLine+=1; 
03DA:  MOVLW  01
03DC:  ADDWF  04,F
....................   } 
....................   QuantChrLine = 1; 
03DE:  MOVLW  01
03E0:  MOVWF  05
....................   OffsetX = 0; 
03E2:  CLRF   06
.................... } 
03E4:  GOTO   03F4 (RETURN)
.................... void clear_screen(void) { 
....................    int p, c; 
....................    for(p = 0; p < 8; p++) { 
*
0316:  CLRF   xE7
0318:  MOVF   xE7,W
031A:  SUBLW  07
031C:  BNC   033C
....................       for(c = 0; c < 128; c++) { 
031E:  CLRF   xE8
0320:  MOVF   xE8,W
0322:  SUBLW  7F
0324:  BNC   0338
....................          HMF6598_Gotoxy(c,p); 
0326:  MOVFF  E8,F4
032A:  MOVFF  E7,F5
032E:  RCALL  02A2
....................          HMF6598_Write_data(0x00); 
0330:  CLRF   xF3
0332:  RCALL  02FE
....................       } 
0334:  INCF   xE8,F
0336:  BRA    0320
....................    } 
0338:  INCF   xE7,F
033A:  BRA    0318
....................    HMF6598_Gotoxy(0,0);    
033C:  CLRF   xF4
033E:  CLRF   xF5
0340:  RCALL  02A2
.................... } 
0342:  GOTO   03B4 (RETURN)
.................... void    HMF6598_Gotoxy(int x, int y){ 
*
02A2:  CLRF   xF6
....................    int8 OffsetChr = 0; 
....................     
....................    HMF6598_Write_command(0xb0 | y); 
02A4:  MOVF   xF5,W
02A6:  IORLW  B0
02A8:  MOVWF  xF7
02AA:  MOVWF  xF8
02AC:  RCALL  0246
....................    HMF6598_Write_command((0x00 | x) & 0x0f); 
02AE:  MOVF   xF4,W
02B0:  ANDLW  0F
02B2:  MOVWF  xF7
02B4:  MOVWF  xF8
02B6:  RCALL  0246
....................    HMF6598_Write_command(0x10|(x>>4)); 
02B8:  SWAPF  xF4,W
02BA:  MOVWF  00
02BC:  MOVLW  0F
02BE:  ANDWF  00,F
02C0:  MOVF   00,W
02C2:  IORLW  10
02C4:  MOVWF  xF7
02C6:  MOVWF  xF8
02C8:  RCALL  0246
....................     
....................    OffsetChr = (x+1)/6; 
02CA:  MOVLW  01
02CC:  ADDWF  xF4,W
02CE:  MOVWF  xF8
02D0:  MOVWF  xF9
02D2:  MOVLW  06
02D4:  MOVWF  xFA
02D6:  RCALL  027A
02D8:  MOVFF  01,F6
....................    if((x+1)%6) 
02DC:  MOVLW  01
02DE:  ADDWF  xF4,W
02E0:  MOVWF  xF8
02E2:  MOVWF  xF9
02E4:  MOVLW  06
02E6:  MOVWF  xFA
02E8:  RCALL  027A
02EA:  MOVF   00,W
02EC:  BZ    02F0
....................       OffsetChr++;    
02EE:  INCF   xF6,F
....................    CurrentLine = y; 
02F0:  MOVFF  F5,04
....................    QuantChrLine = OffsetChr; 
02F4:  MOVFF  F6,05
....................    OffsetX = x; 
02F8:  MOVFF  F4,06
.................... } 
02FC:  RETLW  00
.................... void    HMF6598_Printchar(char cvar){ 
....................    int i; 
....................    if (QuantChrLine > 21)   
*
03E8:  MOVF   05,W
03EA:  SUBLW  15
03EC:  BC    03F2
....................        newLine();  
03EE:  BRA    03BE
....................    else 
03F0:  BRA    03F4
....................        QuantChrLine++;     
03F2:  INCF   05,F
....................    if(cvar == 0x20) 
03F4:  MOVF   xF0,W
03F6:  SUBLW  20
03F8:  BNZ   040C
....................       for(i=0;i<2;i++) 
03FA:  CLRF   xF1
03FC:  MOVF   xF1,W
03FE:  SUBLW  01
0400:  BNC   040A
....................          HMF6598_Write_data(0x00); 
0402:  CLRF   xF3
0404:  RCALL  02FE
0406:  INCF   xF1,F
0408:  BRA    03FC
....................    else{ 
040A:  BRA    04A8
....................       for(i=0;i<5;i++){ 
040C:  CLRF   xF1
040E:  MOVF   xF1,W
0410:  SUBLW  04
0412:  BNC   04A8
....................          if (cvar < 0x53){ 
0414:  MOVF   xF0,W
0416:  SUBLW  52
0418:  BNC   0460
....................             if(TEXT[cvar-0x20][i])          
041A:  MOVLW  20
041C:  SUBWF  xF0,W
041E:  MULLW  05
0420:  MOVF   FF3,W
0422:  CLRF   xF3
0424:  MOVWF  xF2
0426:  CLRF   03
0428:  MOVF   xF1,W
042A:  ADDWF  xF2,W
042C:  MOVWF  01
042E:  MOVF   xF3,W
0430:  ADDWFC 03,F
0432:  MOVF   01,W
0434:  RCALL  0004
0436:  MOVWF  01
0438:  MOVF   01,F
043A:  BZ    045E
....................                HMF6598_Write_data(TEXT[cvar-0x20][i]);       
043C:  MOVLW  20
043E:  SUBWF  xF0,W
0440:  MULLW  05
0442:  MOVF   FF3,W
0444:  CLRF   xF3
0446:  MOVWF  xF2
0448:  CLRF   03
044A:  MOVF   xF1,W
044C:  ADDWF  xF2,W
044E:  MOVWF  01
0450:  MOVF   xF3,W
0452:  ADDWFC 03,F
0454:  MOVF   01,W
0456:  RCALL  0004
0458:  MOVWF  xF2
045A:  MOVWF  xF3
045C:  RCALL  02FE
....................          } 
....................          else { 
045E:  BRA    04A4
....................             if(TEXT2[cvar-0x53][i])                
0460:  MOVLW  53
0462:  SUBWF  xF0,W
0464:  MULLW  05
0466:  MOVF   FF3,W
0468:  CLRF   xF3
046A:  MOVWF  xF2
046C:  CLRF   03
046E:  MOVF   xF1,W
0470:  ADDWF  xF2,W
0472:  MOVWF  01
0474:  MOVF   xF3,W
0476:  ADDWFC 03,F
0478:  MOVF   01,W
047A:  RCALL  0114
047C:  MOVWF  01
047E:  MOVF   01,F
0480:  BZ    04A4
....................                HMF6598_Write_data(TEXT2[cvar-0x53][i]);                
0482:  MOVLW  53
0484:  SUBWF  xF0,W
0486:  MULLW  05
0488:  MOVF   FF3,W
048A:  CLRF   xF3
048C:  MOVWF  xF2
048E:  CLRF   03
0490:  MOVF   xF1,W
0492:  ADDWF  xF2,W
0494:  MOVWF  01
0496:  MOVF   xF3,W
0498:  ADDWFC 03,F
049A:  MOVF   01,W
049C:  RCALL  0114
049E:  MOVWF  xF2
04A0:  MOVWF  xF3
04A2:  RCALL  02FE
....................          } 
....................       } 
04A4:  INCF   xF1,F
04A6:  BRA    040E
....................    } 
....................    HMF6598_Write_data(0x00); 
04A8:  CLRF   xF3
04AA:  RCALL  02FE
.................... } 
04AC:  RETLW  00
.................... void HMF6598_PutPixel(int x, int y, int1 COLOR){ 
....................    char BytePlot = 0, tempByte; 
....................    if((x > 127)||(y > 63)) 
....................       return; 
....................    BytePlot |= 1; 
....................    BytePlot<<=(y%8); 
....................    tempByte = BytePlot; 
....................    HMF6598_Gotoxy(x,(y/8)); 
....................    BytePlot|=HMF6598_Read_data(); 
....................    if(COLOR == OFF) 
....................       BytePlot-=tempByte; 
....................    HMF6598_Write_data(BytePlot); 
.................... } 
....................  
.................... void HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR){ 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................    do{ 
....................       if(fill){ 
....................          HMF6598_line(x-a, y+b, x+a, y+b, color); 
....................          HMF6598_line(x-a, y-b, x+a, y-b, color); 
....................          HMF6598_line(x-b, y+a, x+b, y+a, color); 
....................          HMF6598_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else{ 
....................          HMF6598_PutPixel(a+x, b+y, color); 
....................          HMF6598_PutPixel(b+x, a+y, color); 
....................          HMF6598_PutPixel(x-a, b+y, color); 
....................          HMF6598_PutPixel(x-b, a+y, color); 
....................          HMF6598_PutPixel(b+x, y-a, color); 
....................          HMF6598_PutPixel(a+x, y-b, color); 
....................          HMF6598_PutPixel(x-a, y-b, color); 
....................          HMF6598_PutPixel(x-b, y-a, color); 
....................       } 
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... void HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR){ 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................  
....................    if(x1 > x2) 
....................       addx = -1; 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................       addy = -1; 
....................    else 
....................       addy = 1; 
....................    if(dx >= dy){ 
....................       P = 2*dy - dx; 
....................       for(i=0; i<=dx; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................          if(P < 0){ 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else{ 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else{ 
....................       P = 2*dx - dy; 
....................       for(i=0; i<=dy; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................  
....................          if(P < 0){ 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else{ 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void main(void){ 
*
0582:  CLRF   FF8
0584:  BCF    FD0.7
0586:  CLRF   FEA
0588:  CLRF   FE9
058A:  CLRF   04
058C:  CLRF   05
058E:  CLRF   06
0590:  MOVF   FC1,W
0592:  ANDLW  C0
0594:  IORLW  0F
0596:  MOVWF  FC1
0598:  MOVLW  07
059A:  MOVWF  FB4
059C:  CLRF   07
059E:  CLRF   08
....................  
.................... BYTE BLK[3][24] = {0x00,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08, 
.................... 0x08,0x08,0x08,0x08,0x08,0x08,0xF8,0x00,0x00,0x03,0x02,0xFE,0x02,0x02,0x02,0x02, 
.................... 0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0xFE,0x02,0x03,0x00, 
.................... 0x00,0x00,0x00,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80, 
.................... 0x80,0x80,0x80,0x80,0xFF,0x00,0x00,0x00}; 
05A0:  CLRF   09
05A2:  MOVLW  F8
05A4:  MOVWF  0A
05A6:  MOVLW  08
05A8:  MOVWF  0B
05AA:  MOVWF  0C
05AC:  MOVWF  0D
05AE:  MOVWF  0E
05B0:  MOVWF  0F
05B2:  MOVWF  10
05B4:  MOVWF  11
05B6:  MOVWF  12
05B8:  MOVWF  13
05BA:  MOVWF  14
05BC:  MOVWF  15
05BE:  MOVWF  16
05C0:  MOVWF  17
05C2:  MOVWF  18
05C4:  MOVWF  19
05C6:  MOVWF  1A
05C8:  MOVWF  1B
05CA:  MOVWF  1C
05CC:  MOVWF  1D
05CE:  MOVWF  1E
05D0:  MOVLW  F8
05D2:  MOVWF  1F
05D4:  CLRF   20
05D6:  CLRF   21
05D8:  MOVLW  03
05DA:  MOVWF  22
05DC:  MOVLW  02
05DE:  MOVWF  23
05E0:  MOVLW  FE
05E2:  MOVWF  24
05E4:  MOVLW  02
05E6:  MOVWF  25
05E8:  MOVWF  26
05EA:  MOVWF  27
05EC:  MOVWF  28
05EE:  MOVWF  29
05F0:  MOVWF  2A
05F2:  MOVWF  2B
05F4:  MOVWF  2C
05F6:  MOVWF  2D
05F8:  MOVWF  2E
05FA:  MOVWF  2F
05FC:  MOVWF  30
05FE:  MOVWF  31
0600:  MOVWF  32
0602:  MOVWF  33
0604:  MOVWF  34
0606:  MOVLW  FE
0608:  MOVWF  35
060A:  MOVLW  02
060C:  MOVWF  36
060E:  MOVLW  03
0610:  MOVWF  37
0612:  CLRF   38
0614:  CLRF   39
0616:  CLRF   3A
0618:  CLRF   3B
061A:  MOVLW  FF
061C:  MOVWF  3C
061E:  MOVLW  80
0620:  MOVWF  3D
0622:  MOVWF  3E
0624:  MOVWF  3F
0626:  MOVWF  40
0628:  MOVWF  41
062A:  MOVWF  42
062C:  MOVWF  43
062E:  MOVWF  44
0630:  MOVWF  45
0632:  MOVWF  46
0634:  MOVWF  47
0636:  MOVWF  48
0638:  MOVWF  49
063A:  MOVWF  4A
063C:  MOVWF  4B
063E:  MOVWF  4C
0640:  MOVLW  FF
0642:  MOVWF  4D
0644:  CLRF   4E
0646:  CLRF   4F
0648:  CLRF   50
....................  
....................  
.................... BYTE CNZ1[3][24] = {0x00,0x00,0x20,0x20,0x20,0xE0,0xE0,0x00,0x00,0x00,0x00,0xF0,0x30,0xF0,0xF0,0xF0, 
.................... 0xF0,0xF0,0xF0,0xA0,0x50,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFD,0xFC, 
.................... 0x00,0x00,0x00,0x01,0xFC,0x01,0xFD,0xFD,0xFD,0xA9,0x55,0xA8,0x01,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x00,0x00,0x00,0x00,0x7F,0x00,0x7F,0x7F, 
.................... 0x7F,0x2A,0x55,0x2A,0x00,0x00,0x00,0x00}; 
064A:  CLRF   51
064C:  CLRF   52
064E:  MOVLW  20
0650:  MOVWF  53
0652:  MOVWF  54
0654:  MOVWF  55
0656:  MOVLW  E0
0658:  MOVWF  56
065A:  MOVWF  57
065C:  CLRF   58
065E:  CLRF   59
0660:  CLRF   5A
0662:  CLRF   5B
0664:  MOVLW  F0
0666:  MOVWF  5C
0668:  MOVLW  30
066A:  MOVWF  5D
066C:  MOVLW  F0
066E:  MOVWF  5E
0670:  MOVWF  5F
0672:  MOVWF  x60
0674:  MOVWF  x61
0676:  MOVWF  x62
0678:  MOVWF  x63
067A:  MOVLW  A0
067C:  MOVWF  x64
067E:  MOVLW  50
0680:  MOVWF  x65
0682:  MOVLW  B0
0684:  MOVWF  x66
0686:  CLRF   x67
0688:  CLRF   x68
068A:  CLRF   x69
068C:  CLRF   x6A
068E:  CLRF   x6B
0690:  CLRF   x6C
0692:  CLRF   x6D
0694:  MOVLW  01
0696:  MOVWF  x6E
0698:  MOVLW  FD
069A:  MOVWF  x6F
069C:  MOVLW  FC
069E:  MOVWF  x70
06A0:  CLRF   x71
06A2:  CLRF   x72
06A4:  CLRF   x73
06A6:  MOVLW  01
06A8:  MOVWF  x74
06AA:  MOVLW  FC
06AC:  MOVWF  x75
06AE:  MOVLW  01
06B0:  MOVWF  x76
06B2:  MOVLW  FD
06B4:  MOVWF  x77
06B6:  MOVWF  x78
06B8:  MOVWF  x79
06BA:  MOVLW  A9
06BC:  MOVWF  x7A
06BE:  MOVLW  55
06C0:  MOVWF  x7B
06C2:  MOVLW  A8
06C4:  MOVWF  x7C
06C6:  MOVLW  01
06C8:  MOVWF  x7D
06CA:  CLRF   x7E
06CC:  CLRF   x7F
06CE:  CLRF   x80
06D0:  CLRF   x81
06D2:  CLRF   x82
06D4:  CLRF   x83
06D6:  CLRF   x84
06D8:  CLRF   x85
06DA:  CLRF   x86
06DC:  MOVLW  7F
06DE:  MOVWF  x87
06E0:  MOVWF  x88
06E2:  CLRF   x89
06E4:  CLRF   x8A
06E6:  CLRF   x8B
06E8:  CLRF   x8C
06EA:  MOVWF  x8D
06EC:  CLRF   x8E
06EE:  MOVWF  x8F
06F0:  MOVWF  x90
06F2:  MOVWF  x91
06F4:  MOVLW  2A
06F6:  MOVWF  x92
06F8:  MOVLW  55
06FA:  MOVWF  x93
06FC:  MOVLW  2A
06FE:  MOVWF  x94
0700:  CLRF   x95
0702:  CLRF   x96
0704:  CLRF   x97
0706:  CLRF   x98
....................  
.................... BYTE CNZ2[3][24] = {0x00,0x00,0xD0,0xD0,0xD0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xD0,0x10,0x10,0x10, 
.................... 0x10,0x10,0x10,0x50,0xA0,0x50,0x00,0x00,0x00,0x00,0x01,0x01,0xFD,0xFC,0x00,0x00, 
.................... 0xFC,0xFC,0xFC,0xFC,0x01,0x00,0x00,0x00,0x00,0x54,0xA8,0x55,0x00,0x01,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00, 
.................... 0x00,0x55,0x2A,0x55,0x00,0x00,0x00,0x00}; 
0708:  CLRF   x99
070A:  CLRF   x9A
070C:  MOVLW  D0
070E:  MOVWF  x9B
0710:  MOVWF  x9C
0712:  MOVWF  x9D
0714:  MOVLW  10
0716:  MOVWF  x9E
0718:  MOVWF  x9F
071A:  MOVWF  xA0
071C:  MOVWF  xA1
071E:  MOVWF  xA2
0720:  MOVWF  xA3
0722:  MOVWF  xA4
0724:  MOVLW  D0
0726:  MOVWF  xA5
0728:  MOVLW  10
072A:  MOVWF  xA6
072C:  MOVWF  xA7
072E:  MOVWF  xA8
0730:  MOVWF  xA9
0732:  MOVWF  xAA
0734:  MOVWF  xAB
0736:  MOVLW  50
0738:  MOVWF  xAC
073A:  MOVLW  A0
073C:  MOVWF  xAD
073E:  MOVLW  50
0740:  MOVWF  xAE
0742:  CLRF   xAF
0744:  CLRF   xB0
0746:  CLRF   xB1
0748:  CLRF   xB2
074A:  MOVLW  01
074C:  MOVWF  xB3
074E:  MOVWF  xB4
0750:  MOVLW  FD
0752:  MOVWF  xB5
0754:  MOVLW  FC
0756:  MOVWF  xB6
0758:  CLRF   xB7
075A:  CLRF   xB8
075C:  MOVWF  xB9
075E:  MOVWF  xBA
0760:  MOVWF  xBB
0762:  MOVWF  xBC
0764:  MOVLW  01
0766:  MOVWF  xBD
0768:  CLRF   xBE
076A:  CLRF   xBF
076C:  CLRF   xC0
076E:  CLRF   xC1
0770:  MOVLW  54
0772:  MOVWF  xC2
0774:  MOVLW  A8
0776:  MOVWF  xC3
0778:  MOVLW  55
077A:  MOVWF  xC4
077C:  CLRF   xC5
077E:  MOVLW  01
0780:  MOVWF  xC6
0782:  CLRF   xC7
0784:  CLRF   xC8
0786:  CLRF   xC9
0788:  CLRF   xCA
078A:  CLRF   xCB
078C:  CLRF   xCC
078E:  MOVLW  7F
0790:  MOVWF  xCD
0792:  MOVWF  xCE
0794:  CLRF   xCF
0796:  CLRF   xD0
0798:  MOVWF  xD1
079A:  MOVWF  xD2
079C:  MOVWF  xD3
079E:  MOVWF  xD4
07A0:  CLRF   xD5
07A2:  CLRF   xD6
07A4:  CLRF   xD7
07A6:  CLRF   xD8
07A8:  CLRF   xD9
07AA:  MOVLW  55
07AC:  MOVWF  xDA
07AE:  MOVLW  2A
07B0:  MOVWF  xDB
07B2:  MOVLW  55
07B4:  MOVWF  xDC
07B6:  CLRF   xDD
07B8:  CLRF   xDE
07BA:  CLRF   xDF
07BC:  CLRF   xE0
....................                           
....................    int i, j, t; 
....................    long x; 
....................    BYTE tempByte; 
....................    HMF6598_InitLcd(); 
07BE:  BRA    0346
....................    t = 0; 
07C0:  CLRF   xE3
....................    x = 3500; 
07C2:  MOVLW  0D
07C4:  MOVWF  xE5
07C6:  MOVLW  AC
07C8:  MOVWF  xE4
....................    /*for(i=0;i<128;i++){ 
....................      BLK[i] = 0x07; 
....................      CNZ1[i] = 0x18; 
....................      CNZ2[i] = 0xe0; 
....................    }*/ 
....................    while(true){ // 2512 
....................       for(j=0;j<3;j++){ 
07CA:  CLRF   xE2
07CC:  MOVF   xE2,W
07CE:  SUBLW  02
07D0:  BNC   0894
....................          HMF6598_Gotoxy(0,j); 
07D2:  CLRF   xF4
07D4:  MOVFF  E2,F5
07D8:  RCALL  02A2
....................          for(i=0;i<24;i++){ 
07DA:  CLRF   xE1
07DC:  MOVF   xE1,W
07DE:  SUBLW  17
07E0:  BNC   0890
....................             tempByte = BLK[j][i]; 
07E2:  MOVF   xE2,W
07E4:  MULLW  18
07E6:  MOVF   FF3,W
07E8:  CLRF   xE8
07EA:  MOVWF  xE7
07EC:  CLRF   03
07EE:  MOVF   xE1,W
07F0:  ADDWF  xE7,W
07F2:  MOVWF  01
07F4:  MOVF   xE8,W
07F6:  ADDWFC 03,F
07F8:  MOVF   01,W
07FA:  ADDLW  09
07FC:  MOVWF  FE9
07FE:  MOVLW  00
0800:  ADDWFC 03,W
0802:  MOVWF  FEA
0804:  MOVFF  FEF,E6
....................             if(t<2){ 
0808:  MOVF   xE3,W
080A:  SUBLW  01
080C:  BNC   085A
....................                tempByte |= CNZ1[j][i]; 
080E:  MOVF   xE2,W
0810:  MULLW  18
0812:  MOVF   FF3,W
0814:  CLRF   xE8
0816:  MOVWF  xE7
0818:  CLRF   03
081A:  MOVF   xE1,W
081C:  ADDWF  xE7,W
081E:  MOVWF  01
0820:  MOVF   xE8,W
0822:  ADDWFC 03,F
0824:  MOVF   01,W
0826:  ADDLW  51
0828:  MOVWF  FE9
082A:  MOVLW  00
082C:  ADDWFC 03,W
082E:  MOVWF  FEA
0830:  MOVF   FEF,W
0832:  IORWF  xE6,F
....................                tempByte |= CNZ2[j][i]; 
0834:  MOVF   xE2,W
0836:  MULLW  18
0838:  MOVF   FF3,W
083A:  CLRF   xE8
083C:  MOVWF  xE7
083E:  CLRF   03
0840:  MOVF   xE1,W
0842:  ADDWF  xE7,W
0844:  MOVWF  01
0846:  MOVF   xE8,W
0848:  ADDWFC 03,F
084A:  MOVF   01,W
084C:  ADDLW  99
084E:  MOVWF  FE9
0850:  MOVLW  00
0852:  ADDWFC 03,W
0854:  MOVWF  FEA
0856:  MOVF   FEF,W
0858:  IORWF  xE6,F
....................             } 
....................             if(t<4) 
085A:  MOVF   xE3,W
085C:  SUBLW  03
085E:  BNC   0886
....................                tempByte |= CNZ1[j][i]; 
0860:  MOVF   xE2,W
0862:  MULLW  18
0864:  MOVF   FF3,W
0866:  CLRF   xE8
0868:  MOVWF  xE7
086A:  CLRF   03
086C:  MOVF   xE1,W
086E:  ADDWF  xE7,W
0870:  MOVWF  01
0872:  MOVF   xE8,W
0874:  ADDWFC 03,F
0876:  MOVF   01,W
0878:  ADDLW  51
087A:  MOVWF  FE9
087C:  MOVLW  00
087E:  ADDWFC 03,W
0880:  MOVWF  FEA
0882:  MOVF   FEF,W
0884:  IORWF  xE6,F
....................             HMF6598_Write_data(tempByte); 
0886:  MOVFF  E6,F3
088A:  RCALL  02FE
....................          } 
088C:  INCF   xE1,F
088E:  BRA    07DC
....................       } 
0890:  INCF   xE2,F
0892:  BRA    07CC
....................       HMF6598_Gotoxy(0,3); 
0894:  CLRF   xF4
0896:  MOVLW  03
0898:  MOVWF  xF5
089A:  RCALL  02A2
....................       printf(HMF6598_Printchar, "%lu      ", x); 
089C:  MOVLW  10
089E:  MOVWF  FE9
08A0:  MOVFF  E5,E8
08A4:  MOVFF  E4,E7
08A8:  BRA    04AE
08AA:  MOVLW  03
08AC:  MOVWF  FF6
08AE:  MOVLW  02
08B0:  MOVWF  FF7
08B2:  MOVLW  06
08B4:  MOVWF  xE7
08B6:  BRA    0562
....................       delay_us(x); 
08B8:  MOVFF  E5,E7
08BC:  INCF   xE7,F
08BE:  DECF   xE7,F
08C0:  BTFSC  FD8.2
08C2:  BRA    08CC
08C4:  MOVLW  FF
08C6:  MOVWF  xE8
08C8:  RCALL  020A
08CA:  BRA    08BE
08CC:  MOVFF  E4,E8
08D0:  RCALL  020A
....................       t++; 
08D2:  INCF   xE3,F
....................       if (t > 9) 
08D4:  MOVF   xE3,W
08D6:  SUBLW  09
08D8:  BC    08DC
....................          t = 0; 
08DA:  CLRF   xE3
....................       if(!input(pin_D5)) 
08DC:  BSF    F95.5
08DE:  BTFSC  F83.5
08E0:  BRA    08EA
....................          x--; 
08E2:  MOVF   xE4,W
08E4:  BTFSC  FD8.2
08E6:  DECF   xE5,F
08E8:  DECF   xE4,F
....................       if(x < 1) 
08EA:  MOVF   xE4,F
08EC:  BNZ   08FA
08EE:  MOVF   xE5,F
08F0:  BNZ   08FA
....................          x = 3500; 
08F2:  MOVLW  0D
08F4:  MOVWF  xE5
08F6:  MOVLW  AC
08F8:  MOVWF  xE4
....................    } 
08FA:  BRA    07CA
....................   
....................     
.................... } 
08FC:  SLEEP 

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV20 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICPRT NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
