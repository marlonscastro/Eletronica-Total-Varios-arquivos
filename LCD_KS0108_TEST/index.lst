CCS PCM C Compiler, Version 4.114, 93460303               06-nov-12 14:51

               Filename: D:\SkyDrive\Eletronica\PROJETOS PIC CCS\16F628A_LCD_KS0108_TEST\index.lst

               ROM used: 1570 words (77%)
                         Largest free fragment is 478
               RAM used: 7 (3%) at main() level
                         26 (12%) worst case
               Stack:    3 locations

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   60E
0003:  NOP
.................... #include <16f628A.h> 
.................... //////// Standard Header file for the PIC16F628A device //////////////// 
.................... #device PIC16F628A 
.................... #list 
....................  
.................... #use delay(clock=4000000) 
*
05F9:  MOVLW  22
05FA:  MOVWF  04
05FB:  BCF    03.7
05FC:  MOVF   00,W
05FD:  BTFSC  03.2
05FE:  GOTO   60D
05FF:  MOVLW  01
0600:  MOVWF  78
0601:  CLRF   77
0602:  DECFSZ 77,F
0603:  GOTO   602
0604:  DECFSZ 78,F
0605:  GOTO   601
0606:  MOVLW  4A
0607:  MOVWF  77
0608:  DECFSZ 77,F
0609:  GOTO   608
060A:  GOTO   60B
060B:  DECFSZ 00,F
060C:  GOTO   5FF
060D:  GOTO   61E (RETURN)
.................... #FUSES NOWDT, NOBROWNOUT, PUT, XT   
.................... #include "demo/Extended_GLCD.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                       Extended_GLCD.c                           //// 
.................... ////                                                                 //// 
.................... ////                             by                                  //// 
.................... ////                     SAINT (Caner ERSiL)                         //// 
.................... ////                                                                 //// 
.................... ////             !!! PLEASE READ THIS INFO FIRST !!!                 //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a KS0108 based 128x64 pixel//// 
.................... //// GLCD. This "Extended_GLCD.c" driver based on, "GLCD.c" driver   //// 
.................... //// can be found in CCS installation folder. The driver treats the  //// 
.................... //// upper left pixel as (0,0).                                      //// 
.................... //                                                                     // 
.................... // ! DON'T FORGET TO CHANGE YOUR PIN CONFIGURATION FOR YOUR CIRCUIT !  // 
.................... //                                                                     // 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                 The NEW functions added by me:                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_standby(command)                                          //// 
.................... ////  glcd_3Dbox(x,y,width,height,depth,color)                       //// 
.................... ////  glcd_circle_seg(x,y,radius,angle_start,angle_end,color)        //// 
.................... ////  glcd_image(inverse)                                            //// 
.................... ////  glcd_image_xy(x,y,inverse)                                     //// 
.................... ////                                                                 //// 
.................... ////     !!         YOU CAN FIND DETAILED DESCRIPTIONS        !!     //// 
.................... ////     !! AND "HOW TO USE" INFORMATIONS ABOVE THE FUNCTIONS !!     //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////            Original(untouched) GLCD functions are:              //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way. :)           //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <Bitmap.h> 
.................... /* Data generated with bitmap2LCD */ 
.................... /* 13/03/2009 21:37:33 */ 
.................... /* Bitmap Source file : Caner Ersil.bmp */ 
....................  
.................... const int image[]= 
.................... { 
....................  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0x7F  0x3F  0x1F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F, 
....................  0x0F  0x0F  0x1F  0x3F  0x7F  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0x3F  0x1F  0x0F  0x07, 
....................  0x03  0x01  0x00  0x80  0xE0  0xF0  0xF8  0xFC, 
....................  0xFC  0xFE  0xFE  0xFE  0xFE  0x7E  0x1E  0x1E, 
....................  0x1C  0x1C  0x3C  0x3C  0x00  0x00  0x00  0x00, 
....................  0x00  0x04  0x84  0xFC  0xFC  0xFC  0xFC  0xFC, 
....................  0xFC  0x7C  0xFC  0xFC  0xFC  0xE4  0x04  0x04, 
....................  0x00  0x00  0x00  0x08  0x08  0x08  0xF8  0xF8, 
....................  0xFC  0xFC  0xFC  0xFC  0xFC  0xFC  0xF8  0xE0, 
....................  0x04  0x04  0x7C  0xFC  0xFC  0xFC  0xF8  0xF8, 
....................  0x78  0x00  0x08  0x08  0x08  0x38  0xF8  0xF8, 
....................  0xF8  0xF8  0xF8  0xF8  0xFC  0xFC  0x1C  0x1C, 
....................  0x1C  0x9C  0x9C  0x1C  0x3C  0x30  0x00  0x08, 
....................  0x08  0x08  0xD8  0xF8  0xF8  0xF8  0xFC  0x7C, 
....................  0x7C  0xFC  0xFC  0xFC  0xFC  0xFC  0xFC  0xF8, 
....................  0xF8  0xF0  0xE0  0x00  0x00  0x00  0x01  0x03, 
....................  0x07  0x0F  0x1F  0x3F  0xFF  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0x00  0x00  0x00  0x00, 
....................  0x00  0x00  0x00  0x3F  0x7F  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0xFF  0xFE  0xFC  0xF8, 
....................  0xF8  0xF8  0xF8  0xFC  0xFC  0x00  0x00  0x00, 
....................  0x80  0xF8  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF, 
....................  0x3D  0x3C  0x3F  0x3F  0xFF  0xFF  0xFF  0xFC, 
....................  0xF0  0xC0  0x00  0x00  0x00  0x80  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0xF7  0x07  0x1F  0x3F, 
....................  0xFF  0xFC  0xF8  0xFF  0xFF  0xFF  0xFF  0x7F, 
....................  0x00  0x00  0x00  0x00  0x00  0x00  0x1F  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0xFF  0xBF  0x8E  0x0F, 
....................  0x0F  0x0F  0x1F  0x00  0xC0  0xC0  0xC0  0x00, 
....................  0x00  0xC0  0xFF  0xFF  0xFF  0xFF  0xFF  0x78, 
....................  0x78  0xFF  0xFF  0xFF  0xFF  0xFF  0xBF  0x1F, 
....................  0x1F  0x0F  0x03  0x00  0x00  0x00  0x00  0x00, 
....................  0x00  0x00  0x00  0x00  0xFF  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0x00  0x00  0x00  0x00, 
....................  0x00  0x00  0x00  0x00  0x00  0x01  0x01  0x03, 
....................  0x07  0x07  0x07  0x07  0x07  0x07  0x03  0x03, 
....................  0x01  0x01  0x00  0x00  0x00  0x00  0x04  0x06, 
....................  0x07  0x07  0x07  0x07  0x03  0x03  0x03  0x02, 
....................  0x04  0x00  0x08  0x0E  0x07  0x07  0x07  0x03, 
....................  0x03  0x03  0x01  0x05  0x04  0x07  0x07  0x07, 
....................  0x07  0x07  0x07  0x07  0x0F  0x0F  0x08  0x08, 
....................  0x08  0x01  0x03  0x07  0x07  0x07  0x07  0x04, 
....................  0x04  0x00  0x0C  0x04  0x04  0x06  0x06  0x07, 
....................  0x07  0x07  0x07  0x07  0x07  0x07  0x0F  0x0F, 
....................  0x0F  0x0F  0x0F  0x0F  0x0F  0x0F  0x00  0x00, 
....................  0x04  0x07  0x07  0x07  0x07  0x0F  0x0F  0x0C, 
....................  0x08  0x00  0x01  0x13  0x1F  0x0F  0x0F  0x0F, 
....................  0x07  0x06  0x04  0x00  0x00  0x00  0x00  0x00, 
....................  0x00  0x00  0x00  0x00  0xFF  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0x00  0x00  0x00  0x00, 
....................  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00, 
....................  0x00  0x40  0x40  0x40  0xC0  0xC0  0xC0  0xC0, 
....................  0xC0  0xC0  0xC0  0xE0  0xE0  0xE0  0xE0  0xE0, 
....................  0xE0  0xE0  0xE0  0xE0  0x80  0x00  0x40  0x40, 
....................  0x40  0xC0  0xC0  0xC0  0xC0  0xE0  0xE0  0xE0, 
....................  0xE0  0xE0  0xE0  0xE0  0xE0  0xE0  0xC0  0xC0, 
....................  0x80  0x00  0x00  0x00  0xC0  0xE0  0xE0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xE0  0xE0, 
....................  0xC0  0xC0  0xE0  0x80  0x00  0x00  0x00  0x00, 
....................  0x00  0x40  0x60  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0x60  0x00  0x40  0x40  0x40  0xC0, 
....................  0xC0  0xC0  0xE0  0xE0  0xE0  0x60  0x20  0x20, 
....................  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00, 
....................  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00, 
....................  0x00  0x00  0x00  0x00  0xFF  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0x00  0x00  0x00  0x00, 
....................  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00, 
....................  0x00  0x00  0x00  0x00  0x01  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0xFF  0x70  0x78  0x78, 
....................  0x7C  0xFC  0x00  0x01  0x01  0x00  0x00  0x00, 
....................  0x00  0xFE  0xFF  0xFF  0xFF  0xFF  0xC3  0xC3, 
....................  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF, 
....................  0x7F  0x1F  0x00  0x03  0x0F  0x1F  0x1F  0x3F, 
....................  0x3F  0x7F  0x7F  0xFF  0xFF  0xFF  0xFD  0xF8, 
....................  0xF0  0xF1  0xF3  0xE3  0xE0  0xC0  0xC0  0x00, 
....................  0x02  0x02  0x06  0xFE  0xFE  0xFE  0xFE  0xFE, 
....................  0xFA  0x02  0x02  0x02  0x00  0x00  0xC0  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0xFF  0xF8  0x00  0x00, 
....................  0x00  0x00  0x80  0xC0  0xC0  0x00  0x00  0x00, 
....................  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00, 
....................  0x00  0x00  0x00  0x00  0xFF  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0xFC  0xF8  0xF0  0xE0, 
....................  0xC0  0x80  0x00  0x00  0x00  0x00  0x00  0x00, 
....................  0x00  0x60  0x20  0x20  0x30  0x30  0x3F  0x3F, 
....................  0x3F  0x3F  0x3F  0x3F  0x3D  0x7C  0x78  0x78, 
....................  0x78  0x78  0x78  0x7E  0x7E  0x06  0x00  0x20, 
....................  0x3E  0x3F  0x3F  0x3F  0x7F  0x7F  0x63  0x43, 
....................  0x07  0x0F  0x9F  0xFF  0x7F  0x7D  0x78  0x38, 
....................  0x30  0x20  0x00  0x00  0x06  0x1C  0x1C  0x1C, 
....................  0x38  0x38  0x38  0x7C  0x7F  0x7F  0x7F  0x7F, 
....................  0x7F  0x7F  0x3F  0x3F  0x3F  0x1F  0x0F  0x00, 
....................  0x20  0x20  0x3E  0x3F  0x3F  0x3F  0x3F  0x3F, 
....................  0x3F  0x3C  0x20  0x00  0x60  0x20  0x3F  0x3F, 
....................  0x3F  0x3F  0x3F  0x3F  0x3F  0x3F  0x3E  0x1E, 
....................  0x1E  0x1F  0x1F  0x1F  0x3F  0x70  0x00  0x00, 
....................  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x80, 
....................  0xC0  0xE0  0xF0  0xF8  0xFF  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFE  0xFC  0xF8  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0  0xF0, 
....................  0xF0  0xF0  0xF0  0xF8  0xFC  0xFE  0xFF  0xFF, 
....................  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF  0xFF 
.................... }; 
.................... /******************/ 
.................... /* 1024 Bytes */ 
.................... /*  End of LCD Pattern  */ 
....................  
.................... /* Data generated with bitmap2LCD */ 
.................... /* 14/03/2009 03:20:56 */ 
.................... /* Bitmap Source file : Test.bmp */ 
....................  
....................  
.................... const int image_xy[]= 
.................... { 
....................  0x40 , 0x20 // This 2 bytes defines the size of BMP for glcd_image_xy() function 
....................              // You should define it by yourself if your image converter does not 
....................              // add it by itself.(this image is 64x32 pixels -> 64=0x40, 32=0x20) 
....................  0xFF , 0xFF , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03, 
....................  0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0xC3 , 0xE3, 
....................  0x63 , 0x63 , 0x63 , 0x63 , 0xC3 , 0x83 , 0x03 , 0x03, 
....................  0x03 , 0x03 , 0x03 , 0x03 , 0x83 , 0xC3 , 0x63 , 0x33, 
....................  0x33 , 0x33 , 0x63 , 0xC3 , 0x03 , 0x03 , 0x03 , 0x03, 
....................  0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03, 
....................  0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03, 
....................  0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0xFF , 0xFF, 
....................  0xFF , 0xFF , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00, 
....................  0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x07 , 0x0F, 
....................  0x0C , 0x0E , 0x0F , 0x0E , 0x0C , 0x09 , 0x0F , 0x00, 
....................  0x80 , 0x80 , 0x80 , 0x03 , 0x0F , 0x0C , 0x08 , 0x0F, 
....................  0x0F , 0x04 , 0x0C , 0x0F , 0x0F , 0x00 , 0x00 , 0x00, 
....................  0x00 , 0x00 , 0xF0 , 0xF8 , 0xC0 , 0xC0 , 0xFC , 0xF0, 
....................  0x00 , 0x00 , 0x00 , 0xD0 , 0xB0 , 0x00 , 0x00 , 0xFC, 
....................  0xFE , 0xF8 , 0x00 , 0x00 , 0x00 , 0x00 , 0xFF , 0xFF, 
....................  0xFF , 0xFF , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00, 
....................  0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x03, 
....................  0x0F , 0x1E , 0x3C , 0x38 , 0x70 , 0x70 , 0xE0 , 0xE0, 
....................  0xE1 , 0xC3 , 0xC7 , 0xC0 , 0xC0 , 0x80 , 0x80 , 0x80, 
....................  0x80 , 0xF8 , 0xFC , 0x0E , 0x03 , 0x00 , 0x00 , 0x00, 
....................  0x00 , 0x00 , 0x0F , 0x07 , 0x00 , 0x00 , 0x07 , 0x03, 
....................  0x02 , 0x00 , 0x00 , 0x0F , 0x1F , 0x00 , 0x00 , 0x00, 
....................  0x73 , 0x71 , 0x40 , 0x00 , 0x00 , 0x00 , 0xFF , 0xFF, 
....................  0xFF , 0xFF , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0, 
....................  0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0, 
....................  0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0, 
....................  0xC0 , 0xC0 , 0xC0 , 0xC1 , 0xC1 , 0xC1 , 0xC1 , 0xC1, 
....................  0xC1 , 0xC1 , 0xC1 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0, 
....................  0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0, 
....................  0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0, 
....................  0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xFF , 0xFF 
.................... }; 
.................... /******************/ 
.................... /* 256 Bytes */ 
.................... /*  End of LCD Pattern  */ 
....................  
....................  
....................  
....................  
.................... #define GLCD_CS1 PIN_A0    // Chip Selection 1 
.................... #define GLCD_CS2 PIN_A0    // Chip Selection 2 
.................... #define GLCD_DI  PIN_A1    // Data or Instruction input 
.................... #define GLCD_RW  PIN_A2    // Read/Write 
.................... #define GLCD_E   PIN_A3    // Enable 
.................... #define GLCD_RST PIN_A4    // Reset 
.................... #define DATAIN   INPUT_B   // Data input port  (Should be same port as DATAOUT) 
.................... #define DATAOUT  OUTPUT_B  // Data output port (Should be same port as DATAIN) 
....................  
.................... #define GLCD_WIDTH 128     // Used for text wrapping by glcd_text57 function 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Initialize a graphic LCD. This must be called before any    // 
.................... //                other glcd function is used.                                // 
.................... // Inputs:        The initialization mode                                     // 
.................... //                OFF - Turns the LCD off                                     // 
.................... //                ON  - Turns the LCD on                                      // 
.................... //****************************************************************************// 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
04A3:  BSF    03.5
04A4:  BCF    05.4
04A5:  BCF    03.5
04A6:  BSF    05.4
....................    output_low(GLCD_E); 
04A7:  BSF    03.5
04A8:  BCF    05.3
04A9:  BCF    03.5
04AA:  BCF    05.3
....................    output_low(GLCD_CS1); 
04AB:  BSF    03.5
04AC:  BCF    05.0
04AD:  BCF    03.5
04AE:  BCF    05.0
....................    output_low(GLCD_CS2); 
04AF:  BSF    03.5
04B0:  BCF    05.0
04B1:  BCF    03.5
04B2:  BCF    05.0
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
04B3:  BSF    03.5
04B4:  BCF    05.1
04B5:  BCF    03.5
04B6:  BCF    05.1
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
04B7:  MOVLW  28
04B8:  MOVWF  30
04B9:  MOVLW  C0
04BA:  MOVWF  31
04BB:  CALL   40D
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //  of the screen 
04BC:  MOVLW  28
04BD:  MOVWF  30
04BE:  MOVLW  C0
04BF:  MOVWF  31
04C0:  CALL   40D
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
04C1:  MOVLW  28
04C2:  MOVWF  30
04C3:  MOVLW  40
04C4:  MOVWF  31
04C5:  CALL   40D
....................    glcd_writeByte(GLCD_CS2, 0x40); 
04C6:  MOVLW  28
04C7:  MOVWF  30
04C8:  MOVLW  40
04C9:  MOVWF  31
04CA:  CALL   40D
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
04CB:  MOVLW  28
04CC:  MOVWF  30
04CD:  MOVLW  B8
04CE:  MOVWF  31
04CF:  CALL   40D
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
04D0:  MOVLW  28
04D1:  MOVWF  30
04D2:  MOVLW  B8
04D3:  MOVWF  31
04D4:  CALL   40D
....................    if(mode == ON) 
04D5:  DECFSZ 21,W
04D6:  GOTO   4E2
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
04D7:  MOVLW  28
04D8:  MOVWF  30
04D9:  MOVLW  3F
04DA:  MOVWF  31
04DB:  CALL   40D
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
04DC:  MOVLW  28
04DD:  MOVWF  30
04DE:  MOVLW  3F
04DF:  MOVWF  31
04E0:  CALL   40D
....................    } 
....................    else 
04E1:  GOTO   4EC
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
04E2:  MOVLW  28
04E3:  MOVWF  30
04E4:  MOVLW  3E
04E5:  MOVWF  31
04E6:  CALL   40D
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
04E7:  MOVLW  28
04E8:  MOVWF  30
04E9:  MOVLW  3E
04EA:  MOVWF  31
04EB:  CALL   40D
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
04EC:  CLRF   29
04ED:  CALL   45A
.................... } 
04EE:  GOTO   617 (RETURN)
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Turns ON-OFF graphic LCD. Good solution on system standby   // 
.................... //                GLCD does not clear its memory map on OFF command. So last  // 
.................... //                screen shows up when ON command send to GLCD                // 
.................... // Inputs:        OFF - Turns the LCD off                                     // 
.................... //                ON  - Turns the LCD on                                      // 
.................... //****************************************************************************// 
.................... void glcd_standby(int1 command) 
.................... {   
....................    output_low(GLCD_E); 
....................    output_low(GLCD_CS1); 
....................    output_low(GLCD_CS2); 
....................    output_low(GLCD_DI); 
....................    if (command) 
....................    {    
....................       glcd_writeByte(GLCD_CS1,0x3F); 
....................       glcd_writeByte(GLCD_CS2,0x3F); 
....................    } 
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1,0x3E); 
....................       glcd_writeByte(GLCD_CS2,0x3E);    
....................    } 
.................... } 
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Turn a pixel on a graphic LCD on or off                     // 
.................... // Inputs:        x - the x coordinate of the pixel                           // 
.................... //                y - the y coordinate of the pixel                           // 
.................... //                color - ON or OFF                                           // 
.................... // Output:        1 if coordinate out of range, 0 if in range                 // 
.................... //****************************************************************************// 
.................... void glcd_pixel(int x, int y, int1 color) 
.................... { 
04EF:  MOVLW  28
04F0:  MOVWF  2E
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
04F1:  MOVF   2A,W
04F2:  SUBLW  3F
04F3:  BTFSC  03.0
04F4:  GOTO   4F9
....................    { 
....................       x -= 64; 
04F5:  MOVLW  40
04F6:  SUBWF  2A,F
....................       chip = GLCD_CS2; 
04F7:  MOVLW  28
04F8:  MOVWF  2E
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
04F9:  BSF    03.5
04FA:  BCF    05.1
04FB:  BCF    03.5
04FC:  BCF    05.1
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
04FD:  BCF    2A.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
04FE:  BSF    2A.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
04FF:  MOVF   2E,W
0500:  MOVWF  30
0501:  MOVF   2A,W
0502:  MOVWF  31
0503:  CALL   40D
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
0504:  RRF    2B,W
0505:  MOVWF  77
0506:  RRF    77,F
0507:  RRF    77,F
0508:  MOVLW  1F
0509:  ANDWF  77,F
050A:  MOVF   77,W
050B:  ANDLW  BF
050C:  IORLW  B8
050D:  MOVWF  2F
050E:  MOVF   2E,W
050F:  MOVWF  30
0510:  MOVF   2F,W
0511:  MOVWF  31
0512:  CALL   40D
....................    output_high(GLCD_DI);                                    // Set for data 
0513:  BSF    03.5
0514:  BCF    05.1
0515:  BCF    03.5
0516:  BSF    05.1
....................    data = glcd_readByte(chip); 
0517:  MOVF   2E,W
0518:  MOVWF  2F
*
054F:  MOVF   78,W
0550:  MOVWF  2D
....................  
....................    if(color == ON) 
0551:  DECFSZ 2C,W
0552:  GOTO   563
....................       bit_set(data, y%8);        // Turn the pixel on 
0553:  MOVF   2B,W
0554:  ANDLW  07
0555:  MOVWF  2F
0556:  MOVLW  01
0557:  MOVWF  77
0558:  MOVF   2F,W
0559:  MOVWF  78
055A:  BTFSC  03.2
055B:  GOTO   560
055C:  BCF    03.0
055D:  RLF    77,F
055E:  DECFSZ 78,F
055F:  GOTO   55C
0560:  MOVF   77,W
0561:  IORWF  2D,F
....................    else                          // or 
0562:  GOTO   573
....................       bit_clear(data, y%8);      // turn the pixel off 
0563:  MOVF   2B,W
0564:  ANDLW  07
0565:  MOVWF  2F
0566:  MOVLW  01
0567:  MOVWF  77
0568:  MOVF   2F,W
0569:  MOVWF  78
056A:  BTFSC  03.2
056B:  GOTO   570
056C:  BCF    03.0
056D:  RLF    77,F
056E:  DECFSZ 78,F
056F:  GOTO   56C
0570:  MOVF   77,W
0571:  XORLW  FF
0572:  ANDWF  2D,F
....................    output_low(GLCD_DI);          // Set for instruction 
0573:  BSF    03.5
0574:  BCF    05.1
0575:  BCF    03.5
0576:  BCF    05.1
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
0577:  MOVF   2E,W
0578:  MOVWF  30
0579:  MOVF   2A,W
057A:  MOVWF  31
057B:  CALL   40D
....................    output_high(GLCD_DI);         // Set for data 
057C:  BSF    03.5
057D:  BCF    05.1
057E:  BCF    03.5
057F:  BSF    05.1
....................    glcd_writeByte(chip, data);   // Write the pixel data 
0580:  MOVF   2E,W
0581:  MOVWF  30
0582:  MOVF   2D,W
0583:  MOVWF  31
0584:  CALL   40D
.................... } 
0585:  RETURN
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's              // 
.................... //                line drawing algorithm                                      //    
.................... // Inputs:        (x1, y1) - the start coordinate                             // 
.................... //                (x2, y2) - the end coordinate                               // 
.................... //                color - ON or OFF                                           // 
.................... // Dependencies:  glcd_pixel()                                                // 
.................... //****************************************************************************// 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................  
....................    if(x1 > x2) 
....................       addx = -1; 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................       addy = -1; 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          glcd_pixel(x, y, color); 
....................  
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          glcd_pixel(x, y, color); 
....................  
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Draw a rectangle on a graphic LCD                           // 
.................... // Inputs:        (x1, y1) - the start coordinate                             // 
.................... //                (x2, y2) - the end coordinate                               // 
.................... //                fill  - YES or NO                                           // 
.................... //                color - ON or OFF                                           // 
.................... // Dependencies:  glcd_pixel(), glcd_line()                                   //    
.................... //****************************************************************************// 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Draw a 3D box on a graphic LCD (Ex: to make a 3D Button)    // 
.................... // Inputs:        (x, y) - the start point                                    // 
.................... //                (width, height) - size of the box                           // 
.................... //                depth  - 3D depth effect ratio of the box (2 or 3 is fine)  // 
.................... //                color - ON or OFF                                           // 
.................... // Dependencies:  glcd_pixel()                                                //    
.................... //****************************************************************************// 
.................... void glcd_3Dbox(int16 x,int16 y,int16 width, int16 height, int depth, int1 color) 
.................... { 
....................    int16 i,j; 
....................    for(i=x;i<=x+width;i++) 
....................    { 
....................       glcd_pixel(i,y,1); 
....................       glcd_pixel(i,y+height,1); 
....................    }  
....................    for(i=y;i<=y+height;i++) 
....................    { 
....................       glcd_pixel(x,i,1); 
....................       glcd_pixel(x+width,i,1); 
....................    } 
....................    for(j=1;j<=depth;j++) 
....................    { 
....................       for(i=y+j;i<=y+height+j;i++) 
....................       { 
....................          glcd_pixel(x-j,i,1); 
....................       } 
....................    } 
....................    for(j=1;j<=depth;j++) 
....................    { 
....................       for(i=x-j;i<=(x-j+width);i++) 
....................       { 
....................          glcd_pixel(i,y+height+j,color); 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD                     // 
.................... // Inputs:        (x1, y1) - the start coordinate                             // 
.................... //                (x2, y2) - the end coordinate                               // 
.................... //                width  - The number of pixels wide                          // 
.................... //                color - ON or OFF                                           // 
.................... // Dependencies:  glcd_pixel()                                                // 
.................... //****************************************************************************// 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Draw a circle on a graphic LCD                              // 
.................... // Inputs:        (x,y) - the center of the circle                            // 
.................... //                radius - the radius of the circle                           // 
.................... //                fill - YES or NO                                            // 
.................... //                color - ON or OFF                                           // 
.................... // Dependencies:  glcd_pixel(), glcd_line()                                   // 
.................... //****************************************************************************// 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Draw a segment of a circle on a graphic LCD                 // 
.................... // Inputs:        (x,y) - The center of the circle                            // 
.................... //                radius - The radius of the circle                           // 
.................... //                angle_start - Start point angle of segment of circle        // 
.................... //                angle_end - End point angle of segment of circle            // 
.................... //                                                                            // 
.................... // Example:       (angle_start = 0 & angle_end = 360 draws a normal circle)   // 
.................... //                (angle_start = 0 & angle_end = 180 draws half circle (arc) )// 
.................... //                                                                            // 
.................... //                color - ON or OFF                                           // 
.................... // Dependencies:  glcd_pixel(), <math.h>                                      // 
.................... //****************************************************************************// 
.................... void glcd_circle_seg(int x, int y, int radius, int16 angle_start, int16 angle_end, int1 color) 
.................... { 
....................    int   x_round, y_round; 
....................    float angle; 
....................    #define DEGREE 2*3.14159265/360 
....................     
....................    for (angle = (float)angle_start; angle <= angle_end; angle += .9) 
....................    { 
....................       x_round = (sin (angle * DEGREE) * radius); 
....................       y_round = (cos (angle * DEGREE) * radius); 
....................       glcd_pixel(x + x_round, y + y_round, color); 
....................    } 
.................... } 
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Write text on a graphic LCD                                 // 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter       // 
.................... //                textptr - A pointer to an array of text to display          // 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ...        // 
.................... //                color - ON or OFF                                           // 
.................... // Dependencies:  glcd_pixel()                                                // 
.................... //****************************************************************************// 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
....................       { 
....................          x = 0;                           // Set x at far left position 
....................          y += 7*size + 1;                 // Set y at next position down 
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
....................                   } 
....................                } 
....................             } 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Fill the LCD screen with the passed in color                // 
.................... // Inputs:        ON - turn all the pixels on                                 // 
.................... //                OFF - turn all the pixels off                               // 
.................... // Dependencies:  glcd_writeByte()                                            // 
.................... //****************************************************************************// 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
045A:  CLRF   2A
045B:  MOVF   2A,W
045C:  SUBLW  07
045D:  BTFSS  03.0
045E:  GOTO   4A2
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
045F:  BSF    03.5
0460:  BCF    05.1
0461:  BCF    03.5
0462:  BCF    05.1
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0463:  MOVLW  28
0464:  MOVWF  30
0465:  MOVLW  40
0466:  MOVWF  31
0467:  CALL   40D
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
0468:  MOVLW  28
0469:  MOVWF  30
046A:  MOVLW  40
046B:  MOVWF  31
046C:  CALL   40D
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
046D:  MOVF   2A,W
046E:  IORLW  B8
046F:  MOVWF  2C
0470:  MOVLW  28
0471:  MOVWF  30
0472:  MOVF   2C,W
0473:  MOVWF  31
0474:  CALL   40D
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
0475:  MOVF   2A,W
0476:  IORLW  B8
0477:  MOVWF  2C
0478:  MOVLW  28
0479:  MOVWF  30
047A:  MOVF   2C,W
047B:  MOVWF  31
047C:  CALL   40D
....................       output_high(GLCD_DI);                     // Set for data 
047D:  BSF    03.5
047E:  BCF    05.1
047F:  BCF    03.5
0480:  BSF    05.1
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
0481:  CLRF   2B
0482:  MOVF   2B,W
0483:  SUBLW  3F
0484:  BTFSS  03.0
0485:  GOTO   4A0
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0486:  MOVLW  FF
0487:  MOVWF  2C
0488:  MOVF   29,W
0489:  MOVWF  2D
048A:  CALL   435
048B:  MOVF   78,W
048C:  MOVWF  2C
048D:  MOVLW  28
048E:  MOVWF  30
048F:  MOVF   78,W
0490:  MOVWF  31
0491:  CALL   40D
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
0492:  MOVLW  FF
0493:  MOVWF  2C
0494:  MOVF   29,W
0495:  MOVWF  2D
0496:  CALL   435
0497:  MOVF   78,W
0498:  MOVWF  2C
0499:  MOVLW  28
049A:  MOVWF  30
049B:  MOVF   78,W
049C:  MOVWF  31
049D:  CALL   40D
....................       } 
049E:  INCF   2B,F
049F:  GOTO   482
....................    } 
04A0:  INCF   2A,F
04A1:  GOTO   45B
.................... } 
04A2:  RETURN
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Fill the graphic LCD screen with 128x64 bit converted image // 
.................... // Inputs:        YES - Inverse of image (Raw data saved in ROM)              // 
.................... //                NO - Normal image (Raw data saved in ROM)                   // 
.................... // Dependencies:  glcd_pixel(), glcd_init()                                   // 
.................... //                                                                            // 
.................... //                      !! Check the "Bitmap.h" file !!                       // 
.................... //                                                                            // 
.................... //****************************************************************************// 
.................... void glcd_image(int1 inverse) 
.................... { 
*
0586:  CLRF   26
0587:  CLRF   25
0588:  MOVLW  80
0589:  MOVWF  27
058A:  MOVLW  40
058B:  MOVWF  28
....................    unsigned int i, j, k;  
....................    unsigned int16 count=0; 
....................    int width = 128;   
....................    int height = 64; 
....................    glcd_fillScreen(OFF);                        //Clears the screen (opt.) 
058C:  CLRF   29
058D:  CALL   45A
....................    if(inverse) 
058E:  MOVF   21,F
058F:  BTFSC  03.2
0590:  GOTO   5C5
....................    { 
....................       for(i=0;i<height;i+=8) 
0591:  CLRF   22
0592:  MOVF   28,W
0593:  SUBWF  22,W
0594:  BTFSC  03.0
0595:  GOTO   5C4
....................       { 
....................          for(j=0;j<width;j++) 
0596:  CLRF   23
0597:  MOVF   27,W
0598:  SUBWF  23,W
0599:  BTFSC  03.0
059A:  GOTO   5C1
....................          { 
....................             for(k=0;k<8;k++) 
059B:  CLRF   24
059C:  MOVF   24,W
059D:  SUBLW  07
059E:  BTFSS  03.0
059F:  GOTO   5BC
....................             {  
....................                if(~bit_test(image[count],k)) 
05A0:  MOVF   26,W
05A1:  MOVWF  7A
05A2:  MOVF   25,W
05A3:  CALL   004
05A4:  MOVWF  29
05A5:  MOVWF  77
05A6:  MOVF   24,W
05A7:  MOVWF  78
05A8:  BTFSC  03.2
05A9:  GOTO   5AE
05AA:  BCF    03.0
05AB:  RRF    77,F
05AC:  DECFSZ 78,F
05AD:  GOTO   5AA
05AE:  BTFSC  77.0
05AF:  GOTO   5BA
....................                { 
....................                   glcd_pixel(j,i+k,ON); 
05B0:  MOVF   24,W
05B1:  ADDWF  22,W
05B2:  MOVWF  29
05B3:  MOVF   23,W
05B4:  MOVWF  2A
05B5:  MOVF   29,W
05B6:  MOVWF  2B
05B7:  MOVLW  01
05B8:  MOVWF  2C
05B9:  CALL   4EF
....................                }          
....................                 
....................             } 
05BA:  INCF   24,F
05BB:  GOTO   59C
....................             count++; 
05BC:  INCF   25,F
05BD:  BTFSC  03.2
05BE:  INCF   26,F
....................          }   
05BF:  INCF   23,F
05C0:  GOTO   597
....................       } 
05C1:  MOVLW  08
05C2:  ADDWF  22,F
05C3:  GOTO   592
....................    } 
....................    else 
05C4:  GOTO   5F8
....................    { 
....................       for(i=0;i<height;i+=8) 
05C5:  CLRF   22
05C6:  MOVF   28,W
05C7:  SUBWF  22,W
05C8:  BTFSC  03.0
05C9:  GOTO   5F8
....................       { 
....................          for(j=0;j<width;j++) 
05CA:  CLRF   23
05CB:  MOVF   27,W
05CC:  SUBWF  23,W
05CD:  BTFSC  03.0
05CE:  GOTO   5F5
....................          { 
....................             for(k=0;k<8;k++) 
05CF:  CLRF   24
05D0:  MOVF   24,W
05D1:  SUBLW  07
05D2:  BTFSS  03.0
05D3:  GOTO   5F0
....................             {  
....................                if(bit_test(image[count],k)) 
05D4:  MOVF   26,W
05D5:  MOVWF  7A
05D6:  MOVF   25,W
05D7:  CALL   004
05D8:  MOVWF  29
05D9:  MOVWF  77
05DA:  MOVF   24,W
05DB:  MOVWF  78
05DC:  BTFSC  03.2
05DD:  GOTO   5E2
05DE:  BCF    03.0
05DF:  RRF    77,F
05E0:  DECFSZ 78,F
05E1:  GOTO   5DE
05E2:  BTFSS  77.0
05E3:  GOTO   5EE
....................                { 
....................                   glcd_pixel(j,i+k,ON); 
05E4:  MOVF   24,W
05E5:  ADDWF  22,W
05E6:  MOVWF  29
05E7:  MOVF   23,W
05E8:  MOVWF  2A
05E9:  MOVF   29,W
05EA:  MOVWF  2B
05EB:  MOVLW  01
05EC:  MOVWF  2C
05ED:  CALL   4EF
....................                }          
....................                 
....................             } 
05EE:  INCF   24,F
05EF:  GOTO   5D0
....................             count++; 
05F0:  INCF   25,F
05F1:  BTFSC  03.2
05F2:  INCF   26,F
....................          }   
05F3:  INCF   23,F
05F4:  GOTO   5CB
....................       } 
05F5:  MOVLW  08
05F6:  ADDWF  22,F
05F7:  GOTO   5C6
....................    } 
.................... } 
05F8:  GOTO   619 (RETURN)
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Draw less or equal 128x64 pixels of image to the graphic LCD// 
.................... //                screen on specified x, y coordinate                         //  
.................... // Inputs:        (x, y) - The start coordinate                               // 
.................... //                YES - Inverse of image (Raw data saved in ROM)              // 
.................... //                NO - Normal image (Raw data saved in ROM)                   // 
.................... // Dependencies:  glcd_pixel(), glcd_init()                                   // 
.................... //                                                                            // 
.................... //                       !!! PRLEASE BE CAREFULL !!                           // 
.................... //                                                                            // 
.................... //         First 2 bytes of your image data must be size of your BMP          // 
.................... //                                                                            // 
.................... // Example:       If your BMP image size is 64x32, first 2 bytes should       // 
.................... //                be 0x40, 0x20 --> (64 = 0x40, 32 = 0x20)                    // 
.................... //                                                                            // 
.................... //                      !! Check the "Bitmap.h" file !!                       // 
.................... //                                                                            // 
.................... //****************************************************************************// 
.................... void glcd_image_xy(int x, int y, int1 inverse) 
.................... { 
....................    unsigned int i, j, k; 
....................    unsigned int16 count=2; 
....................    int width  = image_xy[0]; 
....................    int height = image_xy[1]; 
....................    glcd_fillScreen(OFF);                        //Clears the screen (opt.) 
....................    if(inverse) 
....................    { 
....................       for(i=0;i<height;i+=8) 
....................       {    
....................          for(j=0;j<width;j++) 
....................          { 
....................             for(k=0;k<8;k++) 
....................             {  
....................                if(~bit_test(image_xy[count],k)) 
....................                { 
....................                   glcd_pixel(x+j,y+i+k,ON); 
....................                } 
....................             } 
....................             count++; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       for(i=0;i<height;i+=8) 
....................       {    
....................          for(j=0;j<width;j++) 
....................          { 
....................             for(k=0;k<8;k++) 
....................             {  
....................                if(bit_test(image_xy[count],k)) 
....................                { 
....................                   glcd_pixel(x+j,y+i+k,ON); 
....................                } 
....................             } 
....................             count++; 
....................          } 
....................       } 
....................    } 
.................... } 
....................        
.................... //****************************************************************************// 
.................... // Purpose:       Write a byte of data to the specified chip                  // 
.................... // Inputs:        chipSelect - which chip to write the data to                // 
.................... //                data - the byte of data to write                            // 
.................... //****************************************************************************// 
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
040D:  MOVF   30,W
040E:  SUBLW  28
040F:  BTFSS  03.2
0410:  GOTO   416
....................       output_high(GLCD_CS1); 
0411:  BSF    03.5
0412:  BCF    05.0
0413:  BCF    03.5
0414:  BSF    05.0
....................    else 
0415:  GOTO   41A
....................       output_high(GLCD_CS2); 
0416:  BSF    03.5
0417:  BCF    05.0
0418:  BCF    03.5
0419:  BSF    05.0
....................  
....................    output_low(GLCD_RW);       // Set for writing 
041A:  BSF    03.5
041B:  BCF    05.2
041C:  BCF    03.5
041D:  BCF    05.2
....................    DATAOUT(data);            // Put the data on the port 
041E:  BSF    03.5
041F:  CLRF   06
0420:  BCF    03.5
0421:  MOVF   31,W
0422:  MOVWF  06
....................    output_high(GLCD_E);       // Pulse the enable pin 
0423:  BSF    03.5
0424:  BCF    05.3
0425:  BCF    03.5
0426:  BSF    05.3
....................    delay_us(2); 
0427:  GOTO   428
....................    output_low(GLCD_E); 
0428:  BSF    03.5
0429:  BCF    05.3
042A:  BCF    03.5
042B:  BCF    05.3
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
042C:  BSF    03.5
042D:  BCF    05.0
042E:  BCF    03.5
042F:  BCF    05.0
....................    output_low(GLCD_CS2); 
0430:  BSF    03.5
0431:  BCF    05.0
0432:  BCF    03.5
0433:  BCF    05.0
.................... } 
0434:  RETURN
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Reads a byte of data from the specified chip                // 
.................... // Ouputs:        A byte of data read from the chip                           // 
.................... //****************************************************************************// 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
0519:  MOVF   2F,W
051A:  SUBLW  28
051B:  BTFSS  03.2
051C:  GOTO   522
....................       output_high(GLCD_CS1); 
051D:  BSF    03.5
051E:  BCF    05.0
051F:  BCF    03.5
0520:  BSF    05.0
....................    else 
0521:  GOTO   526
....................       output_high(GLCD_CS2); 
0522:  BSF    03.5
0523:  BCF    05.0
0524:  BCF    03.5
0525:  BSF    05.0
....................  
....................    DATAIN();                 // Set port d to input 
0526:  MOVLW  FF
0527:  BSF    03.5
0528:  MOVWF  06
....................    output_high(GLCD_RW);      // Set for reading 
0529:  BCF    05.2
052A:  BCF    03.5
052B:  BSF    05.2
....................    output_high(GLCD_E);       // Pulse the enable pin 
052C:  BSF    03.5
052D:  BCF    05.3
052E:  BCF    03.5
052F:  BSF    05.3
....................    delay_us(2); 
0530:  GOTO   531
....................    output_low(GLCD_E); 
0531:  BSF    03.5
0532:  BCF    05.3
0533:  BCF    03.5
0534:  BCF    05.3
....................    delay_us(2); 
0535:  GOTO   536
....................    output_high(GLCD_E);       // Pulse the enable pin 
0536:  BSF    03.5
0537:  BCF    05.3
0538:  BCF    03.5
0539:  BSF    05.3
....................    delay_us(2); 
053A:  GOTO   53B
....................    data = DATAIN();          // Get the data from the display's output register 
053B:  MOVLW  FF
053C:  BSF    03.5
053D:  MOVWF  06
053E:  BCF    03.5
053F:  MOVF   06,W
0540:  MOVWF  30
....................    output_low(GLCD_E); 
0541:  BSF    03.5
0542:  BCF    05.3
0543:  BCF    03.5
0544:  BCF    05.3
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0545:  BSF    03.5
0546:  BCF    05.0
0547:  BCF    03.5
0548:  BCF    05.0
....................    output_low(GLCD_CS2); 
0549:  BSF    03.5
054A:  BCF    05.0
054B:  BCF    03.5
054C:  BCF    05.0
....................    return data;               // Return the read data 
054D:  MOVF   30,W
054E:  MOVWF  78
.................... } 
....................  
....................  
.................... void main(void){ 
*
060E:  CLRF   04
060F:  BCF    03.7
0610:  MOVLW  1F
0611:  ANDWF  03,F
0612:  MOVLW  07
0613:  MOVWF  1F
....................    glcd_init(ON); 
0614:  MOVLW  01
0615:  MOVWF  21
0616:  GOTO   4A3
....................    
....................    glcd_image(NO); 
0617:  CLRF   21
0618:  GOTO   586
....................    delay_ms(4000); 
0619:  MOVLW  10
061A:  MOVWF  21
061B:  MOVLW  FA
061C:  MOVWF  22
061D:  GOTO   5F9
061E:  DECFSZ 21,F
061F:  GOTO   61B
....................    while(true){} 
0620:  GOTO   620
.................... } 
0621:  SLEEP

Configuration Fuses:
   Word  1: 3F21   NOWDT PUT XT MCLR NOBROWNOUT NOLVP NOCPD NOPROTECT
