CCS PCH C Compiler, Version 4.114, 93467473               13-dez-11 16:49

               Filename: D:\ELETRONICA\PROJETOS PIC CCS\LCD PE12864LRF-004-H\index.lst

               ROM used: 11958 bytes (36%)
                         Largest free fragment is 20810
               RAM used: 1039 (51%) at main() level
                         1174 (57%) worst case
               Stack:    8 locations

*
0000:  GOTO   2E86
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #use delay(clock=48000000) 
*
0200:  MOVLW  04
0202:  MOVWF  FEA
0204:  MOVLW  2B
0206:  MOVWF  FE9
0208:  MOVF   FEF,W
020A:  BZ    0228
020C:  MOVLW  0F
020E:  MOVWF  01
0210:  CLRF   00
0212:  DECFSZ 00,F
0214:  BRA    0212
0216:  DECFSZ 01,F
0218:  BRA    0210
021A:  MOVLW  8F
021C:  MOVWF  00
021E:  DECFSZ 00,F
0220:  BRA    021E
0222:  NOP   
0224:  DECFSZ FEF,F
0226:  BRA    020C
0228:  RETLW  00
.................... #fuses HSPLL, PLL4, CPUDIV1, PUT, NOWDT, NOBROWNOUT, NOLVP 
.................... #include "DriverPE12864LRF.c" 
.................... // Driver teste para o LCD 128x64 (PowerTip PE12864LRF-004-H/* 
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x00, 0x41, 0x49, 0x49, 0x36, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x00, 0x27, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x00, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x7e, 0x00, // A      34 
....................                          0x7F, 0x49, 0x49, 0x36, 0x00, // B 
....................                          0x3E, 0x41, 0x41, 0x22, 0x00, // C 
....................                          0x7F, 0x41, 0x41, 0x3e, 0x00, // D      37 
....................                          0x7F, 0x49, 0x49, 0x41, 0x00, // E 
....................                          0x7F, 0x09, 0x09, 0x01, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x08, 0x7f, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x3f, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x3e, 0x00, // O 
....................                          0x7F, 0x09, 0x09, 0x06, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x09, 0x76, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x32, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x40, 0x3f, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x08, 0x04, 0x78, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x04, 0x78, 0x00, // n 
....................                          0x38, 0x44, 0x44, 0x38, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x00, 0x3c, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x3c, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... #define PE12864_A0    pin_A0 
.................... #define PE12864_RES   pin_A1 
.................... #define PE12864_CS1   pin_A2 
.................... #define PE12864_CLK   pin_B0 
.................... #define PE12864_DATA  pin_B1 
....................  
.................... #define ON   1 
.................... #define OFF  0 
....................  
.................... int8 CurrentLine = 0; 
.................... int8 QuantChrLine = 0; 
.................... int8 OffsetX = 0; 
.................... byte Buffer[128][8]; 
....................  
.................... void    PE12864_InitLcd(void); 
.................... void    PE12864_Write_command(char byte_command); 
.................... void    PE12864_Write_data(char byte_data); 
.................... void    PE12864_Gotoxy(int8 x, int y); 
.................... void    PE12864_Printchar(char cvar); 
.................... void    PE12864_PutPixel(int8 x,int8 y, int1 COLOR); 
.................... void    PE12864_SerialOut(char byteDC); 
.................... void    clear_screen(void); 
.................... void    newLine(void); 
.................... void    PE12864_circle(int x, int y, int radius, int1 fill, int1 COLOR); 
.................... void    PE12864_line(int x1, int y1, int x2, int y2, int1 COLOR); 
.................... //void    linexy(int8 x1,int8 y1,int8 x2,int8 y2, int1 COLOR); 
....................  
.................... void    PE12864_InitLcd(void){ 
....................     
....................    output_low(PE12864_CS1); // Chip Enabled 
*
03E8:  BCF    F92.2
03EA:  BCF    F89.2
....................    output_low(PE12864_RES); 
03EC:  BCF    F92.1
03EE:  BCF    F89.1
....................    delay_ms(5); 
03F0:  MOVLW  05
03F2:  MOVLB  4
03F4:  MOVWF  x2B
03F6:  MOVLB  0
03F8:  RCALL  0200
....................    output_high(PE12864_RES);    
03FA:  BCF    F92.1
03FC:  BSF    F89.1
....................  
....................    // LCD BIAS SET 
....................    //- PAG 45 - 1010001-BIT    0: 1/9 ou 1: 1/7 ST7565S 
....................    PE12864_Write_command(0xa2); 
03FE:  MOVLW  A2
0400:  MOVLB  4
0402:  MOVWF  x58
0404:  MOVLB  0
0406:  RCALL  0260
....................    //1010011-BIT  Display Fill  0: Normal  1: Reverse 
....................    PE12864_Write_command(0xa6); // Normal 
0408:  MOVLW  A6
040A:  MOVLB  4
040C:  MOVWF  x58
040E:  MOVLB  0
0410:  RCALL  0260
....................    // Commom Output mode Select 
....................    //- PAG 46 -  1100-BIT      0: Normal Direction    1: Reverse Direction    (Ex: 11000*** - Normal Direction) 
....................    PE12864_Write_command(0xc8); 
0412:  MOVLW  C8
0414:  MOVLB  4
0416:  MOVWF  x58
0418:  MOVLB  0
041A:  RCALL  0260
....................    // LCD ADC Select 0:normal  1: Reverse 
....................    PE12864_Write_command(0xa0);    
041C:  MOVLW  A0
041E:  MOVLB  4
0420:  MOVWF  x58
0422:  MOVLB  0
0424:  RCALL  0260
....................    // CMD Set Start Line  
....................    PE12864_Write_command(0x40);    
0426:  MOVLW  40
0428:  MOVLB  4
042A:  MOVWF  x58
042C:  MOVLB  0
042E:  RCALL  0260
....................     
....................    PE12864_Write_command(0x28 | 0x4);  
0430:  MOVLW  2C
0432:  MOVLB  4
0434:  MOVWF  x58
0436:  MOVLB  0
0438:  RCALL  0260
....................    PE12864_Write_command(0x28 | 0x6);     
043A:  MOVLW  2E
043C:  MOVLB  4
043E:  MOVWF  x58
0440:  MOVLB  0
0442:  RCALL  0260
....................    PE12864_Write_command(0x28 | 0x7);     
0444:  MOVLW  2F
0446:  MOVLB  4
0448:  MOVWF  x58
044A:  MOVLB  0
044C:  RCALL  0260
....................    delay_us(5);    
044E:  MOVLW  13
0450:  MOVWF  00
0452:  DECFSZ 00,F
0454:  BRA    0452
0456:  BRA    0458
....................    PE12864_Write_command(0x20 | 0x6);  // resistor Ratio 
0458:  MOVLW  26
045A:  MOVLB  4
045C:  MOVWF  x58
045E:  MOVLB  0
0460:  RCALL  0260
....................    clear_screen(); 
0462:  BRA    037C
....................    PE12864_Write_command(0xaf); // Display ON 
0464:  MOVLW  AF
0466:  MOVLB  4
0468:  MOVWF  x58
046A:  MOVLB  0
046C:  RCALL  0260
....................    PE12864_Write_command(0xa4); // all points Normal 
046E:  MOVLW  A4
0470:  MOVLB  4
0472:  MOVWF  x58
0474:  MOVLB  0
0476:  RCALL  0260
....................  
....................    //Set Brightness   
....................    PE12864_Write_command(0x81);  
0478:  MOVLW  81
047A:  MOVLB  4
047C:  MOVWF  x58
047E:  MOVLB  0
0480:  RCALL  0260
....................    PE12864_Write_command(0x1a); 
0482:  MOVLW  1A
0484:  MOVLB  4
0486:  MOVWF  x58
0488:  MOVLB  0
048A:  RCALL  0260
.................... } 
048C:  GOTO   2EB0 (RETURN)
....................  
.................... void PE12864_SerialOut(char byteDC){ 
....................   int i; 
....................   output_low(PE12864_CS1);   
*
022A:  BCF    F92.2
022C:  BCF    F89.2
....................   for (i=8; i>0; i--) { 
022E:  MOVLW  08
0230:  MOVLB  4
0232:  MOVWF  x5A
0234:  MOVF   x5A,F
0236:  BZ    0258
....................     output_low(PE12864_CLK); 
0238:  BCF    F93.0
023A:  BCF    F8A.0
....................     if ((byteDC&0x80)==0) 
023C:  MOVF   x59,W
023E:  ANDLW  80
0240:  BNZ   0248
....................       output_low(PE12864_DATA); 
0242:  BCF    F93.1
0244:  BCF    F8A.1
....................     else 
0246:  BRA    024C
....................       output_high(PE12864_DATA); 
0248:  BCF    F93.1
024A:  BSF    F8A.1
....................     output_high(PE12864_CLK); 
024C:  BCF    F93.0
024E:  BSF    F8A.0
....................     byteDC<<=0x01; 
0250:  BCF    FD8.0
0252:  RLCF   x59,F
....................   } 
0254:  DECF   x5A,F
0256:  BRA    0234
....................   output_high(PE12864_CS1); 
0258:  BCF    F92.2
025A:  BSF    F89.2
.................... } 
025C:  MOVLB  0
025E:  RETLW  00
.................... void    PE12864_Write_command(char byte_command){ 
....................   output_low(PE12864_A0);          // Write Command Enabled 
0260:  BCF    F92.0
0262:  BCF    F89.0
....................   PE12864_SerialOut(byte_command); 
0264:  MOVFF  458,459
0268:  RCALL  022A
.................... } 
026A:  RETLW  00
.................... void    PE12864_Write_data(char byte_data){ 
....................   output_high(PE12864_A0);         // Write data Enabled 
*
032E:  BCF    F92.0
0330:  BSF    F89.0
....................   PE12864_SerialOut(byte_data); 
0332:  MOVFF  453,459
0336:  RCALL  022A
....................   Buffer[OffsetX][CurrentLine] = byte_data;   
0338:  MOVLB  4
033A:  CLRF   x55
033C:  MOVFF  06,454
0340:  CLRF   x57
0342:  MOVLW  08
0344:  MOVWF  x56
0346:  MOVLB  0
0348:  RCALL  030C
034A:  MOVFF  01,454
034E:  MOVF   04,W
0350:  MOVLB  4
0352:  ADDWF  01,W
0354:  MOVWF  01
0356:  MOVLW  00
0358:  ADDWFC 02,W
035A:  MOVWF  03
035C:  MOVF   01,W
035E:  ADDLW  07
0360:  MOVWF  FE9
0362:  MOVLW  00
0364:  ADDWFC 03,W
0366:  MOVWF  FEA
0368:  MOVFF  453,FEF
....................   OffsetX++; 
036C:  INCF   06,F
....................   PE12864_Gotoxy(OffsetX,CurrentLine); 
036E:  MOVFF  06,454
0372:  MOVFF  04,455
0376:  MOVLB  0
0378:  RCALL  0298
.................... } 
037A:  RETLW  00
.................... void newLine(){ 
....................   if(CurrentLine < 7){  // New Line Command 
....................       PE12864_Write_command((CurrentLine+1)|0xb0);  // Set Page Address to 0 (0 a 7) 
....................       PE12864_Write_command(0x00);  // Set LSB for index Column 
....................       PE12864_Write_command(0x10);  // Set MSB for index Column    
....................       CurrentLine+=1; 
....................   } 
....................   QuantChrLine = 1; 
....................   OffsetX = 0; 
.................... } 
.................... void clear_screen(void) { 
....................    int p, c; 
....................    for(p = 0; p < 8; p++) { 
037C:  MOVLB  4
037E:  CLRF   x0F
0380:  MOVF   x0F,W
0382:  SUBLW  07
0384:  BNC   03DC
....................       for(c = 0; c < 128; c++) { 
0386:  CLRF   x10
0388:  MOVF   x10,W
038A:  SUBLW  7F
038C:  BNC   03D8
....................          PE12864_Gotoxy(c,p); 
038E:  MOVFF  410,454
0392:  MOVFF  40F,455
0396:  MOVLB  0
0398:  RCALL  0298
....................          PE12864_Write_data(0x00); 
039A:  MOVLB  4
039C:  CLRF   x53
039E:  MOVLB  0
03A0:  RCALL  032E
....................          Buffer[c][p] = 0x00;         
03A2:  MOVLB  4
03A4:  CLRF   x55
03A6:  MOVFF  410,454
03AA:  CLRF   x57
03AC:  MOVLW  08
03AE:  MOVWF  x56
03B0:  MOVLB  0
03B2:  RCALL  030C
03B4:  MOVFF  01,411
03B8:  MOVLB  4
03BA:  MOVF   x0F,W
03BC:  ADDWF  01,W
03BE:  MOVWF  01
03C0:  MOVLW  00
03C2:  ADDWFC 02,W
03C4:  MOVWF  03
03C6:  MOVF   01,W
03C8:  ADDLW  07
03CA:  MOVWF  FE9
03CC:  MOVLW  00
03CE:  ADDWFC 03,W
03D0:  MOVWF  FEA
03D2:  CLRF   FEF
....................       } 
03D4:  INCF   x10,F
03D6:  BRA    0388
....................    } 
03D8:  INCF   x0F,F
03DA:  BRA    0380
....................    PE12864_Gotoxy(0,0);    
03DC:  CLRF   x54
03DE:  CLRF   x55
03E0:  MOVLB  0
03E2:  RCALL  0298
.................... } 
03E4:  GOTO   0464 (RETURN)
.................... void    PE12864_Gotoxy(int x, int y){ 
*
0298:  MOVLB  4
029A:  CLRF   x56
....................    int8 OffsetChr = 0; 
....................     
....................    PE12864_Write_command(0xb0 | y); 
029C:  MOVF   x55,W
029E:  IORLW  B0
02A0:  MOVWF  x57
02A2:  MOVWF  x58
02A4:  MOVLB  0
02A6:  RCALL  0260
....................    PE12864_Write_command((0x00 | x) & 0x0f); 
02A8:  MOVLB  4
02AA:  MOVF   x54,W
02AC:  ANDLW  0F
02AE:  MOVWF  x57
02B0:  MOVWF  x58
02B2:  MOVLB  0
02B4:  RCALL  0260
....................    PE12864_Write_command(0x10|(x>>4)); 
02B6:  MOVLB  4
02B8:  SWAPF  x54,W
02BA:  MOVWF  00
02BC:  MOVLW  0F
02BE:  ANDWF  00,F
02C0:  MOVF   00,W
02C2:  IORLW  10
02C4:  MOVWF  x57
02C6:  MOVWF  x58
02C8:  MOVLB  0
02CA:  RCALL  0260
....................     
....................    OffsetChr = (x+1)/6; 
02CC:  MOVLW  01
02CE:  MOVLB  4
02D0:  ADDWF  x54,W
02D2:  MOVWF  x58
02D4:  MOVWF  x59
02D6:  MOVLW  06
02D8:  MOVWF  x5A
02DA:  MOVLB  0
02DC:  RCALL  026C
02DE:  MOVFF  01,456
....................    if((x+1)%6) 
02E2:  MOVLW  01
02E4:  MOVLB  4
02E6:  ADDWF  x54,W
02E8:  MOVWF  x58
02EA:  MOVWF  x59
02EC:  MOVLW  06
02EE:  MOVWF  x5A
02F0:  MOVLB  0
02F2:  RCALL  026C
02F4:  MOVF   00,W
02F6:  BZ    02FE
....................       OffsetChr++;    
02F8:  MOVLB  4
02FA:  INCF   x56,F
02FC:  MOVLB  0
....................    CurrentLine = y; 
02FE:  MOVFF  455,04
....................    QuantChrLine = OffsetChr; 
0302:  MOVFF  456,05
....................    OffsetX = x; 
0306:  MOVFF  454,06
.................... } 
030A:  RETLW  00
.................... /*void    PE12864_Printchar(char cvar){ 
....................    int i; 
....................    if (QuantChrLine > 21)   
....................        newLine();  
....................    else 
....................        QuantChrLine++;     
....................    for(i=0;i<5;i++){ 
....................       if (cvar < 0x53) 
....................          PE12864_Write_data(TEXT[cvar-0x20][i]);       
....................       else  
....................          PE12864_Write_data(TEXT2[cvar-0x53][i]);                
....................    } 
....................    PE12864_Write_data(0x00); 
.................... }*/ 
....................  
.................... void    PE12864_Printchar(char cvar){ 
....................    int i; 
....................    if (QuantChrLine > 21)   
....................        newLine();  
....................    else 
....................        QuantChrLine++;     
....................    if(cvar == 0x20) 
....................       for(i=0;i<2;i++) 
....................          PE12864_Write_data(0x00); 
....................    else{ 
....................       for(i=0;i<5;i++){ 
....................          if (cvar < 0x53){ 
....................             if(TEXT[cvar-0x20][i])          
....................                PE12864_Write_data(TEXT[cvar-0x20][i]);       
....................          } 
....................          else { 
....................             if(TEXT2[cvar-0x53][i])                
....................                PE12864_Write_data(TEXT2[cvar-0x53][i]);                
....................          } 
....................       } 
....................    } 
....................    PE12864_Write_data(0x00); 
.................... } 
....................  
....................  
.................... void PE12864_PutPixel(int x, int y, int1 COLOR){ 
....................    byte BytePlot, tempByte; 
....................    if((x > 127)||(y > 63)) 
*
11AA:  MOVLB  4
11AC:  MOVF   x47,W
11AE:  SUBLW  7F
11B0:  BNC   11B8
11B2:  MOVF   x48,W
11B4:  SUBLW  3F
11B6:  BC    11BA
....................       return; 
11B8:  BRA    1244
....................    BytePlot = 0; 
11BA:  CLRF   x4A
....................    BytePlot |= 1; 
11BC:  BSF    x4A.0
....................    PE12864_Gotoxy(x,(y/8)); 
11BE:  RRCF   x48,W
11C0:  MOVWF  x4C
11C2:  RRCF   x4C,F
11C4:  RRCF   x4C,F
11C6:  MOVLW  1F
11C8:  ANDWF  x4C,F
11CA:  MOVFF  447,454
11CE:  MOVFF  44C,455
11D2:  MOVLB  0
11D4:  CALL   0298
....................    BytePlot<<=(y%8); 
11D8:  MOVLB  4
11DA:  MOVF   x48,W
11DC:  ANDLW  07
11DE:  MOVWF  01
11E0:  MOVF   01,F
11E2:  BZ    11EC
11E4:  BCF    FD8.0
11E6:  RLCF   x4A,F
11E8:  DECFSZ 01,F
11EA:  BRA    11E4
....................    tempByte = BytePlot;    
11EC:  MOVFF  44A,44B
....................    BytePlot|=Buffer[x][y/8];       
11F0:  CLRF   x55
11F2:  MOVFF  447,454
11F6:  CLRF   x57
11F8:  MOVLW  08
11FA:  MOVWF  x56
11FC:  MOVLB  0
11FE:  CALL   030C
1202:  MOVFF  01,44C
1206:  MOVLB  4
1208:  RRCF   x48,W
120A:  MOVWF  00
120C:  RRCF   00,F
120E:  RRCF   00,F
1210:  MOVLW  1F
1212:  ANDWF  00,F
1214:  MOVF   00,W
1216:  ADDWF  01,W
1218:  MOVWF  01
121A:  MOVLW  00
121C:  ADDWFC 02,W
121E:  MOVWF  03
1220:  MOVF   01,W
1222:  ADDLW  07
1224:  MOVWF  FE9
1226:  MOVLW  00
1228:  ADDWFC 03,W
122A:  MOVWF  FEA
122C:  MOVF   FEF,W
122E:  IORWF  x4A,F
....................    if(COLOR == OFF) 
1230:  MOVF   x49,F
1232:  BNZ   1238
....................       BytePlot-=tempByte; 
1234:  MOVF   x4B,W
1236:  SUBWF  x4A,F
....................    PE12864_Write_data(BytePlot); 
1238:  MOVFF  44A,453
123C:  MOVLB  0
123E:  CALL   032E
1242:  MOVLB  4
....................     
....................    /*   if(COLOR == ON) 
....................       BytePlot|=Buffer[x][y/8];       
....................    else{ 
....................       tempByte = BytePlot; 
....................       BytePlot|=Buffer[x][y/8];        
....................       BytePlot-=tempByte; 
....................       //BytePlot = ((BytePlot | Buffer[x][y/8]) - BytePlot);  
....................    }*/ 
.................... } 
1244:  MOVLB  0
1246:  RETLW  00
....................  
.................... void PE12864_circle(int x, int y, int radius, int1 fill, int1 COLOR){ 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................    do{ 
....................       if(fill){ 
....................          PE12864_line(x-a, y+b, x+a, y+b, color); 
....................          PE12864_line(x-a, y-b, x+a, y-b, color); 
....................          PE12864_line(x-b, y+a, x+b, y+a, color); 
....................          PE12864_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else{ 
....................          PE12864_PutPixel(a+x, b+y, color); 
....................          PE12864_PutPixel(b+x, a+y, color); 
....................          PE12864_PutPixel(x-a, b+y, color); 
....................          PE12864_PutPixel(x-b, a+y, color); 
....................          PE12864_PutPixel(b+x, y-a, color); 
....................          PE12864_PutPixel(a+x, y-b, color); 
....................          PE12864_PutPixel(x-a, y-b, color); 
....................          PE12864_PutPixel(x-b, y-a, color); 
....................       } 
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... void PE12864_line(int x1, int y1, int x2, int y2, int1 COLOR){ 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
*
2066:  MOVLB  4
2068:  MOVF   x39,W
206A:  SUBWF  x3B,W
206C:  MOVWF  x47
206E:  MOVF   x47,W
2070:  BTFSS  x47.7
2072:  BRA    207A
2074:  MOVLW  00
2076:  BSF    FD8.0
2078:  SUBFWB x47,W
207A:  MOVWF  x42
....................    dy = abs((signed int)(y2 - y1)); 
207C:  MOVF   x3A,W
207E:  SUBWF  x3C,W
2080:  MOVWF  x47
2082:  MOVF   x47,W
2084:  BTFSS  x47.7
2086:  BRA    208E
2088:  MOVLW  00
208A:  BSF    FD8.0
208C:  SUBFWB x47,W
208E:  MOVWF  x43
....................    x = x1; 
2090:  MOVFF  439,43E
....................    y = y1; 
2094:  MOVFF  43A,43F
....................  
....................    if(x1 > x2) 
2098:  MOVF   x39,W
209A:  SUBWF  x3B,W
209C:  BC    20A4
....................       addx = -1; 
209E:  MOVLW  FF
20A0:  MOVWF  x40
....................    else 
20A2:  BRA    20A8
....................       addx = 1; 
20A4:  MOVLW  01
20A6:  MOVWF  x40
....................    if(y1 > y2) 
20A8:  MOVF   x3A,W
20AA:  SUBWF  x3C,W
20AC:  BC    20B4
....................       addy = -1; 
20AE:  MOVLW  FF
20B0:  MOVWF  x41
....................    else 
20B2:  BRA    20B8
....................       addy = 1; 
20B4:  MOVLW  01
20B6:  MOVWF  x41
....................    if(dx >= dy){ 
20B8:  MOVF   x43,W
20BA:  XORLW  80
20BC:  MOVWF  00
20BE:  MOVF   x42,W
20C0:  XORLW  80
20C2:  SUBWF  00,W
20C4:  BZ    20C8
20C6:  BC    216C
....................       P = 2*dy - dx; 
20C8:  MOVLW  02
20CA:  MOVWF  x48
20CC:  MOVFF  443,449
20D0:  MOVLB  0
20D2:  RCALL  2018
20D4:  MOVLB  4
20D6:  MOVF   x42,W
20D8:  SUBWF  01,W
20DA:  CLRF   03
20DC:  BTFSC  FE8.7
20DE:  DECF   03,F
20E0:  MOVWF  x44
20E2:  MOVFF  03,445
....................       for(i=0; i<=dx; ++i){ 
20E6:  CLRF   x46
20E8:  BTFSC  x42.7
20EA:  BRA    216A
20EC:  MOVF   x46,W
20EE:  SUBWF  x42,W
20F0:  BNC   216A
....................          PE12864_PutPixel(x, y, COLOR); 
20F2:  MOVFF  43E,447
20F6:  MOVFF  43F,448
20FA:  MOVFF  43D,449
20FE:  MOVLB  0
2100:  CALL   11AA
....................          if(P < 0){ 
2104:  MOVLB  4
2106:  BTFSC  x45.7
2108:  BRA    210C
210A:  BRA    212E
....................             P += 2*dy; 
210C:  MOVLW  02
210E:  MOVWF  x48
2110:  MOVFF  443,449
2114:  MOVLB  0
2116:  RCALL  2018
2118:  MOVF   01,W
211A:  CLRF   03
211C:  BTFSC  FE8.7
211E:  DECF   03,F
2120:  MOVLB  4
2122:  ADDWF  x44,F
2124:  MOVF   03,W
2126:  ADDWFC x45,F
....................             x += addx; 
2128:  MOVF   x40,W
212A:  ADDWF  x3E,F
....................          } 
....................          else{ 
212C:  BRA    2166
....................             P += 2*dy - 2*dx; 
212E:  MOVLW  02
2130:  MOVWF  x48
2132:  MOVFF  443,449
2136:  MOVLB  0
2138:  RCALL  2018
213A:  MOVFF  01,447
213E:  MOVLW  02
2140:  MOVLB  4
2142:  MOVWF  x48
2144:  MOVFF  442,449
2148:  MOVLB  0
214A:  RCALL  2018
214C:  MOVF   01,W
214E:  MOVLB  4
2150:  SUBWF  x47,W
2152:  CLRF   03
2154:  BTFSC  FE8.7
2156:  DECF   03,F
2158:  ADDWF  x44,F
215A:  MOVF   03,W
215C:  ADDWFC x45,F
....................             x += addx; 
215E:  MOVF   x40,W
2160:  ADDWF  x3E,F
....................             y += addy; 
2162:  MOVF   x41,W
2164:  ADDWF  x3F,F
....................          } 
....................       } 
2166:  INCF   x46,F
2168:  BRA    20E8
....................    } 
....................    else{ 
216A:  BRA    220E
....................       P = 2*dx - dy; 
216C:  MOVLW  02
216E:  MOVWF  x48
2170:  MOVFF  442,449
2174:  MOVLB  0
2176:  RCALL  2018
2178:  MOVLB  4
217A:  MOVF   x43,W
217C:  SUBWF  01,W
217E:  CLRF   03
2180:  BTFSC  FE8.7
2182:  DECF   03,F
2184:  MOVWF  x44
2186:  MOVFF  03,445
....................       for(i=0; i<=dy; ++i){ 
218A:  CLRF   x46
218C:  BTFSC  x43.7
218E:  BRA    220E
2190:  MOVF   x46,W
2192:  SUBWF  x43,W
2194:  BNC   220E
....................          PE12864_PutPixel(x, y, COLOR); 
2196:  MOVFF  43E,447
219A:  MOVFF  43F,448
219E:  MOVFF  43D,449
21A2:  MOVLB  0
21A4:  CALL   11AA
....................  
....................          if(P < 0){ 
21A8:  MOVLB  4
21AA:  BTFSC  x45.7
21AC:  BRA    21B0
21AE:  BRA    21D2
....................             P += 2*dx; 
21B0:  MOVLW  02
21B2:  MOVWF  x48
21B4:  MOVFF  442,449
21B8:  MOVLB  0
21BA:  RCALL  2018
21BC:  MOVF   01,W
21BE:  CLRF   03
21C0:  BTFSC  FE8.7
21C2:  DECF   03,F
21C4:  MOVLB  4
21C6:  ADDWF  x44,F
21C8:  MOVF   03,W
21CA:  ADDWFC x45,F
....................             y += addy; 
21CC:  MOVF   x41,W
21CE:  ADDWF  x3F,F
....................          } 
....................          else{ 
21D0:  BRA    220A
....................             P += 2*dx - 2*dy; 
21D2:  MOVLW  02
21D4:  MOVWF  x48
21D6:  MOVFF  442,449
21DA:  MOVLB  0
21DC:  RCALL  2018
21DE:  MOVFF  01,447
21E2:  MOVLW  02
21E4:  MOVLB  4
21E6:  MOVWF  x48
21E8:  MOVFF  443,449
21EC:  MOVLB  0
21EE:  RCALL  2018
21F0:  MOVF   01,W
21F2:  MOVLB  4
21F4:  SUBWF  x47,W
21F6:  CLRF   03
21F8:  BTFSC  FE8.7
21FA:  DECF   03,F
21FC:  ADDWF  x44,F
21FE:  MOVF   03,W
2200:  ADDWFC x45,F
....................             x += addx; 
2202:  MOVF   x40,W
2204:  ADDWF  x3E,F
....................             y += addy; 
2206:  MOVF   x41,W
2208:  ADDWF  x3F,F
....................          } 
....................       } 
220A:  INCF   x46,F
220C:  BRA    218C
....................    } 
.................... } 
220E:  MOVLB  0
2210:  RETLW  00
....................  
.................... /*void linexy(int8 x1,int8 y1,int8 x2,int8 y2, int1 COLOR){ 
....................    int length_x, length_y, i; 
....................    float divResult; 
....................    length_x = abs((signed int)(x2 - x1)); 
....................    length_y = abs((signed int)(y2 - y1)); 
....................     
....................    if(length_x < length_y){ 
....................       divResult = (float)(length_x / length_y); 
....................       for(i = 0; i < length_y+1;i++) 
....................          PE12864_Putpixel(x1+ceil(divResult*i), y1+i, ON); 
....................    } 
....................    else{ 
....................       divResult = (float)(length_y / length_x); 
....................       for(i = 0; i < length_x+1;i++) 
....................          PE12864_Putpixel(x1+i, y1+ceil(divResult*i), ON); 
....................    }    
.................... } 
.................... */ 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
0E2A:  MOVLB  4
0E2C:  BCF    x3F.0
....................    y = x; 
0E2E:  MOVFF  433,438
0E32:  MOVFF  432,437
0E36:  MOVFF  431,436
0E3A:  MOVFF  430,435
....................  
....................    if (x < 0) 
0E3E:  MOVFF  433,485
0E42:  MOVFF  432,484
0E46:  MOVFF  431,483
0E4A:  MOVFF  430,482
0E4E:  CLRF   x89
0E50:  CLRF   x88
0E52:  CLRF   x87
0E54:  CLRF   x86
0E56:  MOVLB  0
0E58:  RCALL  0992
0E5A:  BNC   0E66
....................    { 
....................       s = 1; 
0E5C:  MOVLB  4
0E5E:  BSF    x3F.0
....................       y = -y; 
0E60:  MOVF   x36,W
0E62:  XORLW  80
0E64:  MOVWF  x36
....................    } 
....................  
....................    if (y <= 32768.0) 
0E66:  MOVFF  438,485
0E6A:  MOVFF  437,484
0E6E:  MOVFF  436,483
0E72:  MOVFF  435,482
0E76:  MOVLB  4
0E78:  CLRF   x89
0E7A:  CLRF   x88
0E7C:  CLRF   x87
0E7E:  MOVLW  8E
0E80:  MOVWF  x86
0E82:  MOVLB  0
0E84:  RCALL  0992
0E86:  BC    0E8A
0E88:  BNZ   0EBA
....................       res = (float32)(unsigned int16)y; 
0E8A:  MOVFF  438,485
0E8E:  MOVFF  437,484
0E92:  MOVFF  436,483
0E96:  MOVFF  435,482
0E9A:  RCALL  0A0C
0E9C:  MOVFF  02,487
0EA0:  MOVFF  01,486
0EA4:  CALL   0490
0EA8:  MOVFF  03,43C
0EAC:  MOVFF  02,43B
0EB0:  MOVFF  01,43A
0EB4:  MOVFF  00,439
....................  
....................  else if (y < 10000000.0) 
0EB8:  BRA    105A
0EBA:  MOVFF  438,485
0EBE:  MOVFF  437,484
0EC2:  MOVFF  436,483
0EC6:  MOVFF  435,482
0ECA:  MOVLW  80
0ECC:  MOVLB  4
0ECE:  MOVWF  x89
0ED0:  MOVLW  96
0ED2:  MOVWF  x88
0ED4:  MOVLW  18
0ED6:  MOVWF  x87
0ED8:  MOVLW  96
0EDA:  MOVWF  x86
0EDC:  MOVLB  0
0EDE:  RCALL  0992
0EE0:  BTFSS  FD8.0
0EE2:  BRA    104A
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0EE4:  MOVFF  438,489
0EE8:  MOVFF  437,488
0EEC:  MOVFF  436,487
0EF0:  MOVFF  435,486
0EF4:  MOVLB  4
0EF6:  CLRF   x8D
0EF8:  CLRF   x8C
0EFA:  CLRF   x8B
0EFC:  MOVLW  70
0EFE:  MOVWF  x8A
0F00:  MOVLB  0
0F02:  CALL   04C6
0F06:  MOVFF  03,485
0F0A:  MOVFF  02,484
0F0E:  MOVFF  01,483
0F12:  MOVFF  00,482
0F16:  RCALL  0A0C
0F18:  MOVFF  02,43E
0F1C:  MOVFF  01,43D
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0F20:  MOVFF  438,489
0F24:  MOVFF  437,488
0F28:  MOVFF  436,487
0F2C:  MOVFF  435,486
0F30:  MOVLB  4
0F32:  CLRF   x8D
0F34:  CLRF   x8C
0F36:  CLRF   x8B
0F38:  MOVLW  70
0F3A:  MOVWF  x8A
0F3C:  MOVLB  0
0F3E:  CALL   04C6
0F42:  MOVFF  00,440
0F46:  MOVFF  01,441
0F4A:  MOVFF  02,442
0F4E:  MOVFF  03,443
0F52:  MOVFF  43E,487
0F56:  MOVFF  43D,486
0F5A:  CALL   0490
0F5E:  BSF    FD8.1
0F60:  MOVFF  443,489
0F64:  MOVFF  442,488
0F68:  MOVFF  441,487
0F6C:  MOVFF  440,486
0F70:  MOVFF  03,48D
0F74:  MOVFF  02,48C
0F78:  MOVFF  01,48B
0F7C:  MOVFF  00,48A
0F80:  CALL   071A
0F84:  MOVLB  4
0F86:  CLRF   x89
0F88:  CLRF   x88
0F8A:  CLRF   x87
0F8C:  MOVLW  8E
0F8E:  MOVWF  x86
0F90:  MOVFF  03,48D
0F94:  MOVFF  02,48C
0F98:  MOVFF  01,48B
0F9C:  MOVFF  00,48A
0FA0:  MOVLB  0
0FA2:  CALL   04C6
0FA6:  MOVFF  03,438
0FAA:  MOVFF  02,437
0FAE:  MOVFF  01,436
0FB2:  MOVFF  00,435
....................       res = 32768.0*(float32)l; 
0FB6:  MOVFF  43E,487
0FBA:  MOVFF  43D,486
0FBE:  CALL   0490
0FC2:  MOVLB  4
0FC4:  CLRF   x89
0FC6:  CLRF   x88
0FC8:  CLRF   x87
0FCA:  MOVLW  8E
0FCC:  MOVWF  x86
0FCE:  MOVFF  03,48D
0FD2:  MOVFF  02,48C
0FD6:  MOVFF  01,48B
0FDA:  MOVFF  00,48A
0FDE:  MOVLB  0
0FE0:  CALL   04C6
0FE4:  MOVFF  03,43C
0FE8:  MOVFF  02,43B
0FEC:  MOVFF  01,43A
0FF0:  MOVFF  00,439
....................       res += (float32)(unsigned int16)y; 
0FF4:  MOVFF  438,485
0FF8:  MOVFF  437,484
0FFC:  MOVFF  436,483
1000:  MOVFF  435,482
1004:  RCALL  0A0C
1006:  MOVFF  02,487
100A:  MOVFF  01,486
100E:  CALL   0490
1012:  BCF    FD8.1
1014:  MOVFF  43C,489
1018:  MOVFF  43B,488
101C:  MOVFF  43A,487
1020:  MOVFF  439,486
1024:  MOVFF  03,48D
1028:  MOVFF  02,48C
102C:  MOVFF  01,48B
1030:  MOVFF  00,48A
1034:  CALL   071A
1038:  MOVFF  03,43C
103C:  MOVFF  02,43B
1040:  MOVFF  01,43A
1044:  MOVFF  00,439
....................    } 
....................  
....................  else 
1048:  BRA    105A
....................   res = y; 
104A:  MOVFF  438,43C
104E:  MOVFF  437,43B
1052:  MOVFF  436,43A
1056:  MOVFF  435,439
....................  
....................  y = y - (float32)(unsigned int16)y; 
105A:  MOVFF  438,485
105E:  MOVFF  437,484
1062:  MOVFF  436,483
1066:  MOVFF  435,482
106A:  RCALL  0A0C
106C:  MOVFF  02,487
1070:  MOVFF  01,486
1074:  CALL   0490
1078:  BSF    FD8.1
107A:  MOVFF  438,489
107E:  MOVFF  437,488
1082:  MOVFF  436,487
1086:  MOVFF  435,486
108A:  MOVFF  03,48D
108E:  MOVFF  02,48C
1092:  MOVFF  01,48B
1096:  MOVFF  00,48A
109A:  CALL   071A
109E:  MOVFF  03,438
10A2:  MOVFF  02,437
10A6:  MOVFF  01,436
10AA:  MOVFF  00,435
....................  
....................  if (s) 
10AE:  MOVLB  4
10B0:  BTFSS  x3F.0
10B2:  BRA    10BA
....................   res = -res; 
10B4:  MOVF   x3A,W
10B6:  XORLW  80
10B8:  MOVWF  x3A
....................  
....................  if (y != 0) 
10BA:  MOVFF  438,485
10BE:  MOVFF  437,484
10C2:  MOVFF  436,483
10C6:  MOVFF  435,482
10CA:  CLRF   x89
10CC:  CLRF   x88
10CE:  CLRF   x87
10D0:  CLRF   x86
10D2:  MOVLB  0
10D4:  RCALL  0992
10D6:  BZ    1150
....................  { 
....................   if (s == 1 && n == 0) 
10D8:  MOVLB  4
10DA:  BTFSS  x3F.0
10DC:  BRA    1116
10DE:  MOVF   x34,F
10E0:  BNZ   1116
....................    res -= 1.0; 
10E2:  BSF    FD8.1
10E4:  MOVFF  43C,489
10E8:  MOVFF  43B,488
10EC:  MOVFF  43A,487
10F0:  MOVFF  439,486
10F4:  CLRF   x8D
10F6:  CLRF   x8C
10F8:  CLRF   x8B
10FA:  MOVLW  7F
10FC:  MOVWF  x8A
10FE:  MOVLB  0
1100:  CALL   071A
1104:  MOVFF  03,43C
1108:  MOVFF  02,43B
110C:  MOVFF  01,43A
1110:  MOVFF  00,439
1114:  MOVLB  4
....................  
....................   if (s == 0 && n == 1) 
1116:  BTFSC  x3F.0
1118:  BRA    1152
111A:  DECFSZ x34,W
111C:  BRA    1152
....................    res += 1.0; 
111E:  BCF    FD8.1
1120:  MOVFF  43C,489
1124:  MOVFF  43B,488
1128:  MOVFF  43A,487
112C:  MOVFF  439,486
1130:  CLRF   x8D
1132:  CLRF   x8C
1134:  CLRF   x8B
1136:  MOVLW  7F
1138:  MOVWF  x8A
113A:  MOVLB  0
113C:  CALL   071A
1140:  MOVFF  03,43C
1144:  MOVFF  02,43B
1148:  MOVFF  01,43A
114C:  MOVFF  00,439
1150:  MOVLB  4
....................  } 
....................  if (x == 0) 
1152:  MOVFF  433,485
1156:  MOVFF  432,484
115A:  MOVFF  431,483
115E:  MOVFF  430,482
1162:  CLRF   x89
1164:  CLRF   x88
1166:  CLRF   x87
1168:  CLRF   x86
116A:  MOVLB  0
116C:  RCALL  0992
116E:  BNZ   117C
....................     res = 0; 
1170:  MOVLB  4
1172:  CLRF   x3C
1174:  CLRF   x3B
1176:  CLRF   x3A
1178:  CLRF   x39
117A:  MOVLB  0
....................  
....................  return (res); 
117C:  MOVFF  439,00
1180:  MOVFF  43A,01
1184:  MOVFF  43B,02
1188:  MOVFF  43C,03
.................... } 
118C:  GOTO   11A8 (RETURN)
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
1190:  MOVFF  42F,433
1194:  MOVFF  42E,432
1198:  MOVFF  42D,431
119C:  MOVFF  42C,430
11A0:  MOVLB  4
11A2:  CLRF   x34
11A4:  MOVLB  0
11A6:  BRA    0E2A
.................... } 
11A8:  RETLW  00
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
*
0A48:  MOVLB  4
0A4A:  CLRF   x63
0A4C:  CLRF   x62
0A4E:  CLRF   x61
0A50:  MOVLW  7F
0A52:  MOVWF  x60
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
0A54:  MOVLW  7E
0A56:  MOVWF  x6A
0A58:  MOVLW  80
0A5A:  MOVWF  x6B
0A5C:  CLRF   x6C
0A5E:  CLRF   x6D
0A60:  MOVLW  7A
0A62:  MOVWF  x6E
0A64:  MOVLW  2A
0A66:  MOVWF  x6F
0A68:  MOVLW  AA
0A6A:  MOVWF  x70
0A6C:  MOVLW  AB
0A6E:  MOVWF  x71
0A70:  MOVLW  75
0A72:  MOVWF  x72
0A74:  MOVLW  B6
0A76:  MOVWF  x73
0A78:  MOVLW  0B
0A7A:  MOVWF  x74
0A7C:  MOVLW  61
0A7E:  MOVWF  x75
0A80:  MOVLW  6F
0A82:  MOVWF  x76
0A84:  MOVLW  50
0A86:  MOVWF  x77
0A88:  MOVLW  0D
0A8A:  MOVWF  x78
0A8C:  MOVLW  01
0A8E:  MOVWF  x79
0A90:  MOVLW  69
0A92:  MOVWF  x7A
0A94:  MOVLW  93
0A96:  MOVWF  x7B
0A98:  MOVLW  F2
0A9A:  MOVWF  x7C
0A9C:  MOVLW  7E
0A9E:  MOVWF  x7D
0AA0:  MOVLW  62
0AA2:  MOVWF  x7E
0AA4:  MOVLW  0F
0AA6:  MOVWF  x7F
0AA8:  MOVLW  76
0AAA:  MOVWF  x80
0AAC:  MOVLW  AE
0AAE:  MOVWF  x81
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0AB0:  MOVFF  457,485
0AB4:  MOVFF  456,484
0AB8:  MOVFF  455,483
0ABC:  MOVFF  454,482
0AC0:  CLRF   x89
0AC2:  CLRF   x88
0AC4:  CLRF   x87
0AC6:  CLRF   x86
0AC8:  MOVLB  0
0ACA:  RCALL  0992
0ACC:  BNC   0AD6
0ACE:  MOVLB  4
0AD0:  MOVF   x55,W
0AD2:  XORLW  80
0AD4:  MOVWF  x55
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0AD6:  MOVFF  457,489
0ADA:  MOVFF  456,488
0ADE:  MOVFF  455,487
0AE2:  MOVFF  454,486
0AE6:  MOVLW  83
0AE8:  MOVLB  4
0AEA:  MOVWF  x8D
0AEC:  MOVLW  F9
0AEE:  MOVWF  x8C
0AF0:  MOVLW  22
0AF2:  MOVWF  x8B
0AF4:  MOVLW  7E
0AF6:  MOVWF  x8A
0AF8:  MOVLB  0
0AFA:  RCALL  04C6
0AFC:  MOVFF  03,485
0B00:  MOVFF  02,484
0B04:  MOVFF  01,483
0B08:  MOVFF  00,482
0B0C:  RCALL  0A0C
0B0E:  MOVFF  01,464
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0B12:  MOVFF  457,489
0B16:  MOVFF  456,488
0B1A:  MOVFF  455,487
0B1E:  MOVFF  454,486
0B22:  MOVLW  83
0B24:  MOVLB  4
0B26:  MOVWF  x8D
0B28:  MOVLW  F9
0B2A:  MOVWF  x8C
0B2C:  MOVLW  22
0B2E:  MOVWF  x8B
0B30:  MOVLW  7E
0B32:  MOVWF  x8A
0B34:  MOVLB  0
0B36:  RCALL  04C6
0B38:  MOVFF  00,482
0B3C:  MOVFF  01,483
0B40:  MOVFF  02,484
0B44:  MOVFF  03,485
0B48:  MOVLB  4
0B4A:  CLRF   x87
0B4C:  MOVFF  464,486
0B50:  MOVLB  0
0B52:  RCALL  0490
0B54:  BSF    FD8.1
0B56:  MOVFF  485,489
0B5A:  MOVFF  484,488
0B5E:  MOVFF  483,487
0B62:  MOVFF  482,486
0B66:  MOVFF  03,48D
0B6A:  MOVFF  02,48C
0B6E:  MOVFF  01,48B
0B72:  MOVFF  00,48A
0B76:  RCALL  071A
0B78:  MOVFF  03,469
0B7C:  MOVFF  02,468
0B80:  MOVFF  01,467
0B84:  MOVFF  00,466
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0B88:  MOVLW  03
0B8A:  MOVLB  4
0B8C:  ANDWF  x64,F
....................  
....................    if (quad == 0 || quad == 2) 
0B8E:  MOVF   x64,F
0B90:  BZ    0B98
0B92:  MOVF   x64,W
0B94:  SUBLW  02
0B96:  BNZ   0BD0
....................       t = frac * PI_DIV_BY_TWO; 
0B98:  MOVFF  469,489
0B9C:  MOVFF  468,488
0BA0:  MOVFF  467,487
0BA4:  MOVFF  466,486
0BA8:  MOVLW  DB
0BAA:  MOVWF  x8D
0BAC:  MOVLW  0F
0BAE:  MOVWF  x8C
0BB0:  MOVLW  49
0BB2:  MOVWF  x8B
0BB4:  MOVLW  7F
0BB6:  MOVWF  x8A
0BB8:  MOVLB  0
0BBA:  RCALL  04C6
0BBC:  MOVFF  03,45F
0BC0:  MOVFF  02,45E
0BC4:  MOVFF  01,45D
0BC8:  MOVFF  00,45C
....................    else if (quad == 1) 
0BCC:  BRA    0CA4
0BCE:  MOVLB  4
0BD0:  DECFSZ x64,W
0BD2:  BRA    0C3E
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0BD4:  BSF    FD8.1
0BD6:  CLRF   x89
0BD8:  CLRF   x88
0BDA:  CLRF   x87
0BDC:  MOVLW  7F
0BDE:  MOVWF  x86
0BE0:  MOVFF  469,48D
0BE4:  MOVFF  468,48C
0BE8:  MOVFF  467,48B
0BEC:  MOVFF  466,48A
0BF0:  MOVLB  0
0BF2:  RCALL  071A
0BF4:  MOVFF  00,482
0BF8:  MOVFF  01,483
0BFC:  MOVFF  02,484
0C00:  MOVFF  03,485
0C04:  MOVFF  03,489
0C08:  MOVFF  02,488
0C0C:  MOVFF  01,487
0C10:  MOVFF  00,486
0C14:  MOVLW  DB
0C16:  MOVLB  4
0C18:  MOVWF  x8D
0C1A:  MOVLW  0F
0C1C:  MOVWF  x8C
0C1E:  MOVLW  49
0C20:  MOVWF  x8B
0C22:  MOVLW  7F
0C24:  MOVWF  x8A
0C26:  MOVLB  0
0C28:  RCALL  04C6
0C2A:  MOVFF  03,45F
0C2E:  MOVFF  02,45E
0C32:  MOVFF  01,45D
0C36:  MOVFF  00,45C
....................    else // should be 3 
0C3A:  BRA    0CA4
0C3C:  MOVLB  4
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0C3E:  BSF    FD8.1
0C40:  MOVFF  469,489
0C44:  MOVFF  468,488
0C48:  MOVFF  467,487
0C4C:  MOVFF  466,486
0C50:  CLRF   x8D
0C52:  CLRF   x8C
0C54:  CLRF   x8B
0C56:  MOVLW  7F
0C58:  MOVWF  x8A
0C5A:  MOVLB  0
0C5C:  RCALL  071A
0C5E:  MOVFF  00,482
0C62:  MOVFF  01,483
0C66:  MOVFF  02,484
0C6A:  MOVFF  03,485
0C6E:  MOVFF  03,489
0C72:  MOVFF  02,488
0C76:  MOVFF  01,487
0C7A:  MOVFF  00,486
0C7E:  MOVLW  DB
0C80:  MOVLB  4
0C82:  MOVWF  x8D
0C84:  MOVLW  0F
0C86:  MOVWF  x8C
0C88:  MOVLW  49
0C8A:  MOVWF  x8B
0C8C:  MOVLW  7F
0C8E:  MOVWF  x8A
0C90:  MOVLB  0
0C92:  RCALL  04C6
0C94:  MOVFF  03,45F
0C98:  MOVFF  02,45E
0C9C:  MOVFF  01,45D
0CA0:  MOVFF  00,45C
....................  
....................    y = 1.0; 
0CA4:  MOVLB  4
0CA6:  CLRF   x5B
0CA8:  CLRF   x5A
0CAA:  CLRF   x59
0CAC:  MOVLW  7F
0CAE:  MOVWF  x58
....................    t = t * t; 
0CB0:  MOVFF  45F,489
0CB4:  MOVFF  45E,488
0CB8:  MOVFF  45D,487
0CBC:  MOVFF  45C,486
0CC0:  MOVFF  45F,48D
0CC4:  MOVFF  45E,48C
0CC8:  MOVFF  45D,48B
0CCC:  MOVFF  45C,48A
0CD0:  MOVLB  0
0CD2:  CALL   04C6
0CD6:  MOVFF  03,45F
0CDA:  MOVFF  02,45E
0CDE:  MOVFF  01,45D
0CE2:  MOVFF  00,45C
....................    for (i = 0; i <= 5; i++) 
0CE6:  MOVLB  4
0CE8:  CLRF   x65
0CEA:  MOVF   x65,W
0CEC:  SUBLW  05
0CEE:  BNC   0DBA
....................    { 
....................       t2 = t2 * t; 
0CF0:  MOVFF  463,489
0CF4:  MOVFF  462,488
0CF8:  MOVFF  461,487
0CFC:  MOVFF  460,486
0D00:  MOVFF  45F,48D
0D04:  MOVFF  45E,48C
0D08:  MOVFF  45D,48B
0D0C:  MOVFF  45C,48A
0D10:  MOVLB  0
0D12:  CALL   04C6
0D16:  MOVFF  03,463
0D1A:  MOVFF  02,462
0D1E:  MOVFF  01,461
0D22:  MOVFF  00,460
....................       y = y + p[i] * t2; 
0D26:  MOVLB  4
0D28:  MOVF   x65,W
0D2A:  MULLW  04
0D2C:  MOVF   FF3,W
0D2E:  CLRF   03
0D30:  ADDLW  6A
0D32:  MOVWF  FE9
0D34:  MOVLW  04
0D36:  ADDWFC 03,W
0D38:  MOVWF  FEA
0D3A:  MOVFF  FEF,482
0D3E:  MOVFF  FEC,483
0D42:  MOVFF  FEC,484
0D46:  MOVFF  FEC,485
0D4A:  MOVFF  485,489
0D4E:  MOVFF  484,488
0D52:  MOVFF  483,487
0D56:  MOVFF  482,486
0D5A:  MOVFF  463,48D
0D5E:  MOVFF  462,48C
0D62:  MOVFF  461,48B
0D66:  MOVFF  460,48A
0D6A:  MOVLB  0
0D6C:  CALL   04C6
0D70:  MOVFF  FEA,483
0D74:  MOVFF  FE9,482
0D78:  BCF    FD8.1
0D7A:  MOVFF  45B,489
0D7E:  MOVFF  45A,488
0D82:  MOVFF  459,487
0D86:  MOVFF  458,486
0D8A:  MOVFF  03,48D
0D8E:  MOVFF  02,48C
0D92:  MOVFF  01,48B
0D96:  MOVFF  00,48A
0D9A:  RCALL  071A
0D9C:  MOVFF  483,FEA
0DA0:  MOVFF  482,FE9
0DA4:  MOVFF  03,45B
0DA8:  MOVFF  02,45A
0DAC:  MOVFF  01,459
0DB0:  MOVFF  00,458
....................    } 
0DB4:  MOVLB  4
0DB6:  INCF   x65,F
0DB8:  BRA    0CEA
....................  
....................    if (quad == 2 || quad == 1) 
0DBA:  MOVF   x64,W
0DBC:  SUBLW  02
0DBE:  BZ    0DC4
0DC0:  DECFSZ x64,W
0DC2:  BRA    0DCA
....................       y = -y;  // correct sign 
0DC4:  MOVF   x59,W
0DC6:  XORLW  80
0DC8:  MOVWF  x59
....................  
....................    return (y); 
0DCA:  MOVFF  458,00
0DCE:  MOVFF  459,01
0DD2:  MOVFF  45A,02
0DD6:  MOVFF  45B,03
.................... } 
0DDA:  MOVLB  0
0DDC:  RETLW  00
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
0DDE:  BSF    FD8.1
0DE0:  MOVFF  44F,489
0DE4:  MOVFF  44E,488
0DE8:  MOVFF  44D,487
0DEC:  MOVFF  44C,486
0DF0:  MOVLW  DB
0DF2:  MOVLB  4
0DF4:  MOVWF  x8D
0DF6:  MOVLW  0F
0DF8:  MOVWF  x8C
0DFA:  MOVLW  49
0DFC:  MOVWF  x8B
0DFE:  MOVLW  7F
0E00:  MOVWF  x8A
0E02:  MOVLB  0
0E04:  RCALL  071A
0E06:  MOVFF  00,450
0E0A:  MOVFF  01,451
0E0E:  MOVFF  02,452
0E12:  MOVFF  03,453
0E16:  MOVFF  03,457
0E1A:  MOVFF  02,456
0E1E:  MOVFF  01,455
0E22:  MOVFF  00,454
0E26:  RCALL  0A48
.................... } 
0E28:  RETLW  00
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
1970:  MOVFF  454,456
1974:  MOVFF  453,455
1978:  MOVFF  456,03
197C:  MOVLB  4
197E:  MOVFF  455,FE9
1982:  MOVFF  456,FEA
1986:  MOVF   FEF,F
1988:  BZ    1996
198A:  INCF   x55,F
198C:  BTFSC  FD8.2
198E:  INCF   x56,F
1990:  MOVLB  0
1992:  BRA    1978
1994:  MOVLB  4
....................    return(sc - s); 
1996:  MOVF   x53,W
1998:  SUBWF  x55,W
199A:  MOVWF  00
199C:  MOVF   x54,W
199E:  SUBWFB x56,W
19A0:  MOVWF  03
19A2:  MOVFF  00,01
.................... } 
19A6:  MOVLB  0
19A8:  GOTO   19BC (RETURN)
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void PE12864_TextXy(int x, int y, char* cvar); 
.................... void circulo(float aC, float bC, float r); 
.................... void circuloMenor(float aC, float bC, float r); 
.................... void circuloPonteiro(float aC, float bC, float r); 
.................... void circuloNumerico(float aC, float bC, float r); 
....................  
....................  
.................... void circulo(float aC, float bC, float r){ 
*
1248:  MOVLB  4
124A:  CLRF   x1C
124C:  CLRF   x1B
....................    int16 i = 0; 
....................    float y, x; 
....................    while(i <= 360){ 
124E:  MOVF   x1C,W
1250:  SUBLW  01
1252:  BTFSS  FD8.0
1254:  BRA    1540
1256:  BNZ   1260
1258:  MOVF   x1B,W
125A:  SUBLW  68
125C:  BTFSS  FD8.0
125E:  BRA    1540
....................       y = (sin(i*pi/180)*r)+bC; 
1260:  MOVFF  41C,487
1264:  MOVFF  41B,486
1268:  MOVLB  0
126A:  CALL   0490
126E:  MOVFF  03,489
1272:  MOVFF  02,488
1276:  MOVFF  01,487
127A:  MOVFF  00,486
127E:  MOVLW  DB
1280:  MOVLB  4
1282:  MOVWF  x8D
1284:  MOVLW  0F
1286:  MOVWF  x8C
1288:  MOVLW  49
128A:  MOVWF  x8B
128C:  MOVLW  80
128E:  MOVWF  x8A
1290:  MOVLB  0
1292:  CALL   04C6
1296:  MOVFF  00,425
129A:  MOVFF  01,426
129E:  MOVFF  02,427
12A2:  MOVFF  03,428
12A6:  MOVFF  03,44F
12AA:  MOVFF  02,44E
12AE:  MOVFF  01,44D
12B2:  MOVFF  00,44C
12B6:  MOVLB  4
12B8:  CLRF   x53
12BA:  CLRF   x52
12BC:  MOVLW  34
12BE:  MOVWF  x51
12C0:  MOVLW  86
12C2:  MOVWF  x50
12C4:  MOVLB  0
12C6:  CALL   05BC
12CA:  MOVFF  00,425
12CE:  MOVFF  01,426
12D2:  MOVFF  02,427
12D6:  MOVFF  03,428
12DA:  MOVFF  03,44F
12DE:  MOVFF  02,44E
12E2:  MOVFF  01,44D
12E6:  MOVFF  00,44C
12EA:  RCALL  0DDE
12EC:  MOVFF  00,425
12F0:  MOVFF  01,426
12F4:  MOVFF  02,427
12F8:  MOVFF  03,428
12FC:  MOVFF  03,489
1300:  MOVFF  02,488
1304:  MOVFF  01,487
1308:  MOVFF  00,486
130C:  MOVFF  41A,48D
1310:  MOVFF  419,48C
1314:  MOVFF  418,48B
1318:  MOVFF  417,48A
131C:  CALL   04C6
1320:  MOVFF  00,425
1324:  MOVFF  01,426
1328:  MOVFF  02,427
132C:  MOVFF  03,428
1330:  MOVFF  FEA,42A
1334:  MOVFF  FE9,429
1338:  BCF    FD8.1
133A:  MOVFF  03,489
133E:  MOVFF  02,488
1342:  MOVFF  01,487
1346:  MOVFF  00,486
134A:  MOVFF  416,48D
134E:  MOVFF  415,48C
1352:  MOVFF  414,48B
1356:  MOVFF  413,48A
135A:  CALL   071A
135E:  MOVFF  42A,FEA
1362:  MOVFF  429,FE9
1366:  MOVFF  03,420
136A:  MOVFF  02,41F
136E:  MOVFF  01,41E
1372:  MOVFF  00,41D
....................       x = (cos(i*pi/180)*r)+aC;       
1376:  MOVFF  41C,487
137A:  MOVFF  41B,486
137E:  CALL   0490
1382:  MOVFF  03,489
1386:  MOVFF  02,488
138A:  MOVFF  01,487
138E:  MOVFF  00,486
1392:  MOVLW  DB
1394:  MOVLB  4
1396:  MOVWF  x8D
1398:  MOVLW  0F
139A:  MOVWF  x8C
139C:  MOVLW  49
139E:  MOVWF  x8B
13A0:  MOVLW  80
13A2:  MOVWF  x8A
13A4:  MOVLB  0
13A6:  CALL   04C6
13AA:  MOVFF  00,425
13AE:  MOVFF  01,426
13B2:  MOVFF  02,427
13B6:  MOVFF  03,428
13BA:  MOVFF  03,44F
13BE:  MOVFF  02,44E
13C2:  MOVFF  01,44D
13C6:  MOVFF  00,44C
13CA:  MOVLB  4
13CC:  CLRF   x53
13CE:  CLRF   x52
13D0:  MOVLW  34
13D2:  MOVWF  x51
13D4:  MOVLW  86
13D6:  MOVWF  x50
13D8:  MOVLB  0
13DA:  CALL   05BC
13DE:  MOVFF  00,425
13E2:  MOVFF  01,426
13E6:  MOVFF  02,427
13EA:  MOVFF  03,428
13EE:  MOVFF  03,457
13F2:  MOVFF  02,456
13F6:  MOVFF  01,455
13FA:  MOVFF  00,454
13FE:  CALL   0A48
1402:  MOVFF  00,425
1406:  MOVFF  01,426
140A:  MOVFF  02,427
140E:  MOVFF  03,428
1412:  MOVFF  03,489
1416:  MOVFF  02,488
141A:  MOVFF  01,487
141E:  MOVFF  00,486
1422:  MOVFF  41A,48D
1426:  MOVFF  419,48C
142A:  MOVFF  418,48B
142E:  MOVFF  417,48A
1432:  CALL   04C6
1436:  MOVFF  00,425
143A:  MOVFF  01,426
143E:  MOVFF  02,427
1442:  MOVFF  03,428
1446:  MOVFF  FEA,42A
144A:  MOVFF  FE9,429
144E:  BCF    FD8.1
1450:  MOVFF  03,489
1454:  MOVFF  02,488
1458:  MOVFF  01,487
145C:  MOVFF  00,486
1460:  MOVFF  412,48D
1464:  MOVFF  411,48C
1468:  MOVFF  410,48B
146C:  MOVFF  40F,48A
1470:  CALL   071A
1474:  MOVFF  42A,FEA
1478:  MOVFF  429,FE9
147C:  MOVFF  03,424
1480:  MOVFF  02,423
1484:  MOVFF  01,422
1488:  MOVFF  00,421
....................       PE12864_Putpixel(floor(x), floor(64-y), ON); 
148C:  MOVFF  424,42F
1490:  MOVFF  423,42E
1494:  MOVFF  422,42D
1498:  MOVFF  421,42C
149C:  RCALL  1190
149E:  MOVFF  03,485
14A2:  MOVFF  02,484
14A6:  MOVFF  01,483
14AA:  MOVFF  00,482
14AE:  CALL   0A0C
14B2:  MOVFF  01,425
14B6:  MOVFF  FEA,427
14BA:  MOVFF  FE9,426
14BE:  BSF    FD8.1
14C0:  MOVLB  4
14C2:  CLRF   x89
14C4:  CLRF   x88
14C6:  CLRF   x87
14C8:  MOVLW  85
14CA:  MOVWF  x86
14CC:  MOVFF  420,48D
14D0:  MOVFF  41F,48C
14D4:  MOVFF  41E,48B
14D8:  MOVFF  41D,48A
14DC:  MOVLB  0
14DE:  CALL   071A
14E2:  MOVFF  427,FEA
14E6:  MOVFF  426,FE9
14EA:  MOVFF  00,428
14EE:  MOVFF  01,429
14F2:  MOVFF  02,42A
14F6:  MOVFF  03,42B
14FA:  MOVFF  03,42F
14FE:  MOVFF  02,42E
1502:  MOVFF  01,42D
1506:  MOVFF  00,42C
150A:  RCALL  1190
150C:  MOVFF  03,485
1510:  MOVFF  02,484
1514:  MOVFF  01,483
1518:  MOVFF  00,482
151C:  CALL   0A0C
1520:  MOVFF  01,428
1524:  MOVFF  425,447
1528:  MOVFF  01,448
152C:  MOVLW  01
152E:  MOVLB  4
1530:  MOVWF  x49
1532:  MOVLB  0
1534:  RCALL  11AA
....................       i++; 
1536:  MOVLB  4
1538:  INCF   x1B,F
153A:  BTFSC  FD8.2
153C:  INCF   x1C,F
....................    } 
153E:  BRA    124E
.................... } 
1540:  MOVLB  0
1542:  GOTO   2E06 (RETURN)
.................... void circuloMenor(float aC, float bC, float r){ 
1546:  MOVLB  4
1548:  CLRF   x1C
154A:  CLRF   x1B
....................    int16 i = 0; 
....................    float y, x; 
....................    while(i <= 360){ 
154C:  MOVF   x1C,W
154E:  SUBLW  01
1550:  BTFSS  FD8.0
1552:  BRA    1842
1554:  BNZ   155E
1556:  MOVF   x1B,W
1558:  SUBLW  68
155A:  BTFSS  FD8.0
155C:  BRA    1842
....................       y = (sin(i*pi/180)*r)+bC; 
155E:  MOVFF  41C,487
1562:  MOVFF  41B,486
1566:  MOVLB  0
1568:  CALL   0490
156C:  MOVFF  03,489
1570:  MOVFF  02,488
1574:  MOVFF  01,487
1578:  MOVFF  00,486
157C:  MOVLW  DB
157E:  MOVLB  4
1580:  MOVWF  x8D
1582:  MOVLW  0F
1584:  MOVWF  x8C
1586:  MOVLW  49
1588:  MOVWF  x8B
158A:  MOVLW  80
158C:  MOVWF  x8A
158E:  MOVLB  0
1590:  CALL   04C6
1594:  MOVFF  00,425
1598:  MOVFF  01,426
159C:  MOVFF  02,427
15A0:  MOVFF  03,428
15A4:  MOVFF  03,44F
15A8:  MOVFF  02,44E
15AC:  MOVFF  01,44D
15B0:  MOVFF  00,44C
15B4:  MOVLB  4
15B6:  CLRF   x53
15B8:  CLRF   x52
15BA:  MOVLW  34
15BC:  MOVWF  x51
15BE:  MOVLW  86
15C0:  MOVWF  x50
15C2:  MOVLB  0
15C4:  CALL   05BC
15C8:  MOVFF  00,425
15CC:  MOVFF  01,426
15D0:  MOVFF  02,427
15D4:  MOVFF  03,428
15D8:  MOVFF  03,44F
15DC:  MOVFF  02,44E
15E0:  MOVFF  01,44D
15E4:  MOVFF  00,44C
15E8:  CALL   0DDE
15EC:  MOVFF  00,425
15F0:  MOVFF  01,426
15F4:  MOVFF  02,427
15F8:  MOVFF  03,428
15FC:  MOVFF  03,489
1600:  MOVFF  02,488
1604:  MOVFF  01,487
1608:  MOVFF  00,486
160C:  MOVFF  41A,48D
1610:  MOVFF  419,48C
1614:  MOVFF  418,48B
1618:  MOVFF  417,48A
161C:  CALL   04C6
1620:  MOVFF  00,425
1624:  MOVFF  01,426
1628:  MOVFF  02,427
162C:  MOVFF  03,428
1630:  MOVFF  FEA,42A
1634:  MOVFF  FE9,429
1638:  BCF    FD8.1
163A:  MOVFF  03,489
163E:  MOVFF  02,488
1642:  MOVFF  01,487
1646:  MOVFF  00,486
164A:  MOVFF  416,48D
164E:  MOVFF  415,48C
1652:  MOVFF  414,48B
1656:  MOVFF  413,48A
165A:  CALL   071A
165E:  MOVFF  42A,FEA
1662:  MOVFF  429,FE9
1666:  MOVFF  03,420
166A:  MOVFF  02,41F
166E:  MOVFF  01,41E
1672:  MOVFF  00,41D
....................       x = (cos(i*pi/180)*r)+aC;       
1676:  MOVFF  41C,487
167A:  MOVFF  41B,486
167E:  CALL   0490
1682:  MOVFF  03,489
1686:  MOVFF  02,488
168A:  MOVFF  01,487
168E:  MOVFF  00,486
1692:  MOVLW  DB
1694:  MOVLB  4
1696:  MOVWF  x8D
1698:  MOVLW  0F
169A:  MOVWF  x8C
169C:  MOVLW  49
169E:  MOVWF  x8B
16A0:  MOVLW  80
16A2:  MOVWF  x8A
16A4:  MOVLB  0
16A6:  CALL   04C6
16AA:  MOVFF  00,425
16AE:  MOVFF  01,426
16B2:  MOVFF  02,427
16B6:  MOVFF  03,428
16BA:  MOVFF  03,44F
16BE:  MOVFF  02,44E
16C2:  MOVFF  01,44D
16C6:  MOVFF  00,44C
16CA:  MOVLB  4
16CC:  CLRF   x53
16CE:  CLRF   x52
16D0:  MOVLW  34
16D2:  MOVWF  x51
16D4:  MOVLW  86
16D6:  MOVWF  x50
16D8:  MOVLB  0
16DA:  CALL   05BC
16DE:  MOVFF  00,425
16E2:  MOVFF  01,426
16E6:  MOVFF  02,427
16EA:  MOVFF  03,428
16EE:  MOVFF  03,457
16F2:  MOVFF  02,456
16F6:  MOVFF  01,455
16FA:  MOVFF  00,454
16FE:  CALL   0A48
1702:  MOVFF  00,425
1706:  MOVFF  01,426
170A:  MOVFF  02,427
170E:  MOVFF  03,428
1712:  MOVFF  03,489
1716:  MOVFF  02,488
171A:  MOVFF  01,487
171E:  MOVFF  00,486
1722:  MOVFF  41A,48D
1726:  MOVFF  419,48C
172A:  MOVFF  418,48B
172E:  MOVFF  417,48A
1732:  CALL   04C6
1736:  MOVFF  00,425
173A:  MOVFF  01,426
173E:  MOVFF  02,427
1742:  MOVFF  03,428
1746:  MOVFF  FEA,42A
174A:  MOVFF  FE9,429
174E:  BCF    FD8.1
1750:  MOVFF  03,489
1754:  MOVFF  02,488
1758:  MOVFF  01,487
175C:  MOVFF  00,486
1760:  MOVFF  412,48D
1764:  MOVFF  411,48C
1768:  MOVFF  410,48B
176C:  MOVFF  40F,48A
1770:  CALL   071A
1774:  MOVFF  42A,FEA
1778:  MOVFF  429,FE9
177C:  MOVFF  03,424
1780:  MOVFF  02,423
1784:  MOVFF  01,422
1788:  MOVFF  00,421
....................       PE12864_Putpixel(floor(x), floor(64-y), ON); 
178C:  MOVFF  424,42F
1790:  MOVFF  423,42E
1794:  MOVFF  422,42D
1798:  MOVFF  421,42C
179C:  RCALL  1190
179E:  MOVFF  03,485
17A2:  MOVFF  02,484
17A6:  MOVFF  01,483
17AA:  MOVFF  00,482
17AE:  CALL   0A0C
17B2:  MOVFF  01,425
17B6:  MOVFF  FEA,427
17BA:  MOVFF  FE9,426
17BE:  BSF    FD8.1
17C0:  MOVLB  4
17C2:  CLRF   x89
17C4:  CLRF   x88
17C6:  CLRF   x87
17C8:  MOVLW  85
17CA:  MOVWF  x86
17CC:  MOVFF  420,48D
17D0:  MOVFF  41F,48C
17D4:  MOVFF  41E,48B
17D8:  MOVFF  41D,48A
17DC:  MOVLB  0
17DE:  CALL   071A
17E2:  MOVFF  427,FEA
17E6:  MOVFF  426,FE9
17EA:  MOVFF  00,428
17EE:  MOVFF  01,429
17F2:  MOVFF  02,42A
17F6:  MOVFF  03,42B
17FA:  MOVFF  03,42F
17FE:  MOVFF  02,42E
1802:  MOVFF  01,42D
1806:  MOVFF  00,42C
180A:  RCALL  1190
180C:  MOVFF  03,485
1810:  MOVFF  02,484
1814:  MOVFF  01,483
1818:  MOVFF  00,482
181C:  CALL   0A0C
1820:  MOVFF  01,428
1824:  MOVFF  425,447
1828:  MOVFF  01,448
182C:  MOVLW  01
182E:  MOVLB  4
1830:  MOVWF  x49
1832:  MOVLB  0
1834:  RCALL  11AA
....................       i+=6; 
1836:  MOVLW  06
1838:  MOVLB  4
183A:  ADDWF  x1B,F
183C:  MOVLW  00
183E:  ADDWFC x1C,F
....................    } 
1840:  BRA    154C
.................... } 
1842:  MOVLB  0
1844:  GOTO   2E2E (RETURN)
.................... void circuloPonteiro(float aC, float bC, float r){ 
*
2212:  MOVLB  4
2214:  CLRF   x1C
2216:  CLRF   x1B
2218:  CLRF   x1E
221A:  CLRF   x1D
221C:  MOVLW  0F
221E:  MOVWF  x1F
2220:  MOVLW  29
2222:  MOVWF  x20
2224:  MOVLW  0F
2226:  MOVWF  x21
2228:  CLRF   x22
....................    int16 i = 0, mS = 0; 
....................   // char chr[14]; 
....................    int H = 15, M = 41, S = 15, test = 0; 
....................    float y, x; 
....................    while(i <= 360){ 
222A:  MOVF   x1C,W
222C:  SUBLW  01
222E:  BTFSS  FD8.0
2230:  GOTO   2DDC
2234:  BNZ   2240
2236:  MOVF   x1B,W
2238:  SUBLW  68
223A:  BTFSS  FD8.0
223C:  GOTO   2DDC
....................       y = (sin(i*pi/180)*r)+bC; 
2240:  MOVFF  41C,487
2244:  MOVFF  41B,486
2248:  MOVLB  0
224A:  CALL   0490
224E:  MOVFF  03,489
2252:  MOVFF  02,488
2256:  MOVFF  01,487
225A:  MOVFF  00,486
225E:  MOVLW  DB
2260:  MOVLB  4
2262:  MOVWF  x8D
2264:  MOVLW  0F
2266:  MOVWF  x8C
2268:  MOVLW  49
226A:  MOVWF  x8B
226C:  MOVLW  80
226E:  MOVWF  x8A
2270:  MOVLB  0
2272:  CALL   04C6
2276:  MOVFF  00,42B
227A:  MOVFF  01,42C
227E:  MOVFF  02,42D
2282:  MOVFF  03,42E
2286:  MOVFF  03,44F
228A:  MOVFF  02,44E
228E:  MOVFF  01,44D
2292:  MOVFF  00,44C
2296:  MOVLB  4
2298:  CLRF   x53
229A:  CLRF   x52
229C:  MOVLW  34
229E:  MOVWF  x51
22A0:  MOVLW  86
22A2:  MOVWF  x50
22A4:  MOVLB  0
22A6:  CALL   05BC
22AA:  MOVFF  00,42B
22AE:  MOVFF  01,42C
22B2:  MOVFF  02,42D
22B6:  MOVFF  03,42E
22BA:  MOVFF  03,44F
22BE:  MOVFF  02,44E
22C2:  MOVFF  01,44D
22C6:  MOVFF  00,44C
22CA:  CALL   0DDE
22CE:  MOVFF  00,42B
22D2:  MOVFF  01,42C
22D6:  MOVFF  02,42D
22DA:  MOVFF  03,42E
22DE:  MOVFF  03,489
22E2:  MOVFF  02,488
22E6:  MOVFF  01,487
22EA:  MOVFF  00,486
22EE:  MOVFF  41A,48D
22F2:  MOVFF  419,48C
22F6:  MOVFF  418,48B
22FA:  MOVFF  417,48A
22FE:  CALL   04C6
2302:  MOVFF  00,42B
2306:  MOVFF  01,42C
230A:  MOVFF  02,42D
230E:  MOVFF  03,42E
2312:  MOVFF  FEA,430
2316:  MOVFF  FE9,42F
231A:  BCF    FD8.1
231C:  MOVFF  03,489
2320:  MOVFF  02,488
2324:  MOVFF  01,487
2328:  MOVFF  00,486
232C:  MOVFF  416,48D
2330:  MOVFF  415,48C
2334:  MOVFF  414,48B
2338:  MOVFF  413,48A
233C:  CALL   071A
2340:  MOVFF  430,FEA
2344:  MOVFF  42F,FE9
2348:  MOVFF  03,426
234C:  MOVFF  02,425
2350:  MOVFF  01,424
2354:  MOVFF  00,423
....................       x = (cos(i*pi/180)*r)+aC; 
2358:  MOVFF  41C,487
235C:  MOVFF  41B,486
2360:  CALL   0490
2364:  MOVFF  03,489
2368:  MOVFF  02,488
236C:  MOVFF  01,487
2370:  MOVFF  00,486
2374:  MOVLW  DB
2376:  MOVLB  4
2378:  MOVWF  x8D
237A:  MOVLW  0F
237C:  MOVWF  x8C
237E:  MOVLW  49
2380:  MOVWF  x8B
2382:  MOVLW  80
2384:  MOVWF  x8A
2386:  MOVLB  0
2388:  CALL   04C6
238C:  MOVFF  00,42B
2390:  MOVFF  01,42C
2394:  MOVFF  02,42D
2398:  MOVFF  03,42E
239C:  MOVFF  03,44F
23A0:  MOVFF  02,44E
23A4:  MOVFF  01,44D
23A8:  MOVFF  00,44C
23AC:  MOVLB  4
23AE:  CLRF   x53
23B0:  CLRF   x52
23B2:  MOVLW  34
23B4:  MOVWF  x51
23B6:  MOVLW  86
23B8:  MOVWF  x50
23BA:  MOVLB  0
23BC:  CALL   05BC
23C0:  MOVFF  00,42B
23C4:  MOVFF  01,42C
23C8:  MOVFF  02,42D
23CC:  MOVFF  03,42E
23D0:  MOVFF  03,457
23D4:  MOVFF  02,456
23D8:  MOVFF  01,455
23DC:  MOVFF  00,454
23E0:  CALL   0A48
23E4:  MOVFF  00,42B
23E8:  MOVFF  01,42C
23EC:  MOVFF  02,42D
23F0:  MOVFF  03,42E
23F4:  MOVFF  03,489
23F8:  MOVFF  02,488
23FC:  MOVFF  01,487
2400:  MOVFF  00,486
2404:  MOVFF  41A,48D
2408:  MOVFF  419,48C
240C:  MOVFF  418,48B
2410:  MOVFF  417,48A
2414:  CALL   04C6
2418:  MOVFF  00,42B
241C:  MOVFF  01,42C
2420:  MOVFF  02,42D
2424:  MOVFF  03,42E
2428:  MOVFF  FEA,430
242C:  MOVFF  FE9,42F
2430:  BCF    FD8.1
2432:  MOVFF  03,489
2436:  MOVFF  02,488
243A:  MOVFF  01,487
243E:  MOVFF  00,486
2442:  MOVFF  412,48D
2446:  MOVFF  411,48C
244A:  MOVFF  410,48B
244E:  MOVFF  40F,48A
2452:  CALL   071A
2456:  MOVFF  430,FEA
245A:  MOVFF  42F,FE9
245E:  MOVFF  03,42A
2462:  MOVFF  02,429
2466:  MOVFF  01,428
246A:  MOVFF  00,427
....................       circuloNumerico(62, 29, 26); 
246E:  MOVLB  4
2470:  CLRF   x2E
2472:  CLRF   x2D
2474:  MOVLW  78
2476:  MOVWF  x2C
2478:  MOVLW  84
247A:  MOVWF  x2B
247C:  CLRF   x32
247E:  CLRF   x31
2480:  MOVLW  68
2482:  MOVWF  x30
2484:  MOVLW  83
2486:  MOVWF  x2F
2488:  CLRF   x36
248A:  CLRF   x35
248C:  MOVLW  50
248E:  MOVWF  x34
2490:  MOVLW  83
2492:  MOVWF  x33
2494:  MOVLB  0
2496:  CALL   1BC2
....................       PE12864_line(aC, bC, (cos(0*pi/180)*(r-11))+aC, (sin(0*pi/180)*(r-11))+bC, ON);  // hora 
249A:  MOVFF  412,485
249E:  MOVFF  411,484
24A2:  MOVFF  410,483
24A6:  MOVFF  40F,482
24AA:  CALL   0A0C
24AE:  MOVFF  01,42B
24B2:  MOVFF  416,485
24B6:  MOVFF  415,484
24BA:  MOVFF  414,483
24BE:  MOVFF  413,482
24C2:  CALL   0A0C
24C6:  MOVFF  01,42C
24CA:  MOVLB  4
24CC:  CLRF   x57
24CE:  CLRF   x56
24D0:  CLRF   x55
24D2:  CLRF   x54
24D4:  MOVLB  0
24D6:  CALL   0A48
24DA:  MOVFF  00,42D
24DE:  MOVFF  01,42E
24E2:  MOVFF  02,42F
24E6:  MOVFF  03,430
24EA:  MOVFF  FEA,432
24EE:  MOVFF  FE9,431
24F2:  BSF    FD8.1
24F4:  MOVFF  41A,489
24F8:  MOVFF  419,488
24FC:  MOVFF  418,487
2500:  MOVFF  417,486
2504:  MOVLB  4
2506:  CLRF   x8D
2508:  CLRF   x8C
250A:  MOVLW  30
250C:  MOVWF  x8B
250E:  MOVLW  82
2510:  MOVWF  x8A
2512:  MOVLB  0
2514:  CALL   071A
2518:  MOVFF  432,FEA
251C:  MOVFF  431,FE9
2520:  MOVFF  430,489
2524:  MOVFF  42F,488
2528:  MOVFF  42E,487
252C:  MOVFF  42D,486
2530:  MOVFF  03,48D
2534:  MOVFF  02,48C
2538:  MOVFF  01,48B
253C:  MOVFF  00,48A
2540:  CALL   04C6
2544:  MOVFF  00,42D
2548:  MOVFF  01,42E
254C:  MOVFF  02,42F
2550:  MOVFF  03,430
2554:  MOVFF  FEA,434
2558:  MOVFF  FE9,433
255C:  BCF    FD8.1
255E:  MOVFF  03,489
2562:  MOVFF  02,488
2566:  MOVFF  01,487
256A:  MOVFF  00,486
256E:  MOVFF  412,48D
2572:  MOVFF  411,48C
2576:  MOVFF  410,48B
257A:  MOVFF  40F,48A
257E:  CALL   071A
2582:  MOVFF  434,FEA
2586:  MOVFF  433,FE9
258A:  MOVFF  03,485
258E:  MOVFF  02,484
2592:  MOVFF  01,483
2596:  MOVFF  00,482
259A:  CALL   0A0C
259E:  MOVFF  01,42D
25A2:  MOVLB  4
25A4:  CLRF   x4F
25A6:  CLRF   x4E
25A8:  CLRF   x4D
25AA:  CLRF   x4C
25AC:  MOVLB  0
25AE:  CALL   0DDE
25B2:  MOVFF  00,42E
25B6:  MOVFF  01,42F
25BA:  MOVFF  02,430
25BE:  MOVFF  03,431
25C2:  MOVFF  FEA,436
25C6:  MOVFF  FE9,435
25CA:  BSF    FD8.1
25CC:  MOVFF  41A,489
25D0:  MOVFF  419,488
25D4:  MOVFF  418,487
25D8:  MOVFF  417,486
25DC:  MOVLB  4
25DE:  CLRF   x8D
25E0:  CLRF   x8C
25E2:  MOVLW  30
25E4:  MOVWF  x8B
25E6:  MOVLW  82
25E8:  MOVWF  x8A
25EA:  MOVLB  0
25EC:  CALL   071A
25F0:  MOVFF  436,FEA
25F4:  MOVFF  435,FE9
25F8:  MOVFF  431,489
25FC:  MOVFF  430,488
2600:  MOVFF  42F,487
2604:  MOVFF  42E,486
2608:  MOVFF  03,48D
260C:  MOVFF  02,48C
2610:  MOVFF  01,48B
2614:  MOVFF  00,48A
2618:  CALL   04C6
261C:  MOVFF  00,42E
2620:  MOVFF  01,42F
2624:  MOVFF  02,430
2628:  MOVFF  03,431
262C:  MOVFF  FEA,438
2630:  MOVFF  FE9,437
2634:  BCF    FD8.1
2636:  MOVFF  03,489
263A:  MOVFF  02,488
263E:  MOVFF  01,487
2642:  MOVFF  00,486
2646:  MOVFF  416,48D
264A:  MOVFF  415,48C
264E:  MOVFF  414,48B
2652:  MOVFF  413,48A
2656:  CALL   071A
265A:  MOVFF  438,FEA
265E:  MOVFF  437,FE9
2662:  MOVFF  03,485
2666:  MOVFF  02,484
266A:  MOVFF  01,483
266E:  MOVFF  00,482
2672:  CALL   0A0C
2676:  MOVFF  01,42E
267A:  MOVFF  42B,439
267E:  MOVFF  42C,43A
2682:  MOVFF  42D,43B
2686:  MOVFF  01,43C
268A:  MOVLW  01
268C:  MOVLB  4
268E:  MOVWF  x3D
2690:  MOVLB  0
2692:  RCALL  2066
....................       PE12864_line(aC, bC, (cos((156+test)*pi/180)*(r-7))+aC, (sin((156+test)*pi/180)*(r-7))+bC, ON); // minuto      
2694:  MOVFF  412,485
2698:  MOVFF  411,484
269C:  MOVFF  410,483
26A0:  MOVFF  40F,482
26A4:  CALL   0A0C
26A8:  MOVFF  01,42B
26AC:  MOVFF  416,485
26B0:  MOVFF  415,484
26B4:  MOVFF  414,483
26B8:  MOVFF  413,482
26BC:  CALL   0A0C
26C0:  MOVFF  01,42C
26C4:  MOVLW  9C
26C6:  MOVLB  4
26C8:  ADDWF  x22,W
26CA:  CLRF   x87
26CC:  MOVWF  x86
26CE:  MOVLB  0
26D0:  CALL   0490
26D4:  MOVFF  03,489
26D8:  MOVFF  02,488
26DC:  MOVFF  01,487
26E0:  MOVFF  00,486
26E4:  MOVLW  DB
26E6:  MOVLB  4
26E8:  MOVWF  x8D
26EA:  MOVLW  0F
26EC:  MOVWF  x8C
26EE:  MOVLW  49
26F0:  MOVWF  x8B
26F2:  MOVLW  80
26F4:  MOVWF  x8A
26F6:  MOVLB  0
26F8:  CALL   04C6
26FC:  MOVFF  00,42D
2700:  MOVFF  01,42E
2704:  MOVFF  02,42F
2708:  MOVFF  03,430
270C:  MOVFF  03,44F
2710:  MOVFF  02,44E
2714:  MOVFF  01,44D
2718:  MOVFF  00,44C
271C:  MOVLB  4
271E:  CLRF   x53
2720:  CLRF   x52
2722:  MOVLW  34
2724:  MOVWF  x51
2726:  MOVLW  86
2728:  MOVWF  x50
272A:  MOVLB  0
272C:  CALL   05BC
2730:  MOVFF  00,42D
2734:  MOVFF  01,42E
2738:  MOVFF  02,42F
273C:  MOVFF  03,430
2740:  MOVFF  03,457
2744:  MOVFF  02,456
2748:  MOVFF  01,455
274C:  MOVFF  00,454
2750:  CALL   0A48
2754:  MOVFF  00,42D
2758:  MOVFF  01,42E
275C:  MOVFF  02,42F
2760:  MOVFF  03,430
2764:  MOVFF  FEA,432
2768:  MOVFF  FE9,431
276C:  BSF    FD8.1
276E:  MOVFF  41A,489
2772:  MOVFF  419,488
2776:  MOVFF  418,487
277A:  MOVFF  417,486
277E:  MOVLB  4
2780:  CLRF   x8D
2782:  CLRF   x8C
2784:  MOVLW  60
2786:  MOVWF  x8B
2788:  MOVLW  81
278A:  MOVWF  x8A
278C:  MOVLB  0
278E:  CALL   071A
2792:  MOVFF  432,FEA
2796:  MOVFF  431,FE9
279A:  MOVFF  430,489
279E:  MOVFF  42F,488
27A2:  MOVFF  42E,487
27A6:  MOVFF  42D,486
27AA:  MOVFF  03,48D
27AE:  MOVFF  02,48C
27B2:  MOVFF  01,48B
27B6:  MOVFF  00,48A
27BA:  CALL   04C6
27BE:  MOVFF  00,42D
27C2:  MOVFF  01,42E
27C6:  MOVFF  02,42F
27CA:  MOVFF  03,430
27CE:  MOVFF  FEA,434
27D2:  MOVFF  FE9,433
27D6:  BCF    FD8.1
27D8:  MOVFF  03,489
27DC:  MOVFF  02,488
27E0:  MOVFF  01,487
27E4:  MOVFF  00,486
27E8:  MOVFF  412,48D
27EC:  MOVFF  411,48C
27F0:  MOVFF  410,48B
27F4:  MOVFF  40F,48A
27F8:  CALL   071A
27FC:  MOVFF  434,FEA
2800:  MOVFF  433,FE9
2804:  MOVFF  03,485
2808:  MOVFF  02,484
280C:  MOVFF  01,483
2810:  MOVFF  00,482
2814:  CALL   0A0C
2818:  MOVFF  01,42D
281C:  MOVLW  9C
281E:  MOVLB  4
2820:  ADDWF  x22,W
2822:  CLRF   x87
2824:  MOVWF  x86
2826:  MOVLB  0
2828:  CALL   0490
282C:  MOVFF  03,489
2830:  MOVFF  02,488
2834:  MOVFF  01,487
2838:  MOVFF  00,486
283C:  MOVLW  DB
283E:  MOVLB  4
2840:  MOVWF  x8D
2842:  MOVLW  0F
2844:  MOVWF  x8C
2846:  MOVLW  49
2848:  MOVWF  x8B
284A:  MOVLW  80
284C:  MOVWF  x8A
284E:  MOVLB  0
2850:  CALL   04C6
2854:  MOVFF  00,42E
2858:  MOVFF  01,42F
285C:  MOVFF  02,430
2860:  MOVFF  03,431
2864:  MOVFF  03,44F
2868:  MOVFF  02,44E
286C:  MOVFF  01,44D
2870:  MOVFF  00,44C
2874:  MOVLB  4
2876:  CLRF   x53
2878:  CLRF   x52
287A:  MOVLW  34
287C:  MOVWF  x51
287E:  MOVLW  86
2880:  MOVWF  x50
2882:  MOVLB  0
2884:  CALL   05BC
2888:  MOVFF  00,42E
288C:  MOVFF  01,42F
2890:  MOVFF  02,430
2894:  MOVFF  03,431
2898:  MOVFF  03,44F
289C:  MOVFF  02,44E
28A0:  MOVFF  01,44D
28A4:  MOVFF  00,44C
28A8:  CALL   0DDE
28AC:  MOVFF  00,42E
28B0:  MOVFF  01,42F
28B4:  MOVFF  02,430
28B8:  MOVFF  03,431
28BC:  MOVFF  FEA,436
28C0:  MOVFF  FE9,435
28C4:  BSF    FD8.1
28C6:  MOVFF  41A,489
28CA:  MOVFF  419,488
28CE:  MOVFF  418,487
28D2:  MOVFF  417,486
28D6:  MOVLB  4
28D8:  CLRF   x8D
28DA:  CLRF   x8C
28DC:  MOVLW  60
28DE:  MOVWF  x8B
28E0:  MOVLW  81
28E2:  MOVWF  x8A
28E4:  MOVLB  0
28E6:  CALL   071A
28EA:  MOVFF  436,FEA
28EE:  MOVFF  435,FE9
28F2:  MOVFF  431,489
28F6:  MOVFF  430,488
28FA:  MOVFF  42F,487
28FE:  MOVFF  42E,486
2902:  MOVFF  03,48D
2906:  MOVFF  02,48C
290A:  MOVFF  01,48B
290E:  MOVFF  00,48A
2912:  CALL   04C6
2916:  MOVFF  00,42E
291A:  MOVFF  01,42F
291E:  MOVFF  02,430
2922:  MOVFF  03,431
2926:  MOVFF  FEA,438
292A:  MOVFF  FE9,437
292E:  BCF    FD8.1
2930:  MOVFF  03,489
2934:  MOVFF  02,488
2938:  MOVFF  01,487
293C:  MOVFF  00,486
2940:  MOVFF  416,48D
2944:  MOVFF  415,48C
2948:  MOVFF  414,48B
294C:  MOVFF  413,48A
2950:  CALL   071A
2954:  MOVFF  438,FEA
2958:  MOVFF  437,FE9
295C:  MOVFF  03,485
2960:  MOVFF  02,484
2964:  MOVFF  01,483
2968:  MOVFF  00,482
296C:  CALL   0A0C
2970:  MOVFF  01,42E
2974:  MOVFF  42B,439
2978:  MOVFF  42C,43A
297C:  MOVFF  42D,43B
2980:  MOVFF  01,43C
2984:  MOVLW  01
2986:  MOVLB  4
2988:  MOVWF  x3D
298A:  MOVLB  0
298C:  CALL   2066
....................       PE12864_line(aC, bC, x, y, ON); 
2990:  MOVFF  412,485
2994:  MOVFF  411,484
2998:  MOVFF  410,483
299C:  MOVFF  40F,482
29A0:  CALL   0A0C
29A4:  MOVFF  01,42B
29A8:  MOVFF  416,485
29AC:  MOVFF  415,484
29B0:  MOVFF  414,483
29B4:  MOVFF  413,482
29B8:  CALL   0A0C
29BC:  MOVFF  01,42C
29C0:  MOVFF  42A,485
29C4:  MOVFF  429,484
29C8:  MOVFF  428,483
29CC:  MOVFF  427,482
29D0:  CALL   0A0C
29D4:  MOVFF  01,42D
29D8:  MOVFF  426,485
29DC:  MOVFF  425,484
29E0:  MOVFF  424,483
29E4:  MOVFF  423,482
29E8:  CALL   0A0C
29EC:  MOVFF  01,42E
29F0:  MOVFF  42B,439
29F4:  MOVFF  42C,43A
29F8:  MOVFF  42D,43B
29FC:  MOVFF  01,43C
2A00:  MOVLW  01
2A02:  MOVLB  4
2A04:  MOVWF  x3D
2A06:  MOVLB  0
2A08:  CALL   2066
....................       mS = 0; 
2A0C:  MOVLB  4
2A0E:  CLRF   x1E
2A10:  CLRF   x1D
....................       while(mS < 1000){ 
2A12:  MOVF   x1E,W
2A14:  SUBLW  03
2A16:  BNC   2A42
2A18:  BNZ   2A20
2A1A:  MOVF   x1D,W
2A1C:  SUBLW  E7
2A1E:  BNC   2A42
....................          /*sprintf(chr,"%u:%u:%u %lu", H, M, S, mS); 
....................          PE12864_TextXy(3,5,chr);  */  
....................          PE12864_Gotoxy(0,0); 
2A20:  CLRF   x54
2A22:  CLRF   x55
2A24:  MOVLB  0
2A26:  CALL   0298
....................          /*if(S > 9) 
....................             printf(PE12864_Printchar,"%u:%u:%u", H, M, S); 
....................          else 
....................             printf(PE12864_Printchar,"%u:%u:0%u", H, M, S);*/ 
....................          mS+=1; 
2A2A:  MOVLW  01
2A2C:  MOVLB  4
2A2E:  ADDWF  x1D,F
2A30:  MOVLW  00
2A32:  ADDWFC x1E,F
....................          delay_ms(1); 
2A34:  MOVLW  01
2A36:  MOVWF  x2B
2A38:  MOVLB  0
2A3A:  CALL   0200
....................       } 
2A3E:  MOVLB  4
2A40:  BRA    2A12
....................       S++; 
2A42:  INCF   x21,F
....................       if(S>59){ 
2A44:  MOVF   x21,W
2A46:  SUBLW  3B
2A48:  BTFSC  FD8.0
2A4A:  BRA    2D52
....................          S=0; 
2A4C:  CLRF   x21
....................          M++; 
2A4E:  INCF   x20,F
....................          PE12864_line(aC, bC, (cos((156+test)*pi/180)*(r-7))+aC, (sin((156+test)*pi/180)*(r-7))+bC, OFF); // minuto               
2A50:  MOVFF  412,485
2A54:  MOVFF  411,484
2A58:  MOVFF  410,483
2A5C:  MOVFF  40F,482
2A60:  MOVLB  0
2A62:  CALL   0A0C
2A66:  MOVFF  01,42B
2A6A:  MOVFF  416,485
2A6E:  MOVFF  415,484
2A72:  MOVFF  414,483
2A76:  MOVFF  413,482
2A7A:  CALL   0A0C
2A7E:  MOVFF  01,42C
2A82:  MOVLW  9C
2A84:  MOVLB  4
2A86:  ADDWF  x22,W
2A88:  CLRF   x87
2A8A:  MOVWF  x86
2A8C:  MOVLB  0
2A8E:  CALL   0490
2A92:  MOVFF  03,489
2A96:  MOVFF  02,488
2A9A:  MOVFF  01,487
2A9E:  MOVFF  00,486
2AA2:  MOVLW  DB
2AA4:  MOVLB  4
2AA6:  MOVWF  x8D
2AA8:  MOVLW  0F
2AAA:  MOVWF  x8C
2AAC:  MOVLW  49
2AAE:  MOVWF  x8B
2AB0:  MOVLW  80
2AB2:  MOVWF  x8A
2AB4:  MOVLB  0
2AB6:  CALL   04C6
2ABA:  MOVFF  00,42D
2ABE:  MOVFF  01,42E
2AC2:  MOVFF  02,42F
2AC6:  MOVFF  03,430
2ACA:  MOVFF  03,44F
2ACE:  MOVFF  02,44E
2AD2:  MOVFF  01,44D
2AD6:  MOVFF  00,44C
2ADA:  MOVLB  4
2ADC:  CLRF   x53
2ADE:  CLRF   x52
2AE0:  MOVLW  34
2AE2:  MOVWF  x51
2AE4:  MOVLW  86
2AE6:  MOVWF  x50
2AE8:  MOVLB  0
2AEA:  CALL   05BC
2AEE:  MOVFF  00,42D
2AF2:  MOVFF  01,42E
2AF6:  MOVFF  02,42F
2AFA:  MOVFF  03,430
2AFE:  MOVFF  03,457
2B02:  MOVFF  02,456
2B06:  MOVFF  01,455
2B0A:  MOVFF  00,454
2B0E:  CALL   0A48
2B12:  MOVFF  00,42D
2B16:  MOVFF  01,42E
2B1A:  MOVFF  02,42F
2B1E:  MOVFF  03,430
2B22:  MOVFF  FEA,432
2B26:  MOVFF  FE9,431
2B2A:  BSF    FD8.1
2B2C:  MOVFF  41A,489
2B30:  MOVFF  419,488
2B34:  MOVFF  418,487
2B38:  MOVFF  417,486
2B3C:  MOVLB  4
2B3E:  CLRF   x8D
2B40:  CLRF   x8C
2B42:  MOVLW  60
2B44:  MOVWF  x8B
2B46:  MOVLW  81
2B48:  MOVWF  x8A
2B4A:  MOVLB  0
2B4C:  CALL   071A
2B50:  MOVFF  432,FEA
2B54:  MOVFF  431,FE9
2B58:  MOVFF  430,489
2B5C:  MOVFF  42F,488
2B60:  MOVFF  42E,487
2B64:  MOVFF  42D,486
2B68:  MOVFF  03,48D
2B6C:  MOVFF  02,48C
2B70:  MOVFF  01,48B
2B74:  MOVFF  00,48A
2B78:  CALL   04C6
2B7C:  MOVFF  00,42D
2B80:  MOVFF  01,42E
2B84:  MOVFF  02,42F
2B88:  MOVFF  03,430
2B8C:  MOVFF  FEA,434
2B90:  MOVFF  FE9,433
2B94:  BCF    FD8.1
2B96:  MOVFF  03,489
2B9A:  MOVFF  02,488
2B9E:  MOVFF  01,487
2BA2:  MOVFF  00,486
2BA6:  MOVFF  412,48D
2BAA:  MOVFF  411,48C
2BAE:  MOVFF  410,48B
2BB2:  MOVFF  40F,48A
2BB6:  CALL   071A
2BBA:  MOVFF  434,FEA
2BBE:  MOVFF  433,FE9
2BC2:  MOVFF  03,485
2BC6:  MOVFF  02,484
2BCA:  MOVFF  01,483
2BCE:  MOVFF  00,482
2BD2:  CALL   0A0C
2BD6:  MOVFF  01,42D
2BDA:  MOVLW  9C
2BDC:  MOVLB  4
2BDE:  ADDWF  x22,W
2BE0:  CLRF   x87
2BE2:  MOVWF  x86
2BE4:  MOVLB  0
2BE6:  CALL   0490
2BEA:  MOVFF  03,489
2BEE:  MOVFF  02,488
2BF2:  MOVFF  01,487
2BF6:  MOVFF  00,486
2BFA:  MOVLW  DB
2BFC:  MOVLB  4
2BFE:  MOVWF  x8D
2C00:  MOVLW  0F
2C02:  MOVWF  x8C
2C04:  MOVLW  49
2C06:  MOVWF  x8B
2C08:  MOVLW  80
2C0A:  MOVWF  x8A
2C0C:  MOVLB  0
2C0E:  CALL   04C6
2C12:  MOVFF  00,42E
2C16:  MOVFF  01,42F
2C1A:  MOVFF  02,430
2C1E:  MOVFF  03,431
2C22:  MOVFF  03,44F
2C26:  MOVFF  02,44E
2C2A:  MOVFF  01,44D
2C2E:  MOVFF  00,44C
2C32:  MOVLB  4
2C34:  CLRF   x53
2C36:  CLRF   x52
2C38:  MOVLW  34
2C3A:  MOVWF  x51
2C3C:  MOVLW  86
2C3E:  MOVWF  x50
2C40:  MOVLB  0
2C42:  CALL   05BC
2C46:  MOVFF  00,42E
2C4A:  MOVFF  01,42F
2C4E:  MOVFF  02,430
2C52:  MOVFF  03,431
2C56:  MOVFF  03,44F
2C5A:  MOVFF  02,44E
2C5E:  MOVFF  01,44D
2C62:  MOVFF  00,44C
2C66:  CALL   0DDE
2C6A:  MOVFF  00,42E
2C6E:  MOVFF  01,42F
2C72:  MOVFF  02,430
2C76:  MOVFF  03,431
2C7A:  MOVFF  FEA,436
2C7E:  MOVFF  FE9,435
2C82:  BSF    FD8.1
2C84:  MOVFF  41A,489
2C88:  MOVFF  419,488
2C8C:  MOVFF  418,487
2C90:  MOVFF  417,486
2C94:  MOVLB  4
2C96:  CLRF   x8D
2C98:  CLRF   x8C
2C9A:  MOVLW  60
2C9C:  MOVWF  x8B
2C9E:  MOVLW  81
2CA0:  MOVWF  x8A
2CA2:  MOVLB  0
2CA4:  CALL   071A
2CA8:  MOVFF  436,FEA
2CAC:  MOVFF  435,FE9
2CB0:  MOVFF  431,489
2CB4:  MOVFF  430,488
2CB8:  MOVFF  42F,487
2CBC:  MOVFF  42E,486
2CC0:  MOVFF  03,48D
2CC4:  MOVFF  02,48C
2CC8:  MOVFF  01,48B
2CCC:  MOVFF  00,48A
2CD0:  CALL   04C6
2CD4:  MOVFF  00,42E
2CD8:  MOVFF  01,42F
2CDC:  MOVFF  02,430
2CE0:  MOVFF  03,431
2CE4:  MOVFF  FEA,438
2CE8:  MOVFF  FE9,437
2CEC:  BCF    FD8.1
2CEE:  MOVFF  03,489
2CF2:  MOVFF  02,488
2CF6:  MOVFF  01,487
2CFA:  MOVFF  00,486
2CFE:  MOVFF  416,48D
2D02:  MOVFF  415,48C
2D06:  MOVFF  414,48B
2D0A:  MOVFF  413,48A
2D0E:  CALL   071A
2D12:  MOVFF  438,FEA
2D16:  MOVFF  437,FE9
2D1A:  MOVFF  03,485
2D1E:  MOVFF  02,484
2D22:  MOVFF  01,483
2D26:  MOVFF  00,482
2D2A:  CALL   0A0C
2D2E:  MOVFF  01,42E
2D32:  MOVFF  42B,439
2D36:  MOVFF  42C,43A
2D3A:  MOVFF  42D,43B
2D3E:  MOVFF  01,43C
2D42:  MOVLB  4
2D44:  CLRF   x3D
2D46:  MOVLB  0
2D48:  CALL   2066
....................          test+=6; 
2D4C:  MOVLW  06
2D4E:  MOVLB  4
2D50:  ADDWF  x22,F
....................       } 
....................       //delay_ms(1000); 
....................       PE12864_line(aC, bC, x, y, OFF); 
2D52:  MOVFF  412,485
2D56:  MOVFF  411,484
2D5A:  MOVFF  410,483
2D5E:  MOVFF  40F,482
2D62:  MOVLB  0
2D64:  CALL   0A0C
2D68:  MOVFF  01,42B
2D6C:  MOVFF  416,485
2D70:  MOVFF  415,484
2D74:  MOVFF  414,483
2D78:  MOVFF  413,482
2D7C:  CALL   0A0C
2D80:  MOVFF  01,42C
2D84:  MOVFF  42A,485
2D88:  MOVFF  429,484
2D8C:  MOVFF  428,483
2D90:  MOVFF  427,482
2D94:  CALL   0A0C
2D98:  MOVFF  01,42D
2D9C:  MOVFF  426,485
2DA0:  MOVFF  425,484
2DA4:  MOVFF  424,483
2DA8:  MOVFF  423,482
2DAC:  CALL   0A0C
2DB0:  MOVFF  01,42E
2DB4:  MOVFF  42B,439
2DB8:  MOVFF  42C,43A
2DBC:  MOVFF  42D,43B
2DC0:  MOVFF  01,43C
2DC4:  MOVLB  4
2DC6:  CLRF   x3D
2DC8:  MOVLB  0
2DCA:  CALL   2066
....................       i+=6; 
2DCE:  MOVLW  06
2DD0:  MOVLB  4
2DD2:  ADDWF  x1B,F
2DD4:  MOVLW  00
2DD6:  ADDWFC x1C,F
....................    }    
2DD8:  GOTO   222A
.................... } 
2DDC:  MOVLB  0
2DDE:  GOTO   2E82 (RETURN)
.................... void circuloNumerico(float aC, float bC, float r){ 
*
1BC2:  MOVLB  4
1BC4:  CLRF   x38
1BC6:  CLRF   x37
1BC8:  CLRF   x3A
1BCA:  MOVLW  03
1BCC:  MOVWF  x39
....................    int16 i = 0, val = 3; 
....................    char chr[5]; 
....................    float y, x; 
....................    while(i <= 360){ 
1BCE:  MOVF   x38,W
1BD0:  SUBLW  01
1BD2:  BTFSS  FD8.0
1BD4:  BRA    2014
1BD6:  BNZ   1BE0
1BD8:  MOVF   x37,W
1BDA:  SUBLW  68
1BDC:  BTFSS  FD8.0
1BDE:  BRA    2014
....................       y = (sin(i*pi/180)*r)+bC; 
1BE0:  MOVFF  438,487
1BE4:  MOVFF  437,486
1BE8:  MOVLB  0
1BEA:  CALL   0490
1BEE:  MOVFF  03,489
1BF2:  MOVFF  02,488
1BF6:  MOVFF  01,487
1BFA:  MOVFF  00,486
1BFE:  MOVLW  DB
1C00:  MOVLB  4
1C02:  MOVWF  x8D
1C04:  MOVLW  0F
1C06:  MOVWF  x8C
1C08:  MOVLW  49
1C0A:  MOVWF  x8B
1C0C:  MOVLW  80
1C0E:  MOVWF  x8A
1C10:  MOVLB  0
1C12:  CALL   04C6
1C16:  MOVFF  00,448
1C1A:  MOVFF  01,449
1C1E:  MOVFF  02,44A
1C22:  MOVFF  03,44B
1C26:  MOVFF  03,44F
1C2A:  MOVFF  02,44E
1C2E:  MOVFF  01,44D
1C32:  MOVFF  00,44C
1C36:  MOVLB  4
1C38:  CLRF   x53
1C3A:  CLRF   x52
1C3C:  MOVLW  34
1C3E:  MOVWF  x51
1C40:  MOVLW  86
1C42:  MOVWF  x50
1C44:  MOVLB  0
1C46:  CALL   05BC
1C4A:  MOVFF  00,448
1C4E:  MOVFF  01,449
1C52:  MOVFF  02,44A
1C56:  MOVFF  03,44B
1C5A:  MOVFF  03,44F
1C5E:  MOVFF  02,44E
1C62:  MOVFF  01,44D
1C66:  MOVFF  00,44C
1C6A:  CALL   0DDE
1C6E:  MOVFF  00,448
1C72:  MOVFF  01,449
1C76:  MOVFF  02,44A
1C7A:  MOVFF  03,44B
1C7E:  MOVFF  03,489
1C82:  MOVFF  02,488
1C86:  MOVFF  01,487
1C8A:  MOVFF  00,486
1C8E:  MOVFF  436,48D
1C92:  MOVFF  435,48C
1C96:  MOVFF  434,48B
1C9A:  MOVFF  433,48A
1C9E:  CALL   04C6
1CA2:  MOVFF  00,448
1CA6:  MOVFF  01,449
1CAA:  MOVFF  02,44A
1CAE:  MOVFF  03,44B
1CB2:  MOVFF  FEA,44D
1CB6:  MOVFF  FE9,44C
1CBA:  BCF    FD8.1
1CBC:  MOVFF  03,489
1CC0:  MOVFF  02,488
1CC4:  MOVFF  01,487
1CC8:  MOVFF  00,486
1CCC:  MOVFF  432,48D
1CD0:  MOVFF  431,48C
1CD4:  MOVFF  430,48B
1CD8:  MOVFF  42F,48A
1CDC:  CALL   071A
1CE0:  MOVFF  44D,FEA
1CE4:  MOVFF  44C,FE9
1CE8:  MOVFF  03,443
1CEC:  MOVFF  02,442
1CF0:  MOVFF  01,441
1CF4:  MOVFF  00,440
....................       x = (cos(i*pi/180)*r)+aC;        
1CF8:  MOVFF  438,487
1CFC:  MOVFF  437,486
1D00:  CALL   0490
1D04:  MOVFF  03,489
1D08:  MOVFF  02,488
1D0C:  MOVFF  01,487
1D10:  MOVFF  00,486
1D14:  MOVLW  DB
1D16:  MOVLB  4
1D18:  MOVWF  x8D
1D1A:  MOVLW  0F
1D1C:  MOVWF  x8C
1D1E:  MOVLW  49
1D20:  MOVWF  x8B
1D22:  MOVLW  80
1D24:  MOVWF  x8A
1D26:  MOVLB  0
1D28:  CALL   04C6
1D2C:  MOVFF  00,448
1D30:  MOVFF  01,449
1D34:  MOVFF  02,44A
1D38:  MOVFF  03,44B
1D3C:  MOVFF  03,44F
1D40:  MOVFF  02,44E
1D44:  MOVFF  01,44D
1D48:  MOVFF  00,44C
1D4C:  MOVLB  4
1D4E:  CLRF   x53
1D50:  CLRF   x52
1D52:  MOVLW  34
1D54:  MOVWF  x51
1D56:  MOVLW  86
1D58:  MOVWF  x50
1D5A:  MOVLB  0
1D5C:  CALL   05BC
1D60:  MOVFF  00,448
1D64:  MOVFF  01,449
1D68:  MOVFF  02,44A
1D6C:  MOVFF  03,44B
1D70:  MOVFF  03,457
1D74:  MOVFF  02,456
1D78:  MOVFF  01,455
1D7C:  MOVFF  00,454
1D80:  CALL   0A48
1D84:  MOVFF  00,448
1D88:  MOVFF  01,449
1D8C:  MOVFF  02,44A
1D90:  MOVFF  03,44B
1D94:  MOVFF  03,489
1D98:  MOVFF  02,488
1D9C:  MOVFF  01,487
1DA0:  MOVFF  00,486
1DA4:  MOVFF  436,48D
1DA8:  MOVFF  435,48C
1DAC:  MOVFF  434,48B
1DB0:  MOVFF  433,48A
1DB4:  CALL   04C6
1DB8:  MOVFF  00,448
1DBC:  MOVFF  01,449
1DC0:  MOVFF  02,44A
1DC4:  MOVFF  03,44B
1DC8:  MOVFF  FEA,44D
1DCC:  MOVFF  FE9,44C
1DD0:  BCF    FD8.1
1DD2:  MOVFF  03,489
1DD6:  MOVFF  02,488
1DDA:  MOVFF  01,487
1DDE:  MOVFF  00,486
1DE2:  MOVFF  42E,48D
1DE6:  MOVFF  42D,48C
1DEA:  MOVFF  42C,48B
1DEE:  MOVFF  42B,48A
1DF2:  CALL   071A
1DF6:  MOVFF  44D,FEA
1DFA:  MOVFF  44C,FE9
1DFE:  MOVFF  03,447
1E02:  MOVFF  02,446
1E06:  MOVFF  01,445
1E0A:  MOVFF  00,444
....................       //PE12864_Putpixel(x, y, ON);       
....................       if(!(i%30)){ 
1E0E:  MOVFF  438,449
1E12:  MOVFF  437,448
1E16:  MOVLB  4
1E18:  CLRF   x4B
1E1A:  MOVLW  1E
1E1C:  MOVWF  x4A
1E1E:  MOVLB  0
1E20:  BRA    1848
1E22:  MOVF   00,W
1E24:  IORWF  03,W
1E26:  BTFSS  FD8.2
1E28:  BRA    2008
....................          sprintf(chr,"%lu", val); 
1E2A:  MOVLW  04
1E2C:  MOVLB  4
1E2E:  MOVWF  x0E
1E30:  MOVLW  3B
1E32:  MOVWF  x0D
1E34:  MOVLW  10
1E36:  MOVWF  FE9
1E38:  MOVFF  43A,449
1E3C:  MOVFF  439,448
1E40:  MOVLB  0
1E42:  BRA    18B2
....................          // -- Resolver Bugs :   Inicio  
....................          if(val == 9) 
1E44:  MOVLB  4
1E46:  MOVF   x39,W
1E48:  SUBLW  09
1E4A:  BNZ   1E84
1E4C:  MOVF   x3A,F
1E4E:  BNZ   1E84
....................             y+=1; 
1E50:  BCF    FD8.1
1E52:  MOVFF  443,489
1E56:  MOVFF  442,488
1E5A:  MOVFF  441,487
1E5E:  MOVFF  440,486
1E62:  CLRF   x8D
1E64:  CLRF   x8C
1E66:  CLRF   x8B
1E68:  MOVLW  7F
1E6A:  MOVWF  x8A
1E6C:  MOVLB  0
1E6E:  CALL   071A
1E72:  MOVFF  03,443
1E76:  MOVFF  02,442
1E7A:  MOVFF  01,441
1E7E:  MOVFF  00,440
1E82:  MOVLB  4
....................          if(val == 10){ 
1E84:  MOVF   x39,W
1E86:  SUBLW  0A
1E88:  BNZ   1EF6
1E8A:  MOVF   x3A,F
1E8C:  BNZ   1EF6
....................             y+=2; 
1E8E:  BCF    FD8.1
1E90:  MOVFF  443,489
1E94:  MOVFF  442,488
1E98:  MOVFF  441,487
1E9C:  MOVFF  440,486
1EA0:  CLRF   x8D
1EA2:  CLRF   x8C
1EA4:  CLRF   x8B
1EA6:  MOVLW  80
1EA8:  MOVWF  x8A
1EAA:  MOVLB  0
1EAC:  CALL   071A
1EB0:  MOVFF  03,443
1EB4:  MOVFF  02,442
1EB8:  MOVFF  01,441
1EBC:  MOVFF  00,440
....................             x-=1; 
1EC0:  BSF    FD8.1
1EC2:  MOVFF  447,489
1EC6:  MOVFF  446,488
1ECA:  MOVFF  445,487
1ECE:  MOVFF  444,486
1ED2:  MOVLB  4
1ED4:  CLRF   x8D
1ED6:  CLRF   x8C
1ED8:  CLRF   x8B
1EDA:  MOVLW  7F
1EDC:  MOVWF  x8A
1EDE:  MOVLB  0
1EE0:  CALL   071A
1EE4:  MOVFF  03,447
1EE8:  MOVFF  02,446
1EEC:  MOVFF  01,445
1EF0:  MOVFF  00,444
1EF4:  MOVLB  4
....................          } 
....................          if(val == 11){ 
1EF6:  MOVF   x39,W
1EF8:  SUBLW  0B
1EFA:  BNZ   1F6A
1EFC:  MOVF   x3A,F
1EFE:  BNZ   1F6A
....................             y+=1; 
1F00:  BCF    FD8.1
1F02:  MOVFF  443,489
1F06:  MOVFF  442,488
1F0A:  MOVFF  441,487
1F0E:  MOVFF  440,486
1F12:  CLRF   x8D
1F14:  CLRF   x8C
1F16:  CLRF   x8B
1F18:  MOVLW  7F
1F1A:  MOVWF  x8A
1F1C:  MOVLB  0
1F1E:  CALL   071A
1F22:  MOVFF  03,443
1F26:  MOVFF  02,442
1F2A:  MOVFF  01,441
1F2E:  MOVFF  00,440
....................             x-=3; 
1F32:  BSF    FD8.1
1F34:  MOVFF  447,489
1F38:  MOVFF  446,488
1F3C:  MOVFF  445,487
1F40:  MOVFF  444,486
1F44:  MOVLB  4
1F46:  CLRF   x8D
1F48:  CLRF   x8C
1F4A:  MOVLW  40
1F4C:  MOVWF  x8B
1F4E:  MOVLW  80
1F50:  MOVWF  x8A
1F52:  MOVLB  0
1F54:  CALL   071A
1F58:  MOVFF  03,447
1F5C:  MOVFF  02,446
1F60:  MOVFF  01,445
1F64:  MOVFF  00,444
1F68:  MOVLB  4
....................          } 
....................          if(val == 12) 
1F6A:  MOVF   x39,W
1F6C:  SUBLW  0C
1F6E:  BNZ   1FA8
1F70:  MOVF   x3A,F
1F72:  BNZ   1FA8
....................             x-=3;             
1F74:  BSF    FD8.1
1F76:  MOVFF  447,489
1F7A:  MOVFF  446,488
1F7E:  MOVFF  445,487
1F82:  MOVFF  444,486
1F86:  CLRF   x8D
1F88:  CLRF   x8C
1F8A:  MOVLW  40
1F8C:  MOVWF  x8B
1F8E:  MOVLW  80
1F90:  MOVWF  x8A
1F92:  MOVLB  0
1F94:  CALL   071A
1F98:  MOVFF  03,447
1F9C:  MOVFF  02,446
1FA0:  MOVFF  01,445
1FA4:  MOVFF  00,444
....................          // -- Resolver Bugs :   Fim             
....................          PE12864_TextXy(x,y,chr); 
1FA8:  MOVFF  447,485
1FAC:  MOVFF  446,484
1FB0:  MOVFF  445,483
1FB4:  MOVFF  444,482
1FB8:  MOVLB  0
1FBA:  CALL   0A0C
1FBE:  MOVFF  01,448
1FC2:  MOVFF  443,485
1FC6:  MOVFF  442,484
1FCA:  MOVFF  441,483
1FCE:  MOVFF  440,482
1FD2:  CALL   0A0C
1FD6:  MOVFF  01,449
1FDA:  MOVFF  448,44A
1FDE:  MOVFF  01,44B
1FE2:  MOVLW  04
1FE4:  MOVLB  4
1FE6:  MOVWF  x4D
1FE8:  MOVLW  3B
1FEA:  MOVWF  x4C
1FEC:  MOVLB  0
1FEE:  BRA    19AC
....................          val++; 
1FF0:  MOVLB  4
1FF2:  INCF   x39,F
1FF4:  BTFSC  FD8.2
1FF6:  INCF   x3A,F
....................          if(val > 12)    // 9: 1B 0T || 10: 2B 1T || 11: 1B 1T || 12: 0B 3T 
1FF8:  MOVF   x3A,F
1FFA:  BNZ   2002
1FFC:  MOVF   x39,W
1FFE:  SUBLW  0C
2000:  BC    2008
....................             val = 1; 
2002:  CLRF   x3A
2004:  MOVLW  01
2006:  MOVWF  x39
....................       } 
....................       i+=30; 
2008:  MOVLW  1E
200A:  MOVLB  4
200C:  ADDWF  x37,F
200E:  MOVLW  00
2010:  ADDWFC x38,F
....................    } 
2012:  BRA    1BCE
.................... } 
2014:  MOVLB  0
2016:  RETLW  00
.................... void PE12864_TextXy(int x, int y, char* cvar){ 
*
19AC:  MOVLB  4
19AE:  CLRF   x4F
....................    int i, loop = 0; 
....................    char c1, c2, chr; 
....................    while(loop < strlen(cvar)){  
19B0:  MOVFF  44D,454
19B4:  MOVFF  44C,453
19B8:  MOVLB  0
19BA:  BRA    1970
19BC:  MOVF   01,W
19BE:  MOVLB  4
19C0:  SUBWF  x4F,W
19C2:  BTFSC  FD8.0
19C4:  BRA    1BBC
....................       chr = cvar[loop]; 
19C6:  CLRF   03
19C8:  MOVF   x4F,W
19CA:  ADDWF  x4C,W
19CC:  MOVWF  FE9
19CE:  MOVF   x4D,W
19D0:  ADDWFC 03,W
19D2:  MOVWF  FEA
19D4:  MOVFF  FEF,452
....................       for(i=0;i<5;i++){ 
19D8:  CLRF   x4E
19DA:  MOVF   x4E,W
19DC:  SUBLW  04
19DE:  BTFSS  FD8.0
19E0:  BRA    1BB6
....................          if (chr < 0x53){ 
19E2:  MOVF   x52,W
19E4:  SUBLW  52
19E6:  BNC   1A62
....................             c1 = TEXT[chr-0x20][i] <<(y%8); 
19E8:  MOVLW  20
19EA:  SUBWF  x52,W
19EC:  MULLW  05
19EE:  MOVF   FF3,W
19F0:  CLRF   x54
19F2:  MOVWF  x53
19F4:  CLRF   03
19F6:  MOVF   x4E,W
19F8:  ADDWF  x53,W
19FA:  MOVWF  01
19FC:  MOVF   x54,W
19FE:  ADDWFC 03,F
1A00:  MOVF   01,W
1A02:  MOVLB  0
1A04:  CALL   0004
1A08:  MOVLB  4
1A0A:  MOVWF  x53
1A0C:  MOVF   x4B,W
1A0E:  ANDLW  07
1A10:  MOVWF  01
1A12:  MOVFF  453,450
1A16:  MOVF   01,F
1A18:  BZ    1A22
1A1A:  BCF    FD8.0
1A1C:  RLCF   x50,F
1A1E:  DECFSZ 01,F
1A20:  BRA    1A1A
....................             c2 = TEXT[chr-0x20][i] >>(8-(y%8));                
1A22:  MOVLW  20
1A24:  SUBWF  x52,W
1A26:  MULLW  05
1A28:  MOVF   FF3,W
1A2A:  CLRF   x54
1A2C:  MOVWF  x53
1A2E:  CLRF   03
1A30:  MOVF   x4E,W
1A32:  ADDWF  x53,W
1A34:  MOVWF  01
1A36:  MOVF   x54,W
1A38:  ADDWFC 03,F
1A3A:  MOVF   01,W
1A3C:  MOVLB  0
1A3E:  CALL   0004
1A42:  MOVLB  4
1A44:  MOVWF  x53
1A46:  MOVF   x4B,W
1A48:  ANDLW  07
1A4A:  XORLW  FF
1A4C:  ADDLW  09
1A4E:  MOVWF  01
1A50:  MOVFF  453,451
1A54:  MOVF   01,F
1A56:  BZ    1A60
1A58:  BCF    FD8.0
1A5A:  RRCF   x51,F
1A5C:  DECFSZ 01,F
1A5E:  BRA    1A58
....................          } 
....................          else { 
1A60:  BRA    1ADA
....................             c1 = TEXT2[chr-0x53][i] <<(y%8); 
1A62:  MOVLW  53
1A64:  SUBWF  x52,W
1A66:  MULLW  05
1A68:  MOVF   FF3,W
1A6A:  CLRF   x54
1A6C:  MOVWF  x53
1A6E:  CLRF   03
1A70:  MOVF   x4E,W
1A72:  ADDWF  x53,W
1A74:  MOVWF  01
1A76:  MOVF   x54,W
1A78:  ADDWFC 03,F
1A7A:  MOVF   01,W
1A7C:  MOVLB  0
1A7E:  CALL   0114
1A82:  MOVLB  4
1A84:  MOVWF  x53
1A86:  MOVF   x4B,W
1A88:  ANDLW  07
1A8A:  MOVWF  01
1A8C:  MOVFF  453,450
1A90:  MOVF   01,F
1A92:  BZ    1A9C
1A94:  BCF    FD8.0
1A96:  RLCF   x50,F
1A98:  DECFSZ 01,F
1A9A:  BRA    1A94
....................             c2 = TEXT2[chr-0x53][i] >>(8-(y%8)); 
1A9C:  MOVLW  53
1A9E:  SUBWF  x52,W
1AA0:  MULLW  05
1AA2:  MOVF   FF3,W
1AA4:  CLRF   x54
1AA6:  MOVWF  x53
1AA8:  CLRF   03
1AAA:  MOVF   x4E,W
1AAC:  ADDWF  x53,W
1AAE:  MOVWF  01
1AB0:  MOVF   x54,W
1AB2:  ADDWFC 03,F
1AB4:  MOVF   01,W
1AB6:  MOVLB  0
1AB8:  CALL   0114
1ABC:  MOVLB  4
1ABE:  MOVWF  x53
1AC0:  MOVF   x4B,W
1AC2:  ANDLW  07
1AC4:  XORLW  FF
1AC6:  ADDLW  09
1AC8:  MOVWF  01
1ACA:  MOVFF  453,451
1ACE:  MOVF   01,F
1AD0:  BZ    1ADA
1AD2:  BCF    FD8.0
1AD4:  RRCF   x51,F
1AD6:  DECFSZ 01,F
1AD8:  BRA    1AD2
....................          } 
....................          PE12864_Gotoxy(x,(y/8));       
1ADA:  RRCF   x4B,W
1ADC:  MOVWF  x53
1ADE:  RRCF   x53,F
1AE0:  RRCF   x53,F
1AE2:  MOVLW  1F
1AE4:  ANDWF  x53,F
1AE6:  MOVFF  44A,454
1AEA:  MOVFF  453,455
1AEE:  MOVLB  0
1AF0:  CALL   0298
....................          c1 |= buffer[x][y/8];          
1AF4:  MOVLB  4
1AF6:  CLRF   x55
1AF8:  MOVFF  44A,454
1AFC:  CLRF   x57
1AFE:  MOVLW  08
1B00:  MOVWF  x56
1B02:  MOVLB  0
1B04:  CALL   030C
1B08:  MOVFF  01,453
1B0C:  MOVLB  4
1B0E:  RRCF   x4B,W
1B10:  MOVWF  00
1B12:  RRCF   00,F
1B14:  RRCF   00,F
1B16:  MOVLW  1F
1B18:  ANDWF  00,F
1B1A:  MOVF   00,W
1B1C:  ADDWF  01,W
1B1E:  MOVWF  01
1B20:  MOVLW  00
1B22:  ADDWFC 02,W
1B24:  MOVWF  03
1B26:  MOVF   01,W
1B28:  ADDLW  07
1B2A:  MOVWF  FE9
1B2C:  MOVLW  00
1B2E:  ADDWFC 03,W
1B30:  MOVWF  FEA
1B32:  MOVF   FEF,W
1B34:  IORWF  x50,F
....................          PE12864_Write_data(c1);                
1B36:  MOVFF  450,453
1B3A:  MOVLB  0
1B3C:  CALL   032E
....................          PE12864_Gotoxy(x,(y/8)+1);       
1B40:  MOVLB  4
1B42:  RRCF   x4B,W
1B44:  MOVWF  00
1B46:  RRCF   00,F
1B48:  RRCF   00,F
1B4A:  MOVLW  1F
1B4C:  ANDWF  00,F
1B4E:  MOVF   00,W
1B50:  ADDLW  01
1B52:  MOVWF  x53
1B54:  MOVFF  44A,454
1B58:  MOVWF  x55
1B5A:  MOVLB  0
1B5C:  CALL   0298
....................          c2 |= buffer[x][(y/8)+1]; 
1B60:  MOVLB  4
1B62:  CLRF   x55
1B64:  MOVFF  44A,454
1B68:  CLRF   x57
1B6A:  MOVLW  08
1B6C:  MOVWF  x56
1B6E:  MOVLB  0
1B70:  CALL   030C
1B74:  MOVFF  01,453
1B78:  MOVLB  4
1B7A:  RRCF   x4B,W
1B7C:  MOVWF  00
1B7E:  RRCF   00,F
1B80:  RRCF   00,F
1B82:  MOVLW  1F
1B84:  ANDWF  00,F
1B86:  MOVF   00,W
1B88:  ADDLW  01
1B8A:  ADDWF  01,W
1B8C:  MOVWF  01
1B8E:  MOVLW  00
1B90:  ADDWFC 02,W
1B92:  MOVWF  03
1B94:  MOVF   01,W
1B96:  ADDLW  07
1B98:  MOVWF  FE9
1B9A:  MOVLW  00
1B9C:  ADDWFC 03,W
1B9E:  MOVWF  FEA
1BA0:  MOVF   FEF,W
1BA2:  IORWF  x51,F
....................          PE12864_Write_data(c2); 
1BA4:  MOVFF  451,453
1BA8:  MOVLB  0
1BAA:  CALL   032E
....................          x++; 
1BAE:  MOVLB  4
1BB0:  INCF   x4A,F
....................       } 
1BB2:  INCF   x4E,F
1BB4:  BRA    19DA
....................       x++; 
1BB6:  INCF   x4A,F
....................       loop++; 
1BB8:  INCF   x4F,F
....................    } 
1BBA:  BRA    19B0
.................... } 
1BBC:  MOVLB  0
1BBE:  GOTO   1FF0 (RETURN)
.................... void circuloFechado(float aC, float bC, float r){ 
....................    int16 i = 0; 
....................    float y, x; 
....................    while(i <= 360){ 
....................       y = (sin(i*pi/180)*r)+bC; 
....................       x = (cos(i*pi/180)*r)+aC; 
....................       PE12864_line(aC, bC, x, y, ON);       
....................       i++; 
....................    }    
.................... } 
.................... void relogioAnalogico(){ 
....................    /*circulo(96, 32, 32); 
....................    circuloMenor(96, 32, 30); 
....................    circuloNumerico(94, 29, 26);  
....................    circuloPonteiro(96, 32, 28);*/ 
....................    circulo(64, 32, 32); 
*
2DE2:  MOVLB  4
2DE4:  CLRF   x12
2DE6:  CLRF   x11
2DE8:  CLRF   x10
2DEA:  MOVLW  85
2DEC:  MOVWF  x0F
2DEE:  CLRF   x16
2DF0:  CLRF   x15
2DF2:  CLRF   x14
2DF4:  MOVLW  84
2DF6:  MOVWF  x13
2DF8:  CLRF   x1A
2DFA:  CLRF   x19
2DFC:  CLRF   x18
2DFE:  MOVWF  x17
2E00:  MOVLB  0
2E02:  GOTO   1248
....................    circuloMenor(64, 32, 30); 
2E06:  MOVLB  4
2E08:  CLRF   x12
2E0A:  CLRF   x11
2E0C:  CLRF   x10
2E0E:  MOVLW  85
2E10:  MOVWF  x0F
2E12:  CLRF   x16
2E14:  CLRF   x15
2E16:  CLRF   x14
2E18:  MOVLW  84
2E1A:  MOVWF  x13
2E1C:  CLRF   x1A
2E1E:  CLRF   x19
2E20:  MOVLW  70
2E22:  MOVWF  x18
2E24:  MOVLW  83
2E26:  MOVWF  x17
2E28:  MOVLB  0
2E2A:  GOTO   1546
....................    circuloNumerico(62, 29, 26);  
2E2E:  MOVLB  4
2E30:  CLRF   x2E
2E32:  CLRF   x2D
2E34:  MOVLW  78
2E36:  MOVWF  x2C
2E38:  MOVLW  84
2E3A:  MOVWF  x2B
2E3C:  CLRF   x32
2E3E:  CLRF   x31
2E40:  MOVLW  68
2E42:  MOVWF  x30
2E44:  MOVLW  83
2E46:  MOVWF  x2F
2E48:  CLRF   x36
2E4A:  CLRF   x35
2E4C:  MOVLW  50
2E4E:  MOVWF  x34
2E50:  MOVLW  83
2E52:  MOVWF  x33
2E54:  MOVLB  0
2E56:  CALL   1BC2
....................    circuloPonteiro(64, 32, 28); 
2E5A:  MOVLB  4
2E5C:  CLRF   x12
2E5E:  CLRF   x11
2E60:  CLRF   x10
2E62:  MOVLW  85
2E64:  MOVWF  x0F
2E66:  CLRF   x16
2E68:  CLRF   x15
2E6A:  CLRF   x14
2E6C:  MOVLW  84
2E6E:  MOVWF  x13
2E70:  CLRF   x1A
2E72:  CLRF   x19
2E74:  MOVLW  60
2E76:  MOVWF  x18
2E78:  MOVLW  83
2E7A:  MOVWF  x17
2E7C:  MOVLB  0
2E7E:  GOTO   2212
.................... } 
2E82:  GOTO   2EB2 (RETURN)
.................... void main(void){ 
2E86:  CLRF   FF8
2E88:  BCF    FD0.7
2E8A:  CLRF   FEA
2E8C:  CLRF   FE9
2E8E:  CLRF   04
2E90:  CLRF   05
2E92:  CLRF   06
2E94:  MOVLB  4
2E96:  CLRF   x0E
2E98:  CLRF   x0D
2E9A:  MOVF   FC1,W
2E9C:  ANDLW  C0
2E9E:  IORLW  0F
2EA0:  MOVWF  FC1
2EA2:  MOVLW  07
2EA4:  MOVWF  FB4
2EA6:  CLRF   x07
2EA8:  CLRF   x08
....................    PE12864_InitLcd(); 
2EAA:  MOVLB  0
2EAC:  GOTO   03E8
....................    relogioAnalogico(); 
2EB0:  BRA    2DE2
....................    while(true){} 
2EB2:  BRA    2EB2
.................... } 
2EB4:  SLEEP 

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV20 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICPRT NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
