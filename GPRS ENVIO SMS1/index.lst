CCS PCM C Compiler, Version 4.114, 93480876               04-jun-12 16:07

               Filename: E:\SkyDrive\Eletronica\PROJETOS PIC CCS\GPRS ENVIO SMS1\index.lst

               ROM used: 1122 words (55%)
                         Largest free fragment is 926
               RAM used: 150 (67%) at main() level
                         193 (86%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   226
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   7F,W
0009:  MOVWF  20
000A:  MOVF   0A,W
000B:  MOVWF  27
000C:  CLRF   0A
000D:  SWAPF  20,F
000E:  MOVF   04,W
000F:  MOVWF  22
0010:  MOVF   77,W
0011:  MOVWF  23
0012:  MOVF   78,W
0013:  MOVWF  24
0014:  MOVF   79,W
0015:  MOVWF  25
0016:  MOVF   7A,W
0017:  MOVWF  26
0018:  BCF    03.7
0019:  BCF    03.5
001A:  MOVLW  8C
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  0C.5
001F:  GOTO   0B3
0020:  MOVF   22,W
0021:  MOVWF  04
0022:  MOVF   23,W
0023:  MOVWF  77
0024:  MOVF   24,W
0025:  MOVWF  78
0026:  MOVF   25,W
0027:  MOVWF  79
0028:  MOVF   26,W
0029:  MOVWF  7A
002A:  MOVF   27,W
002B:  MOVWF  0A
002C:  SWAPF  21,W
002D:  MOVWF  03
002E:  SWAPF  7F,F
002F:  SWAPF  7F,W
0030:  RETFIE
.................... /* 
....................    O Codigo abaixo, recebe uma ligação qualquer, desconecta-a e envia uma mensagem pro 85851611 Somente 
....................    Não envia para o numero que ligou. 
.................... */ 
....................  
.................... #include <16F628A.h> 
.................... //////// Standard Header file for the PIC16F628A device //////////////// 
.................... #device PIC16F628A 
.................... #list 
....................  
.................... #use delay(clock=4000000) 
.................... #FUSES NOWDT, NOBROWNOUT, PUT, XT    
....................  
.................... #use rs232(baud=9600, parity=N, xmit=PIN_B2, rcv=PIN_B1, STREAM=gprs)     // GPRS 
.................... //#use rs232(baud=9600, parity=N, xmit=PIN_A0, rcv=PIN_A1, STREAM=serial)   // Ecoar na Serial 
.................... #use rs232(baud=4800, parity=N, xmit=PIN_A0, rcv=PIN_A1, STREAM=serial)   // GPS 
*
0137:  BSF    03.5
0138:  BCF    05.0
0139:  BCF    03.5
013A:  BCF    05.0
013B:  MOVLW  08
013C:  MOVWF  78
013D:  GOTO   13E
013E:  NOP
013F:  BSF    78.7
0140:  GOTO   151
0141:  BCF    78.7
0142:  BSF    03.6
0143:  RRF    23,F
0144:  BCF    03.6
0145:  BTFSC  03.0
0146:  BSF    05.0
0147:  BTFSS  03.0
0148:  BCF    05.0
0149:  BSF    78.6
014A:  GOTO   151
014B:  BCF    78.6
014C:  DECFSZ 78,F
014D:  GOTO   142
014E:  GOTO   14F
014F:  NOP
0150:  BSF    05.0
0151:  MOVLW  3F
0152:  MOVWF  04
0153:  DECFSZ 04,F
0154:  GOTO   153
0155:  NOP
0156:  BTFSC  78.7
0157:  GOTO   141
0158:  BTFSC  78.6
0159:  GOTO   14B
015A:  RETURN
*
01FE:  BSF    03.5
01FF:  BSF    05.1
0200:  BCF    03.5
0201:  BTFSC  05.1
0202:  GOTO   201
0203:  MOVLW  08
0204:  MOVWF  77
0205:  BSF    03.5
0206:  CLRF   6F
0207:  BSF    77.7
0208:  GOTO   219
0209:  BCF    77.7
020A:  GOTO   219
020B:  BCF    03.0
020C:  BCF    03.5
020D:  BTFSC  05.1
020E:  BSF    03.0
020F:  BSF    03.5
0210:  RRF    6F,F
0211:  BSF    77.6
0212:  GOTO   219
0213:  BCF    77.6
0214:  DECFSZ 77,F
0215:  GOTO   20B
0216:  MOVF   6F,W
0217:  MOVWF  78
0218:  GOTO   224
0219:  MOVLW  3F
021A:  BTFSC  77.7
021B:  MOVLW  11
021C:  MOVWF  78
021D:  DECFSZ 78,F
021E:  GOTO   21D
021F:  BTFSC  77.7
0220:  GOTO   209
0221:  BTFSC  77.6
0222:  GOTO   213
0223:  GOTO   20B
0224:  BCF    03.5
0225:  GOTO   445 (RETURN)
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
023B:  CLRF   28
023C:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
015B:  BSF    03.6
015C:  MOVF   2B,W
015D:  MOVWF  2D
015E:  MOVF   2A,W
015F:  MOVWF  2C
0160:  MOVF   2D,W
0161:  MOVWF  7A
0162:  MOVF   2C,W
0163:  MOVWF  04
0164:  BCF    03.7
0165:  BTFSC  7A.0
0166:  BSF    03.7
0167:  MOVF   00,F
0168:  BTFSC  03.2
0169:  GOTO   16E
016A:  INCF   2C,F
016B:  BTFSC  03.2
016C:  INCF   2D,F
016D:  GOTO   160
....................    return(sc - s); 
016E:  MOVF   2A,W
016F:  SUBWF  2C,W
0170:  MOVWF  77
0171:  MOVF   2D,W
0172:  MOVWF  7A
0173:  MOVF   2B,W
0174:  BTFSS  03.0
0175:  INCFSZ 2B,W
0176:  SUBWF  7A,F
0177:  MOVF   77,W
0178:  MOVWF  78
.................... } 
0179:  BCF    03.6
017A:  RETURN
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................     
....................    int i = 0, y = 0; 
....................    char k; 
....................    char arg[6] = {'+', 'C', 'L', 'I', 'P', ':'}; 
*
023D:  MOVLW  2B
023E:  MOVWF  2D
023F:  MOVLW  43
0240:  MOVWF  2E
0241:  MOVLW  4C
0242:  MOVWF  2F
0243:  MOVLW  49
0244:  MOVWF  30
0245:  MOVLW  50
0246:  MOVWF  31
0247:  MOVLW  3A
0248:  MOVWF  32
....................    boolean podeEntrar = false;    
....................    char vet[];// = "\"85851611\",\"\",161,";  
....................     
.................... char *retNum(char *str, char *strret){  //   "85851611","",161, 
*
00D9:  BSF    03.6
00DA:  CLRF   24
00DB:  CLRF   25
00DC:  CLRF   26
....................    int a = 0, b = 0, cont = 0; 
....................    while(a < 19){ 
00DD:  MOVF   24,W
00DE:  SUBLW  12
00DF:  BTFSS  03.0
00E0:  GOTO   131
....................       if(cont == 1){ 
00E1:  DECFSZ 26,W
00E2:  GOTO   0FE
....................          strret[b] = str[a]; 
00E3:  MOVF   25,W
00E4:  ADDWF  22,W
00E5:  MOVWF  78
00E6:  MOVF   23,W
00E7:  MOVWF  7A
00E8:  BTFSC  03.0
00E9:  INCF   7A,F
00EA:  MOVF   78,W
00EB:  MOVWF  27
00EC:  MOVF   7A,W
00ED:  MOVWF  28
00EE:  MOVF   24,W
00EF:  ADDWF  20,W
00F0:  MOVWF  04
00F1:  BCF    03.7
00F2:  BTFSC  21.0
00F3:  BSF    03.7
00F4:  MOVF   00,W
00F5:  MOVWF  29
00F6:  MOVF   27,W
00F7:  MOVWF  04
00F8:  BCF    03.7
00F9:  BTFSC  28.0
00FA:  BSF    03.7
00FB:  MOVF   29,W
00FC:  MOVWF  00
....................          b++; 
00FD:  INCF   25,F
....................       } 
....................       if (str[a] == '\"' ){ 
00FE:  MOVF   24,W
00FF:  ADDWF  20,W
0100:  MOVWF  04
0101:  BCF    03.7
0102:  BTFSC  21.0
0103:  BSF    03.7
0104:  MOVF   00,W
0105:  SUBLW  22
0106:  BTFSS  03.2
0107:  GOTO   12F
....................          cont++; 
0108:  INCF   26,F
....................          if(cont == 2){ 
0109:  MOVF   26,W
010A:  SUBLW  02
010B:  BTFSS  03.2
010C:  GOTO   12F
....................             fputs("ATH\r", gprs);             
010D:  CLRF   27
010E:  MOVF   27,W
010F:  BCF    03.6
0110:  CALL   031
0111:  IORLW  00
0112:  BTFSC  03.2
0113:  GOTO   11D
0114:  BSF    03.6
0115:  INCF   27,F
0116:  BCF    03.6
0117:  BTFSS  0C.4
0118:  GOTO   117
0119:  MOVWF  19
011A:  BSF    03.6
011B:  GOTO   10E
011C:  BCF    03.6
011D:  MOVLW  0D
011E:  BTFSS  0C.4
011F:  GOTO   11E
0120:  MOVWF  19
0121:  MOVLW  0A
0122:  BTFSS  0C.4
0123:  GOTO   122
0124:  MOVWF  19
....................             strret[b-1] = '\0'; 
0125:  MOVLW  01
0126:  BSF    03.6
0127:  SUBWF  25,W
0128:  ADDWF  22,W
0129:  MOVWF  04
012A:  BCF    03.7
012B:  BTFSC  23.0
012C:  BSF    03.7
012D:  CLRF   00
....................             break; 
012E:  GOTO   131
....................          } 
....................       } 
....................       a++; 
012F:  INCF   24,F
....................    } 
0130:  GOTO   0DD
.................... return(strret);       
0131:  MOVF   22,W
0132:  MOVWF  78
0133:  MOVF   23,W
0134:  MOVWF  79
.................... } 
0135:  BCF    03.6
0136:  GOTO   272 (RETURN)
....................  
.................... char *splitstr(char *str, char* strret, int num, char chr){ 
*
017B:  BSF    03.6
017C:  CLRF   25
017D:  CLRF   26
017E:  CLRF   27
017F:  CLRF   28
....................    int i = 0, j = 0, cont = 0, index = 0; 
....................    while(i < strlen(str)){ 
0180:  MOVF   21,W
0181:  MOVWF  2B
0182:  MOVF   20,W
0183:  MOVWF  2A
0184:  BCF    03.6
0185:  CALL   15B
0186:  MOVF   78,W
0187:  BSF    03.6
0188:  SUBWF  25,W
0189:  BTFSC  03.0
018A:  GOTO   1A2
....................       if (index == num){ 
018B:  BSF    03.5
018C:  BCF    03.6
018D:  MOVF   6F,W
018E:  BCF    03.5
018F:  BSF    03.6
0190:  SUBWF  28,W
0191:  BTFSS  03.2
0192:  GOTO   196
....................          cont++; 
0193:  INCF   27,F
....................          break; 
0194:  GOTO   1A2
....................       } 
....................       else  
0195:  GOTO   1A0
....................          if(str[i] == chr) 
0196:  MOVF   25,W
0197:  ADDWF  20,W
0198:  MOVWF  04
0199:  BCF    03.7
019A:  BTFSC  21.0
019B:  BSF    03.7
019C:  MOVF   24,W
019D:  SUBWF  00,W
019E:  BTFSC  03.2
....................            index++; 
019F:  INCF   28,F
....................       i++; 
01A0:  INCF   25,F
....................    } 
01A1:  GOTO   180
....................    while(i < strlen(str)){ 
01A2:  MOVF   21,W
01A3:  MOVWF  2B
01A4:  MOVF   20,W
01A5:  MOVWF  2A
01A6:  BCF    03.6
01A7:  CALL   15B
01A8:  MOVF   78,W
01A9:  BSF    03.6
01AA:  SUBWF  25,W
01AB:  BTFSC  03.0
01AC:  GOTO   1F8
....................       if((str[i] != chr) && (cont == 1)){ 
01AD:  MOVF   25,W
01AE:  ADDWF  20,W
01AF:  MOVWF  04
01B0:  BCF    03.7
01B1:  BTFSC  21.0
01B2:  BSF    03.7
01B3:  MOVF   24,W
01B4:  SUBWF  00,W
01B5:  BTFSC  03.2
01B6:  GOTO   1D4
01B7:  DECFSZ 27,W
01B8:  GOTO   1D4
....................          strret[j] = str[i]; 
01B9:  MOVF   26,W
01BA:  ADDWF  22,W
01BB:  MOVWF  78
01BC:  MOVF   23,W
01BD:  MOVWF  7A
01BE:  BTFSC  03.0
01BF:  INCF   7A,F
01C0:  MOVF   78,W
01C1:  MOVWF  29
01C2:  MOVF   7A,W
01C3:  MOVWF  2A
01C4:  MOVF   25,W
01C5:  ADDWF  20,W
01C6:  MOVWF  04
01C7:  BCF    03.7
01C8:  BTFSC  21.0
01C9:  BSF    03.7
01CA:  MOVF   00,W
01CB:  MOVWF  2B
01CC:  MOVF   29,W
01CD:  MOVWF  04
01CE:  BCF    03.7
01CF:  BTFSC  2A.0
01D0:  BSF    03.7
01D1:  MOVF   2B,W
01D2:  MOVWF  00
....................          j++; 
01D3:  INCF   26,F
....................       } 
....................       if((str[i] == chr) || (i == strlen(str)-1)) 
01D4:  MOVF   25,W
01D5:  ADDWF  20,W
01D6:  MOVWF  04
01D7:  BCF    03.7
01D8:  BTFSC  21.0
01D9:  BSF    03.7
01DA:  MOVF   24,W
01DB:  SUBWF  00,W
01DC:  BTFSC  03.2
01DD:  GOTO   1E9
01DE:  MOVF   21,W
01DF:  MOVWF  2B
01E0:  MOVF   20,W
01E1:  MOVWF  2A
01E2:  BCF    03.6
01E3:  CALL   15B
01E4:  MOVLW  01
01E5:  SUBWF  78,W
01E6:  BSF    03.6
01E7:  SUBWF  25,W
01E8:  BTFSC  03.2
....................          cont++; 
01E9:  INCF   27,F
....................       if(cont == 2){ 
01EA:  MOVF   27,W
01EB:  SUBLW  02
01EC:  BTFSS  03.2
01ED:  GOTO   1F6
....................          strret[j] = '\0'; 
01EE:  MOVF   26,W
01EF:  ADDWF  22,W
01F0:  MOVWF  04
01F1:  BCF    03.7
01F2:  BTFSC  23.0
01F3:  BSF    03.7
01F4:  CLRF   00
....................          break; 
01F5:  GOTO   1F8
....................       } 
....................       i++; 
01F6:  INCF   25,F
....................    } 
01F7:  GOTO   1A2
....................    return strret; 
01F8:  MOVF   22,W
01F9:  MOVWF  78
01FA:  MOVF   23,W
01FB:  MOVWF  79
.................... } 
01FC:  BCF    03.6
01FD:  RETURN
....................  
....................  
.................... #INT_RDA 
.................... void serial_isr(){ 
....................    // IMEI:  358948-01-042182-2 
....................       k=fgetc(gprs); 
*
00B3:  BTFSS  0C.5
00B4:  GOTO   0B3
00B5:  MOVF   1A,W
00B6:  MOVWF  2C
....................       if(k == arg[i]) 
00B7:  MOVLW  2D
00B8:  ADDWF  2A,W
00B9:  MOVWF  04
00BA:  BCF    03.7
00BB:  MOVF   00,W
00BC:  SUBWF  2C,W
00BD:  BTFSC  03.2
....................          i++; 
00BE:  INCF   2A,F
....................       if(i > 5){ 
00BF:  MOVF   2A,W
00C0:  SUBLW  05
00C1:  BTFSC  03.0
00C2:  GOTO   0D6
....................          vet[y] = k; 
00C3:  MOVLW  34
00C4:  ADDWF  2B,W
00C5:  MOVWF  04
00C6:  BCF    03.7
00C7:  MOVF   2C,W
00C8:  MOVWF  00
....................          y++; 
00C9:  INCF   2B,F
....................          if(y > 12){ 
00CA:  MOVF   2B,W
00CB:  SUBLW  0C
00CC:  BTFSC  03.0
00CD:  GOTO   0D6
....................             vet[y] = '\0'; 
00CE:  MOVLW  34
00CF:  ADDWF  2B,W
00D0:  MOVWF  04
00D1:  BCF    03.7
00D2:  CLRF   00
....................            // fputs(retNum(vet, temp), serial);      
....................             podeEntrar = true; 
00D3:  BSF    33.0
....................             i = 0; 
00D4:  CLRF   2A
....................             y = 0; 
00D5:  CLRF   2B
....................             break; 
....................          } 
....................       }  
.................... } 
....................  
00D6:  BCF    0C.5
00D7:  BCF    0A.3
00D8:  GOTO   020
.................... void main(){ 
*
0226:  CLRF   04
0227:  BCF    03.7
0228:  MOVLW  1F
0229:  ANDWF  03,F
022A:  MOVLW  19
022B:  BSF    03.5
022C:  MOVWF  19
022D:  MOVLW  A6
022E:  MOVWF  18
022F:  MOVLW  90
0230:  BCF    03.5
0231:  MOVWF  18
0232:  BSF    03.5
0233:  BCF    05.0
0234:  BCF    03.5
0235:  BSF    05.0
0236:  CLRF   2A
0237:  CLRF   2B
0238:  BCF    33.0
0239:  MOVLW  07
023A:  MOVWF  1F
*
0255:  CLRF   63
0256:  CLRF   64
....................    char temp[20]; 
....................   // char chr[25]; 
....................    //char vet[] = "\r\nRING\r\n+CLIP: \"85851611\",161,\"\",,\"\",0\r\n"; 
.................... // ----- Var GPS ------- 
....................    char temp2[20]; 
....................    char gps[70]; 
....................    char arggps[6] = {'$', 'G', 'P', 'R', 'M', 'C'}; 
*
0249:  MOVLW  24
024A:  MOVWF  5D
024B:  MOVLW  47
024C:  MOVWF  5E
024D:  MOVLW  50
024E:  MOVWF  5F
024F:  MOVLW  52
0250:  MOVWF  60
0251:  MOVLW  4D
0252:  MOVWF  61
0253:  MOVLW  43
0254:  MOVWF  62
....................    int a = 0,b = 0; 
....................    char chrgps; 
....................  
.................... // -------------------- 
....................  
....................    enable_interrupts(GLOBAL); 
*
0257:  MOVLW  C0
0258:  IORWF  0B,F
....................    enable_interrupts(INT_RDA);    
0259:  BSF    03.5
025A:  BSF    0C.5
....................    while(true){ 
....................       /*output_high(pin_B0); 
....................       delay_ms(300); 
....................       output_low(pin_B0); 
....................       delay_ms(300);*/ 
....................        
....................       if(podeEntrar){ 
025B:  BCF    03.5
025C:  BTFSS  33.0
025D:  GOTO   444
....................          podeEntrar = false; 
025E:  BCF    33.0
....................          fputs(retNum(*vet, temp), serial); 
025F:  CLRF   7A
0260:  MOVF   34,W
0261:  MOVWF  04
0262:  BCF    03.7
0263:  BTFSC  7A.0
0264:  BSF    03.7
0265:  MOVF   00,W
0266:  MOVWF  66
0267:  BSF    03.6
0268:  CLRF   21
0269:  BCF    03.6
026A:  MOVF   66,W
026B:  BSF    03.6
026C:  MOVWF  20
026D:  CLRF   23
026E:  MOVLW  35
026F:  MOVWF  22
0270:  BCF    03.6
0271:  GOTO   0D9
0272:  MOVF   79,W
0273:  MOVWF  67
0274:  MOVF   78,W
0275:  MOVWF  66
0276:  MOVWF  04
0277:  BCF    03.7
0278:  BTFSC  79.0
0279:  BSF    03.7
027A:  MOVLW  00
027B:  IORWF  00,W
027C:  BTFSC  03.2
027D:  GOTO   290
027E:  CLRF   69
027F:  MOVF   04,W
0280:  MOVWF  68
0281:  BCF    69.0
0282:  BTFSC  03.7
0283:  BSF    69.0
0284:  MOVF   00,W
0285:  BSF    03.6
0286:  MOVWF  23
0287:  BCF    03.6
0288:  CALL   137
0289:  MOVF   68,W
028A:  MOVWF  04
028B:  BCF    03.7
028C:  BTFSC  69.0
028D:  BSF    03.7
028E:  INCF   04,F
028F:  GOTO   27A
0290:  MOVLW  0D
0291:  BSF    03.6
0292:  MOVWF  23
0293:  BCF    03.6
0294:  CALL   137
0295:  MOVLW  0A
0296:  BSF    03.6
0297:  MOVWF  23
0298:  BCF    03.6
0299:  CALL   137
....................          fputs(temp, serial);          
029A:  MOVLW  35
029B:  MOVWF  04
029C:  BCF    03.7
029D:  MOVLW  00
029E:  IORWF  00,W
029F:  BTFSC  03.2
02A0:  GOTO   2B3
02A1:  CLRF   67
02A2:  MOVF   04,W
02A3:  MOVWF  66
02A4:  BCF    67.0
02A5:  BTFSC  03.7
02A6:  BSF    67.0
02A7:  MOVF   00,W
02A8:  BSF    03.6
02A9:  MOVWF  23
02AA:  BCF    03.6
02AB:  CALL   137
02AC:  MOVF   66,W
02AD:  MOVWF  04
02AE:  BCF    03.7
02AF:  BTFSC  67.0
02B0:  BSF    03.7
02B1:  INCF   04,F
02B2:  GOTO   29D
02B3:  MOVLW  0D
02B4:  BSF    03.6
02B5:  MOVWF  23
02B6:  BCF    03.6
02B7:  CALL   137
02B8:  MOVLW  0A
02B9:  BSF    03.6
02BA:  MOVWF  23
02BB:  BCF    03.6
02BC:  CALL   137
....................          //fputs("ATH\r", gprs);     
....................           
....................          /*sprintf(chr, "AT+CMGS=\"85851611\"\r");                   
....................          fputs("AT+CMGF=1\r", gprs); 
....................          fputs(chr, gprs); 
....................          sprintf(chr, "Lt:   08 01.8650S\r\nLg:034 56.3050W%c", 0x1a); 
....................          fputs(chr, gprs);*/ 
....................           
....................          fprintf(gprs, "AT+CMGF=1\r"); 
02BD:  CLRF   66
02BE:  MOVF   66,W
02BF:  CALL   03A
02C0:  INCF   66,F
02C1:  MOVWF  77
02C2:  MOVF   77,W
02C3:  BTFSS  0C.4
02C4:  GOTO   2C3
02C5:  MOVWF  19
02C6:  MOVLW  0A
02C7:  SUBWF  66,W
02C8:  BTFSS  03.2
02C9:  GOTO   2BE
....................          fprintf(gprs, "AT+CMGS=\"85851611\"\r"); 
02CA:  CLRF   66
02CB:  MOVF   66,W
02CC:  CALL   049
02CD:  INCF   66,F
02CE:  MOVWF  77
02CF:  MOVF   77,W
02D0:  BTFSS  0C.4
02D1:  GOTO   2D0
02D2:  MOVWF  19
02D3:  MOVLW  13
02D4:  SUBWF  66,W
02D5:  BTFSS  03.2
02D6:  GOTO   2CB
....................           
....................          
....................          fprintf(gprs, "Hora: %s\r\n", splitstr(gps, temp2, 1, ',')); 
02D7:  BSF    03.6
02D8:  CLRF   21
02D9:  MOVLW  A0
02DA:  MOVWF  20
02DB:  CLRF   23
02DC:  MOVLW  49
02DD:  MOVWF  22
02DE:  MOVLW  01
02DF:  BSF    03.5
02E0:  BCF    03.6
02E1:  MOVWF  6F
02E2:  MOVLW  2C
02E3:  BCF    03.5
02E4:  BSF    03.6
02E5:  MOVWF  24
02E6:  BCF    03.6
02E7:  CALL   17B
02E8:  MOVF   79,W
02E9:  MOVWF  67
02EA:  MOVF   78,W
02EB:  MOVWF  66
02EC:  CLRF   68
02ED:  MOVF   68,W
02EE:  CALL   061
02EF:  INCF   68,F
02F0:  MOVWF  77
02F1:  MOVF   77,W
02F2:  BTFSS  0C.4
02F3:  GOTO   2F2
02F4:  MOVWF  19
02F5:  MOVLW  06
02F6:  SUBWF  68,W
02F7:  BTFSS  03.2
02F8:  GOTO   2ED
02F9:  MOVF   66,W
02FA:  MOVWF  04
02FB:  BCF    03.7
02FC:  BTFSC  67.0
02FD:  BSF    03.7
02FE:  MOVLW  00
02FF:  IORWF  00,W
0300:  BTFSC  03.2
0301:  GOTO   308
0302:  MOVF   00,W
0303:  BTFSS  0C.4
0304:  GOTO   303
0305:  MOVWF  19
0306:  INCF   04,F
0307:  GOTO   2FE
0308:  MOVLW  0D
0309:  BTFSS  0C.4
030A:  GOTO   309
030B:  MOVWF  19
030C:  MOVLW  0A
030D:  BTFSS  0C.4
030E:  GOTO   30D
030F:  MOVWF  19
....................          fprintf(gprs, "Data: %s\r\n", splitstr(gps, temp2, 9, ','));             
0310:  BSF    03.6
0311:  CLRF   21
0312:  MOVLW  A0
0313:  MOVWF  20
0314:  CLRF   23
0315:  MOVLW  49
0316:  MOVWF  22
0317:  MOVLW  09
0318:  BSF    03.5
0319:  BCF    03.6
031A:  MOVWF  6F
031B:  MOVLW  2C
031C:  BCF    03.5
031D:  BSF    03.6
031E:  MOVWF  24
031F:  BCF    03.6
0320:  CALL   17B
0321:  MOVF   79,W
0322:  MOVWF  67
0323:  MOVF   78,W
0324:  MOVWF  66
0325:  CLRF   68
0326:  MOVF   68,W
0327:  CALL   070
0328:  INCF   68,F
0329:  MOVWF  77
032A:  MOVF   77,W
032B:  BTFSS  0C.4
032C:  GOTO   32B
032D:  MOVWF  19
032E:  MOVLW  06
032F:  SUBWF  68,W
0330:  BTFSS  03.2
0331:  GOTO   326
0332:  MOVF   66,W
0333:  MOVWF  04
0334:  BCF    03.7
0335:  BTFSC  67.0
0336:  BSF    03.7
0337:  MOVLW  00
0338:  IORWF  00,W
0339:  BTFSC  03.2
033A:  GOTO   341
033B:  MOVF   00,W
033C:  BTFSS  0C.4
033D:  GOTO   33C
033E:  MOVWF  19
033F:  INCF   04,F
0340:  GOTO   337
0341:  MOVLW  0D
0342:  BTFSS  0C.4
0343:  GOTO   342
0344:  MOVWF  19
0345:  MOVLW  0A
0346:  BTFSS  0C.4
0347:  GOTO   346
0348:  MOVWF  19
....................          fprintf(gprs, "Lt:  %s", splitstr(gps, temp2, 3, ','));             
0349:  BSF    03.6
034A:  CLRF   21
034B:  MOVLW  A0
034C:  MOVWF  20
034D:  CLRF   23
034E:  MOVLW  49
034F:  MOVWF  22
0350:  MOVLW  03
0351:  BSF    03.5
0352:  BCF    03.6
0353:  MOVWF  6F
0354:  MOVLW  2C
0355:  BCF    03.5
0356:  BSF    03.6
0357:  MOVWF  24
0358:  BCF    03.6
0359:  CALL   17B
035A:  MOVF   79,W
035B:  MOVWF  67
035C:  MOVF   78,W
035D:  MOVWF  66
035E:  CLRF   68
035F:  MOVF   68,W
0360:  CALL   07F
0361:  INCF   68,F
0362:  MOVWF  77
0363:  MOVF   77,W
0364:  BTFSS  0C.4
0365:  GOTO   364
0366:  MOVWF  19
0367:  MOVLW  05
0368:  SUBWF  68,W
0369:  BTFSS  03.2
036A:  GOTO   35F
036B:  MOVF   66,W
036C:  MOVWF  04
036D:  BCF    03.7
036E:  BTFSC  67.0
036F:  BSF    03.7
0370:  MOVLW  00
0371:  IORWF  00,W
0372:  BTFSC  03.2
0373:  GOTO   37A
0374:  MOVF   00,W
0375:  BTFSS  0C.4
0376:  GOTO   375
0377:  MOVWF  19
0378:  INCF   04,F
0379:  GOTO   370
....................          fprintf(gprs, "%s\r\n", splitstr(gps, temp2, 4, ','));             
037A:  BSF    03.6
037B:  CLRF   21
037C:  MOVLW  A0
037D:  MOVWF  20
037E:  CLRF   23
037F:  MOVLW  49
0380:  MOVWF  22
0381:  MOVLW  04
0382:  BSF    03.5
0383:  BCF    03.6
0384:  MOVWF  6F
0385:  MOVLW  2C
0386:  BCF    03.5
0387:  BSF    03.6
0388:  MOVWF  24
0389:  BCF    03.6
038A:  CALL   17B
038B:  MOVF   79,W
038C:  MOVWF  67
038D:  MOVF   78,W
038E:  MOVWF  66
038F:  MOVWF  04
0390:  BCF    03.7
0391:  BTFSC  79.0
0392:  BSF    03.7
0393:  MOVLW  00
0394:  IORWF  00,W
0395:  BTFSC  03.2
0396:  GOTO   39D
0397:  MOVF   00,W
0398:  BTFSS  0C.4
0399:  GOTO   398
039A:  MOVWF  19
039B:  INCF   04,F
039C:  GOTO   393
039D:  MOVLW  0D
039E:  BTFSS  0C.4
039F:  GOTO   39E
03A0:  MOVWF  19
03A1:  MOVLW  0A
03A2:  BTFSS  0C.4
03A3:  GOTO   3A2
03A4:  MOVWF  19
....................          fprintf(gprs, "Lg: %s", splitstr(gps, temp2, 5, ','));             
03A5:  BSF    03.6
03A6:  CLRF   21
03A7:  MOVLW  A0
03A8:  MOVWF  20
03A9:  CLRF   23
03AA:  MOVLW  49
03AB:  MOVWF  22
03AC:  MOVLW  05
03AD:  BSF    03.5
03AE:  BCF    03.6
03AF:  MOVWF  6F
03B0:  MOVLW  2C
03B1:  BCF    03.5
03B2:  BSF    03.6
03B3:  MOVWF  24
03B4:  BCF    03.6
03B5:  CALL   17B
03B6:  MOVF   79,W
03B7:  MOVWF  67
03B8:  MOVF   78,W
03B9:  MOVWF  66
03BA:  CLRF   68
03BB:  MOVF   68,W
03BC:  CALL   08B
03BD:  INCF   68,F
03BE:  MOVWF  77
03BF:  MOVF   77,W
03C0:  BTFSS  0C.4
03C1:  GOTO   3C0
03C2:  MOVWF  19
03C3:  MOVLW  04
03C4:  SUBWF  68,W
03C5:  BTFSS  03.2
03C6:  GOTO   3BB
03C7:  MOVF   66,W
03C8:  MOVWF  04
03C9:  BCF    03.7
03CA:  BTFSC  67.0
03CB:  BSF    03.7
03CC:  MOVLW  00
03CD:  IORWF  00,W
03CE:  BTFSC  03.2
03CF:  GOTO   3D6
03D0:  MOVF   00,W
03D1:  BTFSS  0C.4
03D2:  GOTO   3D1
03D3:  MOVWF  19
03D4:  INCF   04,F
03D5:  GOTO   3CC
....................          fprintf(gprs, "%s\r\n", splitstr(gps, temp2, 6, ',')); 
03D6:  BSF    03.6
03D7:  CLRF   21
03D8:  MOVLW  A0
03D9:  MOVWF  20
03DA:  CLRF   23
03DB:  MOVLW  49
03DC:  MOVWF  22
03DD:  MOVLW  06
03DE:  BSF    03.5
03DF:  BCF    03.6
03E0:  MOVWF  6F
03E1:  MOVLW  2C
03E2:  BCF    03.5
03E3:  BSF    03.6
03E4:  MOVWF  24
03E5:  BCF    03.6
03E6:  CALL   17B
03E7:  MOVF   79,W
03E8:  MOVWF  67
03E9:  MOVF   78,W
03EA:  MOVWF  66
03EB:  MOVWF  04
03EC:  BCF    03.7
03ED:  BTFSC  79.0
03EE:  BSF    03.7
03EF:  MOVLW  00
03F0:  IORWF  00,W
03F1:  BTFSC  03.2
03F2:  GOTO   3F9
03F3:  MOVF   00,W
03F4:  BTFSS  0C.4
03F5:  GOTO   3F4
03F6:  MOVWF  19
03F7:  INCF   04,F
03F8:  GOTO   3EF
03F9:  MOVLW  0D
03FA:  BTFSS  0C.4
03FB:  GOTO   3FA
03FC:  MOVWF  19
03FD:  MOVLW  0A
03FE:  BTFSS  0C.4
03FF:  GOTO   3FE
0400:  MOVWF  19
....................          fprintf(gprs, "VEL(Mph): %s \r\nBy Marlon", splitstr(gps, temp2, 7, ','));             
0401:  BSF    03.6
0402:  CLRF   21
0403:  MOVLW  A0
0404:  MOVWF  20
0405:  CLRF   23
0406:  MOVLW  49
0407:  MOVWF  22
0408:  MOVLW  07
0409:  BSF    03.5
040A:  BCF    03.6
040B:  MOVWF  6F
040C:  MOVLW  2C
040D:  BCF    03.5
040E:  BSF    03.6
040F:  MOVWF  24
0410:  BCF    03.6
0411:  CALL   17B
0412:  MOVF   79,W
0413:  MOVWF  67
0414:  MOVF   78,W
0415:  MOVWF  66
0416:  CLRF   68
0417:  MOVF   68,W
0418:  CALL   096
0419:  INCF   68,F
041A:  MOVWF  77
041B:  MOVF   77,W
041C:  BTFSS  0C.4
041D:  GOTO   41C
041E:  MOVWF  19
041F:  MOVLW  0A
0420:  SUBWF  68,W
0421:  BTFSS  03.2
0422:  GOTO   417
0423:  MOVF   66,W
0424:  MOVWF  04
0425:  BCF    03.7
0426:  BTFSC  67.0
0427:  BSF    03.7
0428:  MOVLW  00
0429:  IORWF  00,W
042A:  BTFSC  03.2
042B:  GOTO   432
042C:  MOVF   00,W
042D:  BTFSS  0C.4
042E:  GOTO   42D
042F:  MOVWF  19
0430:  INCF   04,F
0431:  GOTO   428
0432:  MOVLW  0C
0433:  MOVWF  6A
0434:  MOVF   6A,W
0435:  CALL   096
0436:  INCF   6A,F
0437:  MOVWF  77
0438:  MOVF   77,W
0439:  BTFSS  0C.4
043A:  GOTO   439
043B:  MOVWF  19
043C:  MOVLW  18
043D:  SUBWF  6A,W
043E:  BTFSS  03.2
043F:  GOTO   434
....................          fprintf(gprs, "%c", 0x1a);          
0440:  MOVLW  1A
0441:  BTFSS  0C.4
0442:  GOTO   441
0443:  MOVWF  19
....................       } 
....................       // -------------- Recepção GPS -------------------------- 
....................       chrgps=fgetc(serial); 
0444:  GOTO   1FE
0445:  MOVF   78,W
0446:  MOVWF  65
....................       if(chrgps == arggps[i]) 
0447:  MOVLW  5D
0448:  ADDWF  2A,W
0449:  MOVWF  04
044A:  BCF    03.7
044B:  MOVF   00,W
044C:  SUBWF  65,W
044D:  BTFSC  03.2
....................          b++; 
044E:  INCF   64,F
....................       if(b > 5){ 
044F:  MOVF   64,W
0450:  SUBLW  05
0451:  BTFSC  03.0
0452:  GOTO   460
....................          gps[a] = chrgps; 
0453:  MOVLW  A0
0454:  ADDWF  63,W
0455:  MOVWF  04
0456:  BCF    03.7
0457:  MOVF   65,W
0458:  MOVWF  00
....................          a++; 
0459:  INCF   63,F
....................          if(a > 69){ 
045A:  MOVF   63,W
045B:  SUBLW  45
045C:  BTFSC  03.0
045D:  GOTO   460
....................             a = 0; 
045E:  CLRF   63
....................             b = 0; 
045F:  CLRF   64
....................          } 
....................       }       
....................       // ------------------------------------------------------- 
....................    } 
0460:  GOTO   25C
.................... } 
.................... /*  
.................... 1 = 24 
.................... 2 = 16 
.................... 3 = 17 
.................... 4 = 20 
.................... $GPRMC,213820.79,A,0800.8226,S,03454.5543,W,000.0,000.8,050410,022.6,W,A*25  
....................  
.................... $GPRMC, 
.................... 213820.79,        Fix taken at 213820 UTC 
.................... A,                Status A=active or V=Void. 
.................... 0800.8226,        Latitude 08 deg 00.8226' 
.................... S,                S 
.................... 03454.5543,       Longitude 034 deg 54.5543' 
.................... W,                W 
.................... 000.0,            Speed over the ground in knots (Milhas Náuticas, 1852 Metros ou 1,852 Km) 
.................... 000.8,            Track angle in degrees True 
.................... 050410,           Date -  5 rd of April 2010 
.................... 022.6,            Magnetic Variation 
.................... W,                W 
.................... A*25              The checksum data, always begins with * 
....................  
.................... Da forma que o google Maps traduz:   08 00.8226S 034 54.5643W 
....................  
.................... */ 
0461:  SLEEP

Configuration Fuses:
   Word  1: 3F21   NOWDT PUT XT MCLR NOBROWNOUT NOLVP NOCPD NOPROTECT
