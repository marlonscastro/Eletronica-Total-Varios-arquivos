CCS PCM C Compiler, Version 4.114, 93483988               21-abr-14 18:59

               Filename: D:\SkyDrive\Eletronica\PROJETOS PIC CCS\LCD SIEMENS AX75, C72\LPH9135\main.lst

               ROM used: 464 words (6%)
                         Largest free fragment is 2048
               RAM used: 49 (13%) at main() level
                         59 (16%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   176
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.5
001A:  GOTO   01D
001B:  BTFSC  0B.2
001C:  GOTO   030
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   27,W
0028:  MOVWF  7B
0029:  MOVF   20,W
002A:  MOVWF  0A
002B:  SWAPF  21,W
002C:  MOVWF  03
002D:  SWAPF  7F,F
002E:  SWAPF  7F,W
002F:  RETFIE
0030:  BCF    0A.3
0031:  BCF    0A.4
0032:  GOTO   033
.................... #include <16F876.h> 
.................... //////// Standard Header file for the PIC16F876 device //////////////// 
.................... #device PIC16F876 
.................... #list 
....................  
.................... #FUSES NOWDT, HS, NOPUT, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NODEBUG, NOPROTECT 
.................... #use delay(clock=16000000) 
*
0049:  MOVLW  4B
004A:  MOVWF  04
004B:  BCF    03.7
004C:  MOVF   00,W
004D:  BTFSC  03.2
004E:  GOTO   05D
004F:  MOVLW  05
0050:  MOVWF  78
0051:  CLRF   77
0052:  DECFSZ 77,F
0053:  GOTO   052
0054:  DECFSZ 78,F
0055:  GOTO   051
0056:  MOVLW  2E
0057:  MOVWF  77
0058:  DECFSZ 77,F
0059:  GOTO   058
005A:  GOTO   05B
005B:  DECFSZ 00,F
005C:  GOTO   04F
005D:  RETURN
....................  
.................... #include "LPH9135.h" // Controlador do Siemens Ax75, c72 
.................... #include "Symbols.h" 
.................... BYTE const font_5x8[][5]  = { 
.................... 0x00, 0x00, 0x00, 0x00, 0x00,// (space)  32 
.................... 0x00, 0x00, 0x5F, 0x00, 0x00,// !        33 
.................... 0x00, 0x07, 0x00, 0x07, 0x00,// "        34 
.................... 0x14, 0x7F, 0x14, 0x7F, 0x14,// #        35 
.................... 0x24, 0x2A, 0x7F, 0x2A, 0x12,// $        36 
.................... 0x23, 0x13, 0x08, 0x64, 0x62,// %        37 
.................... 0x36, 0x49, 0x55, 0x22, 0x50,// &        38 
.................... 0x00, 0x05, 0x03, 0x00, 0x00,// '        39 
.................... 0x00, 0x1C, 0x22, 0x41, 0x00,// (        40 
.................... 0x00, 0x41, 0x22, 0x1C, 0x00,// )        41 
.................... 0x08, 0x2A, 0x1C, 0x2A, 0x08,// *        42 
.................... 0x08, 0x08, 0x3E, 0x08, 0x08,// +        43 
.................... 0x00, 0x50, 0x30, 0x00, 0x00,// ,        44 
.................... 0x08, 0x08, 0x08, 0x08, 0x08,// -        45 
.................... 0x00, 0x30, 0x30, 0x00, 0x00,// .        46 
.................... 0x20, 0x10, 0x08, 0x04, 0x02,// /        47 
.................... 0x3E, 0x51, 0x49, 0x45, 0x3E,// 0        48 
.................... 0x00, 0x42, 0x7F, 0x40, 0x00,// 1        49 
.................... 0x42, 0x61, 0x51, 0x49, 0x46,// 2        50 
.................... 0x21, 0x41, 0x45, 0x4B, 0x31,// 3        51 
.................... 0x18, 0x14, 0x12, 0x7F, 0x10,// 4        52 
.................... 0x27, 0x45, 0x45, 0x45, 0x39,// 5        53 
.................... 0x3C, 0x4A, 0x49, 0x49, 0x30,// 6        54 
.................... 0x01, 0x71, 0x09, 0x05, 0x03,// 7        55 
.................... 0x36, 0x49, 0x49, 0x49, 0x36,// 8        56 
.................... 0x06, 0x49, 0x49, 0x29, 0x1E,// 9        57 
.................... 0x00, 0x36, 0x36, 0x00, 0x00,// :        58 
.................... 0x00, 0x56, 0x36, 0x00, 0x00,// ;        59 
.................... 0x00, 0x08, 0x14, 0x22, 0x41,// <        60 
.................... 0x14, 0x14, 0x14, 0x14, 0x14,// =        61 
.................... 0x41, 0x22, 0x14, 0x08, 0x00,// >        62 
.................... 0x02, 0x01, 0x51, 0x09, 0x06,// ?        63 
.................... 0x32, 0x49, 0x79, 0x41, 0x3E,// @        64 
.................... 0x7E, 0x11, 0x11, 0x11, 0x7E,// A        65 
.................... 0x7F, 0x49, 0x49, 0x49, 0x36,// B        66 
.................... 0x3E, 0x41, 0x41, 0x41, 0x22,// C        67 
.................... 0x7F, 0x41, 0x41, 0x22, 0x1C,// D        68 
.................... 0x7F, 0x49, 0x49, 0x49, 0x41,// E        69 
.................... 0x7F, 0x09, 0x09, 0x01, 0x01,// F        70 
.................... 0x3E, 0x41, 0x41, 0x51, 0x32,// G        71 
.................... 0x7F, 0x08, 0x08, 0x08, 0x7F,// H        72 
.................... 0x00, 0x41, 0x7F, 0x41, 0x00,// I        73 
.................... 0x20, 0x40, 0x41, 0x3F, 0x01,// J        74 
.................... 0x7F, 0x08, 0x14, 0x22, 0x41,// K        75 
.................... 0x7F, 0x40, 0x40, 0x40, 0x40,// L        76 
.................... 0x7F, 0x02, 0x04, 0x02, 0x7F,// M        77 
.................... 0x7F, 0x04, 0x08, 0x10, 0x7F,// N        78 
.................... 0x3E, 0x41, 0x41, 0x41, 0x3E,// O        79 
.................... 0x7F, 0x09, 0x09, 0x09, 0x06,// P        80 
.................... 0x3E, 0x41, 0x51, 0x21, 0x5E,// Q        81 
.................... 0x7F, 0x09, 0x19, 0x29, 0x46,// R        82 
.................... 0x46, 0x49, 0x49, 0x49, 0x31,// S        83 
.................... 0x01, 0x01, 0x7F, 0x01, 0x01,// T        84 
.................... 0x3F, 0x40, 0x40, 0x40, 0x3F,// U        85 
.................... 0x1F, 0x20, 0x40, 0x20, 0x1F,// V        86 
.................... 0x7F, 0x20, 0x18, 0x20, 0x7F,// W        87 
.................... 0x63, 0x14, 0x08, 0x14, 0x63,// X        88 
.................... 0x03, 0x04, 0x78, 0x04, 0x03,// Y        89 
.................... 0x61, 0x51, 0x49, 0x45, 0x43,// Z        90 
.................... 0x00, 0x00, 0x7F, 0x41, 0x41,// [        91 
.................... 0x02, 0x04, 0x08, 0x10, 0x20,// "\"      92 
.................... 0x41, 0x41, 0x7F, 0x00, 0x00,// ]        93 
.................... 0x04, 0x02, 0x01, 0x02, 0x04,// ^        94 
.................... 0x40, 0x40, 0x40, 0x40, 0x40,// _        95 
.................... 0x00, 0x01, 0x02, 0x04, 0x00,// `        96 
.................... 0x20, 0x54, 0x54, 0x54, 0x78,// a        97 
.................... 0x7F, 0x48, 0x44, 0x44, 0x38,// b        98 
.................... 0x38, 0x44, 0x44, 0x44, 0x20,// c        99 
.................... 0x38, 0x44, 0x44, 0x48, 0x7F,// d        100 
.................... 0x38, 0x54, 0x54, 0x54, 0x18,// e        101 
.................... 0x08, 0x7E, 0x09, 0x01, 0x02,// f        102 
.................... 0x08, 0x14, 0x54, 0x54, 0x3C,// g        103 
.................... 0x7F, 0x08, 0x04, 0x04, 0x78,// h        104 
.................... 0x00, 0x44, 0x7D, 0x40, 0x00,// i        105 
.................... 0x20, 0x40, 0x44, 0x3D, 0x00,// j        106 
.................... 0x00, 0x7F, 0x10, 0x28, 0x44,// k        107 
.................... 0x00, 0x41, 0x7F, 0x40, 0x00,// l        108 
.................... 0x7C, 0x04, 0x18, 0x04, 0x78,// m        109 
.................... 0x7C, 0x08, 0x04, 0x04, 0x78,// n        110 
.................... 0x38, 0x44, 0x44, 0x44, 0x38,// o        111 
.................... 0x7C, 0x14, 0x14, 0x14, 0x08,// p        112 
.................... 0x08, 0x14, 0x14, 0x18, 0x7C,// q        113 
.................... 0x7C, 0x08, 0x04, 0x04, 0x08,// r        114 
.................... 0x48, 0x54, 0x54, 0x54, 0x20,// s        115 
.................... 0x04, 0x3F, 0x44, 0x40, 0x20,// t        116 
.................... 0x3C, 0x40, 0x40, 0x20, 0x7C,// u        117 
.................... 0x1C, 0x20, 0x40, 0x20, 0x1C,// v        118 
.................... 0x3C, 0x40, 0x30, 0x40, 0x3C,// w        119 
.................... 0x44, 0x28, 0x10, 0x28, 0x44,// x        120 
.................... 0x0C, 0x50, 0x50, 0x50, 0x3C,// y        121 
.................... 0x44, 0x64, 0x54, 0x4C, 0x44,// z        122 
.................... 0x00, 0x08, 0x36, 0x41, 0x00,// {        123 
.................... 0x00, 0x00, 0x7F, 0x00, 0x00,// |        124 
.................... 0x00, 0x41, 0x36, 0x08, 0x00,// }        125 
.................... 0x00, 0x00, 0x00, 0x00, 0x00,// (space)  126 
.................... 0x00, 0x00, 0x00, 0x00, 0x00,// (space)  127 
.................... 0x7E, 0x11, 0x11, 0x11, 0x7E,// A        192 
.................... 0x7F, 0x45, 0x45, 0x45, 0x39,// Б        193 
.................... 0x7F, 0x49, 0x49, 0x49, 0x36,// B        194 
.................... 0x7F, 0x01, 0x01, 0x01, 0x03,// Г        195 
.................... 0xC0, 0x7E, 0x41, 0x7F, 0xC0,// Д        196 
.................... 0x7F, 0x49, 0x49, 0x49, 0x41,// E        197 
.................... 119,8,127,8,119,             // Ж        198 
.................... 34,73,73,73,54,              // З        199 
.................... 127,32,16,8,127,             // И        200 
.................... 127,32,19,8,127,             // Й        201 
.................... 0x7F, 0x08, 0x14, 0x22, 0x41,// K        202 
.................... 64,62,1,1,127,               // Л        203 
.................... 0x7F, 0x02, 0x04, 0x02, 0x7F,// M        204 
.................... 0x7F, 0x08, 0x08, 0x08, 0x7F,// H        205 
.................... 0x3E, 0x41, 0x41, 0x41, 0x3E,// O        206 
.................... 127,1,1,1,127,               // П        207 
.................... 0x7F, 0x09, 0x09, 0x09, 0x06,// P        208 
.................... 0x3E, 0x41, 0x41, 0x41, 0x22,// C        209 
.................... 0x01, 0x01, 0x7F, 0x01, 0x01,// T        210 
.................... 39,72,72,72,63,              // У        211 
.................... 30,33,127,33,30,             // Ф        212 
.................... 0x63, 0x14, 0x08, 0x14, 0x63,// X        213 
.................... 127,64,64,127,192,           // Ц        214 
.................... 15,16,16,16,127,             // Ч        215 
.................... 127,64,124,64,127,           // Ш        216 
.................... 127,64,124,64,255,           // Щ        217 
.................... 1,127,72,72,48,              // Ъ        218 
.................... 127,72,48,0,127,             // Ы        219 
.................... 127,72,72,72,48,             // Ь        220 
.................... 34,73,73,73,62,              // Э        221 
.................... 127,8,62,65,62,              // Ю        222 
.................... 118,9,9,9,127,               // Я        223 
.................... 0x20, 0x54, 0x54, 0x54, 0x78,// a        224 
.................... 124, 84, 84, 84, 36,         // б        225 
.................... 124, 84, 84, 84, 40,         // в        226 
.................... 124, 4, 4, 4, 12,            // г        227 
.................... 192, 120, 68, 124, 192,      // д        228 
.................... 0x38, 0x54, 0x54, 0x54, 0x18,// e        229 
.................... 108, 16, 124, 16, 108,       // ж        230 
.................... 40, 68, 84, 84, 40,          // з        231 
.................... 124, 32, 16, 8, 124,         // и        232 
.................... 124, 33, 18, 8, 124,         // й        233 
.................... 124, 16, 16, 40, 68,         // к        234 
.................... 64, 56, 4, 4, 124,           // л        235 
.................... 124, 8, 16, 8, 124,          // м        236 
.................... 124, 16, 16, 16, 124,        // н        237 
.................... 0x38, 0x44, 0x44, 0x44, 0x38,// o        238 
.................... 124, 4, 4, 4, 124,           // п        239 
.................... 0x7C, 0x14, 0x14, 0x14, 0x08,// p        240 
.................... 0x38, 0x44, 0x44, 0x44, 0x20,// c        241 
.................... 4, 4, 124, 4, 4,             // т        242 
.................... 0x0C, 0x50, 0x50, 0x50, 0x3C,// y        243 
.................... 24, 36, 124, 36, 24,         // ф        244 
.................... 0x44, 0x28, 0x10, 0x28, 0x44,// x        245 
.................... 124, 64, 64, 124, 192,       // ц        246 
.................... 12, 16, 16, 16, 124,         // ч        247 
.................... 124, 64, 120, 64, 124,       // ш        248 
.................... 124, 64, 120, 64, 252,       // щ        249 
.................... 124, 84, 80, 80, 32,         // ъ        250 
.................... 124,80,32,0,124,             // ы        251 
.................... 124, 80, 80, 80, 32,         // ь        252 
.................... 40, 68, 84, 84, 56,          // э        253 
.................... 124, 16, 56, 68, 56,         // ю        254 
.................... 72, 52, 20, 20, 124          // я        255 
.................... }; 
....................  
....................  
.................... #define LCD_CS              pin_c0 
.................... #define LCD_RESET           pin_c1 
.................... #define LCD_RS              pin_a5 
.................... #define LCD_SCK             pin_c3 
.................... #define LCD_DATA            pin_c5 
.................... //#define _8_BIT_COLOR 
....................  
.................... #define CMD 0 
.................... #define DAT 1 
.................... int1 RS_old; 
....................  
.................... #ifdef _8_BIT_COLOR    // 0x00011100 
....................  
.................... #define GREEN       0x1C 
.................... #define DARK_GREEN  0x15 
.................... #define RED         0xE0 
.................... #define BLUE        0x1F     
.................... #define DARK_BLUE   0x03 
.................... #define YELLOW      0xFC 
.................... #define ORANGE      0xEC 
.................... #define VIOLET      0xE3 
.................... #define WHITE       0xFF 
.................... #define BLACK       0x00 
.................... #define GREY        0x6D 
....................  
.................... #else 
....................  
.................... #define    BLACK                0x0000  
.................... #define    WHITE                0xFFFF  
.................... #define    GRAY                 0xE79C 
.................... #define    GREEN                0x07E0  
.................... #define    BLUE                 0x001F  
.................... #define    RED                  0xF800  
.................... #define    SKY                  0x5d1c  
.................... #define    YELLOW               0xffe0  
.................... #define    MAGENTA              0xf81f 
.................... #define    CYAN                 0x07ff 
.................... #define    ORANGE               0xfca0  
.................... #define    PINK                 0xF97F 
.................... #define    BROWN                0x8200 
.................... #define    VIOLET               0x9199 
.................... #define    SILVER               0xa510 
.................... #define    GOLD                 0xa508 
.................... #define    BEGH                 0xf77b 
.................... #define    NAVY                 0x000F       
.................... #define    DARK_GREEN           0x03E0       
.................... #define    DARK_CYAN            0x03EF       
.................... #define    MAROON               0x7800       
.................... #define    PURPLE               0x780F       
.................... #define    OLIVE                0x7BE0       
.................... #define    LIGHT_GREY           0xC618       
.................... #define    DARK_GREY            0x7BEF 
.................... #endif 
....................  
.................... void LCD_init (void); 
.................... void Send_to_lcd (unsigned char RS, unsigned char data); 
.................... void SetArea (char x1, char x2, char y1, char y2); 
.................... void Put_Pixel (char x, char y, unsigned int color); 
.................... void LCD_FillScreen (long color); 
....................  
.................... //=============================================================== 
.................... //Функция записи команды/данных в LCD (RS==0 - команда, RS==1 - данные) 
.................... //=============================================================== 
.................... void Send_to_lcd (int1 RS, unsigned int data){ 
....................    output_bit(LCD_SCK,0);   
005E:  BCF    07.3
005F:  BCF    29.3
0060:  MOVF   29,W
0061:  BSF    03.5
0062:  MOVWF  07
....................    output_bit(LCD_DATA,0);   
0063:  BCF    03.5
0064:  BCF    07.5
0065:  BCF    29.5
0066:  MOVF   29,W
0067:  BSF    03.5
0068:  MOVWF  07
....................    if ((RS_old != RS) || (!RS_old && !RS)){  
0069:  MOVLW  00
006A:  BCF    03.5
006B:  BTFSC  28.0
006C:  MOVLW  01
006D:  SUBWF  52,W
006E:  BTFSS  03.2
006F:  GOTO   075
0070:  BTFSC  28.0
0071:  GOTO   08A
0072:  MOVF   52,F
0073:  BTFSS  03.2
0074:  GOTO   08A
....................       output_bit(LCD_CS,1);    
0075:  BSF    07.0
0076:  BCF    29.0
0077:  MOVF   29,W
0078:  BSF    03.5
0079:  MOVWF  07
....................       output_bit(LCD_RS, RS);    
007A:  BCF    03.5
007B:  MOVF   52,F
007C:  BTFSS  03.2
007D:  GOTO   080
007E:  BCF    05.5
007F:  GOTO   081
0080:  BSF    05.5
0081:  BSF    03.5
0082:  BCF    05.5
....................       output_bit(LCD_CS, 0);    
0083:  BCF    03.5
0084:  BCF    07.0
0085:  BCF    29.0
0086:  MOVF   29,W
0087:  BSF    03.5
0088:  MOVWF  07
0089:  BCF    03.5
....................    } 
....................    spi_write(data); 
008A:  MOVF   53,W
008B:  MOVWF  13
008C:  BSF    03.5
008D:  RRF    14,W
008E:  BTFSS  03.0
008F:  GOTO   08D
....................    RS_old=RS;    
0090:  BCF    03.5
0091:  BCF    28.0
0092:  BTFSC  52.0
0093:  BSF    28.0
.................... } 
0094:  RETURN
....................  
.................... void LCD_FillScreen (long color){ 
....................    unsigned long x;  
....................    SetArea( 0, 127, 0, 127 );   //Область всего экрана  
*
0135:  CLRF   4E
0136:  MOVLW  7F
0137:  MOVWF  4F
0138:  CLRF   50
0139:  MOVWF  51
....................    output_bit(LCD_RS,1);   
*
015A:  BSF    05.5
015B:  BSF    03.5
015C:  BCF    05.5
....................    for (x = 0; x < 16384; x++){  // 16384 - это 128 * 128 
015D:  BCF    03.5
015E:  CLRF   4D
015F:  CLRF   4C
0160:  MOVF   4D,W
0161:  SUBLW  3F
0162:  BTFSS  03.0
0163:  GOTO   175
....................       #ifdef _8_BIT_COLOR   //(8-ми битовая цветовая палитра (256 цветов)) 
....................       Send_to_lcd( DAT, color ); //Данные - задаём цвет пикселя  
....................       #else         //(16-ти битовая цветовая палитра (65536 цветов)) 
....................        Send_to_lcd( DAT, (color >> 8) );  
0164:  MOVF   4B,W
0165:  MOVWF  4E
0166:  CLRF   4F
0167:  MOVLW  01
0168:  MOVWF  52
0169:  MOVF   4B,W
016A:  MOVWF  53
016B:  CALL   05E
....................        Send_to_lcd( DAT, color ); 
016C:  MOVLW  01
016D:  MOVWF  52
016E:  MOVF   4A,W
016F:  MOVWF  53
0170:  CALL   05E
....................       #endif 
....................    }                  
0171:  INCF   4C,F
0172:  BTFSC  03.2
0173:  INCF   4D,F
0174:  GOTO   160
.................... } 
0175:  RETURN
....................  
.................... void LCD_init(void){ 
....................    output_bit(LCD_CS,0); 
*
0095:  BCF    07.0
0096:  BCF    29.0
0097:  MOVF   29,W
0098:  BSF    03.5
0099:  MOVWF  07
....................    output_bit(LCD_DATA,0); 
009A:  BCF    03.5
009B:  BCF    07.5
009C:  BCF    29.5
009D:  MOVF   29,W
009E:  BSF    03.5
009F:  MOVWF  07
....................    output_bit(LCD_SCK,1);    
00A0:  BCF    03.5
00A1:  BSF    07.3
00A2:  BCF    29.3
00A3:  MOVF   29,W
00A4:  BSF    03.5
00A5:  MOVWF  07
....................    output_bit(LCD_RESET,1); 
00A6:  BCF    03.5
00A7:  BSF    07.1
00A8:  BCF    29.1
00A9:  MOVF   29,W
00AA:  BSF    03.5
00AB:  MOVWF  07
....................    output_bit(LCD_RESET,0); 
00AC:  BCF    03.5
00AD:  BCF    07.1
00AE:  BCF    29.1
00AF:  MOVF   29,W
00B0:  BSF    03.5
00B1:  MOVWF  07
....................    delay_ms(50); 
00B2:  MOVLW  32
00B3:  BCF    03.5
00B4:  MOVWF  4B
00B5:  CALL   049
....................    output_bit(LCD_RESET,1);    
00B6:  BSF    07.1
00B7:  BCF    29.1
00B8:  MOVF   29,W
00B9:  BSF    03.5
00BA:  MOVWF  07
....................  
....................    output_bit(LCD_SCK,1);     
00BB:  BCF    03.5
00BC:  BSF    07.3
00BD:  BCF    29.3
00BE:  MOVF   29,W
00BF:  BSF    03.5
00C0:  MOVWF  07
....................  
....................    output_bit(LCD_DATA,1);     
00C1:  BCF    03.5
00C2:  BSF    07.5
00C3:  BCF    29.5
00C4:  MOVF   29,W
00C5:  BSF    03.5
00C6:  MOVWF  07
....................  
....................    output_bit(LCD_SCK,1);     
00C7:  BCF    03.5
00C8:  BSF    07.3
00C9:  BCF    29.3
00CA:  MOVF   29,W
00CB:  BSF    03.5
00CC:  MOVWF  07
....................    delay_ms(10); 
00CD:  MOVLW  0A
00CE:  BCF    03.5
00CF:  MOVWF  4B
00D0:  CALL   049
....................     
....................    //------------------------------------------------- 
....................  
....................    Send_to_lcd(CMD, 0x01);   //Программный сброс 
00D1:  CLRF   52
00D2:  MOVLW  01
00D3:  MOVWF  53
00D4:  CALL   05E
....................    Send_to_lcd(CMD, 0x25);   //Wtite Contrast 
00D5:  CLRF   52
00D6:  MOVLW  25
00D7:  MOVWF  53
00D8:  CALL   05E
....................    Send_to_lcd(DAT, 46);     
00D9:  MOVLW  01
00DA:  MOVWF  52
00DB:  MOVLW  2E
00DC:  MOVWF  53
00DD:  CALL   05E
....................    Send_to_lcd(CMD, 0x11);   //Выход из спящего режима 
00DE:  CLRF   52
00DF:  MOVLW  11
00E0:  MOVWF  53
00E1:  CALL   05E
....................    //Send_to_lcd(CMD, 0x03); // Booster on 
....................    delay_ms(10); 
00E2:  MOVLW  0A
00E3:  MOVWF  4B
00E4:  CALL   049
....................    Send_to_lcd(CMD, 0x20);   //Display Inversion Off 
00E5:  CLRF   52
00E6:  MOVLW  20
00E7:  MOVWF  53
00E8:  CALL   05E
....................    Send_to_lcd(CMD, 0x38);   //Idle Mod Off  On: 0x39 
00E9:  CLRF   52
00EA:  MOVLW  38
00EB:  MOVWF  53
00EC:  CALL   05E
....................    Send_to_lcd(CMD, 0x29);   //Включение дисплея 
00ED:  CLRF   52
00EE:  MOVLW  29
00EF:  MOVWF  53
00F0:  CALL   05E
....................    Send_to_lcd(CMD, 0x13);   //Normal Mod On 
00F1:  CLRF   52
00F2:  MOVLW  13
00F3:  MOVWF  53
00F4:  CALL   05E
....................    Send_to_lcd(CMD, 0x36);   //Memory Access Control 
00F5:  CLRF   52
00F6:  MOVLW  36
00F7:  MOVWF  53
00F8:  CALL   05E
....................    Send_to_lcd(DAT, 0x00); 
00F9:  MOVLW  01
00FA:  MOVWF  52
00FB:  CLRF   53
00FC:  CALL   05E
....................    Send_to_lcd(CMD, 0x3a);   //Установка цветовой палитры 
00FD:  CLRF   52
00FE:  MOVLW  3A
00FF:  MOVWF  53
0100:  CALL   05E
....................     
....................    #ifdef _8_BIT_COLOR 
....................       Send_to_lcd(DAT, 0x02); //Байт на пиксель 256 цветов 
....................    #else 
....................       Send_to_lcd(DAT, 0x05); //Два байта на пиксель 65536 цветов 
0101:  MOVLW  01
0102:  MOVWF  52
0103:  MOVLW  05
0104:  MOVWF  53
0105:  CALL   05E
....................    #endif 
....................    Send_to_lcd(CMD, 0x2A);    //X_Adress Area 
0106:  CLRF   52
0107:  MOVLW  2A
0108:  MOVWF  53
0109:  CALL   05E
....................    Send_to_lcd(DAT, 0x00); 
010A:  MOVLW  01
010B:  MOVWF  52
010C:  CLRF   53
010D:  CALL   05E
....................    Send_to_lcd(DAT, 0x7F); 
010E:  MOVLW  01
010F:  MOVWF  52
0110:  MOVLW  7F
0111:  MOVWF  53
0112:  CALL   05E
....................    Send_to_lcd(CMD, 0xB4);     //Frame Frequency Select 
0113:  CLRF   52
0114:  MOVLW  B4
0115:  MOVWF  53
0116:  CALL   05E
....................    //Send_to_lcd(DAT, 0x03); 
....................    Send_to_lcd(DAT, 0x08); 
0117:  MOVLW  01
0118:  MOVWF  52
0119:  MOVLW  08
011A:  MOVWF  53
011B:  CALL   05E
....................    /*Send_to_lcd(DAT, 0x0B); 
....................    Send_to_lcd(DAT, 0x0E);*/ 
....................    Send_to_lcd(CMD, 0xBA); //Display Control 
011C:  CLRF   52
011D:  MOVLW  BA
011E:  MOVWF  53
011F:  CALL   05E
....................    //Send_to_lcd(DAT, 0x07); 
....................    Send_to_lcd(DAT, 0x0D); 
0120:  MOVLW  01
0121:  MOVWF  52
0122:  MOVLW  0D
0123:  MOVWF  53
0124:  CALL   05E
....................    Send_to_lcd(CMD, 0x2B); //Page Adress Set 
0125:  CLRF   52
0126:  MOVLW  2B
0127:  MOVWF  53
0128:  CALL   05E
....................    Send_to_lcd(DAT, 0x00); 
0129:  MOVLW  01
012A:  MOVWF  52
012B:  CLRF   53
012C:  CALL   05E
....................    Send_to_lcd(DAT, 0x7F);    
012D:  MOVLW  01
012E:  MOVWF  52
012F:  MOVLW  7F
0130:  MOVWF  53
0131:  CALL   05E
....................    } 
0132:  BCF    0A.3
0133:  BCF    0A.4
0134:  GOTO   1AC (RETURN)
....................  
.................... //=============================================================== 
.................... //              Задание прямоугольной области экрана 
.................... //=============================================================== 
.................... void SetArea(char x1, char x2, char y1, char y2){ 
....................  Send_to_lcd( CMD, 0x2A );  //задаем область по X 
*
013A:  CLRF   52
013B:  MOVLW  2A
013C:  MOVWF  53
013D:  CALL   05E
....................  Send_to_lcd( DAT, x1 );    //начальная 
013E:  MOVLW  01
013F:  MOVWF  52
0140:  MOVF   4E,W
0141:  MOVWF  53
0142:  CALL   05E
....................  Send_to_lcd( DAT, x2 );    //конечная 
0143:  MOVLW  01
0144:  MOVWF  52
0145:  MOVF   4F,W
0146:  MOVWF  53
0147:  CALL   05E
....................  
....................  Send_to_lcd( CMD, 0x2B );  //задаем область по Y 
0148:  CLRF   52
0149:  MOVLW  2B
014A:  MOVWF  53
014B:  CALL   05E
....................  Send_to_lcd( DAT, y1 );    //начальная  
014C:  MOVLW  01
014D:  MOVWF  52
014E:  MOVF   50,W
014F:  MOVWF  53
0150:  CALL   05E
....................  Send_to_lcd( DAT, y2 );    //конечная 
0151:  MOVLW  01
0152:  MOVWF  52
0153:  MOVF   51,W
0154:  MOVWF  53
0155:  CALL   05E
....................  
....................  Send_to_lcd( CMD, 0x2C );  //отправляем команду на начало записи в память и начинаем посылать данные 
0156:  CLRF   52
0157:  MOVLW  2C
0158:  MOVWF  53
0159:  CALL   05E
.................... }  
.................... void drawBox(int16 Color, int X, int Y, int Width, int Height){    
....................    SetArea(X, Y, Width, Height); 
....................    int i, j, Line; 
....................   
....................    for (i = 0; i < Width; i++){ 
....................       Line = 0xff; 
....................       for (j = 0; j < Height; j++) 
....................          Send_to_lcd( DAT, (color >> 8) );  
....................          Send_to_lcd( DAT, color ); 
....................    }  
.................... } 
....................  
.................... //=============================================================== 
.................... //                          Рисуем точку  
.................... //===============================================================  
.................... void Put_Pixel (char x, char y, unsigned long color){ 
....................  signed char i; 
....................  SetArea( x, x, y, y );  
....................  //LCD_RS = 1;   
....................    output_bit(LCD_RS,1);   
....................   
....................  #ifdef _8_BIT_COLOR   //(8-ми битовая цветовая палитра (256 цветов)) 
....................    Send_to_lcd( DAT, color ); //Данные - задаём цвет пикселя  
....................  #else                 //(16-ти битовая цветовая палитра (65536 цветов)) 
....................    Send_to_lcd( DAT, (color >> 8) );  
....................    Send_to_lcd( DAT, color ); 
....................  #endif 
.................... }   
....................                     
.................... //=============================================================== 
.................... //           Функция прорисовки символа на дисплее 
.................... //=============================================================== 
.................... void Send_Symbol (unsigned char symbol, char x, char y, int t_color, int b_color, char zoom_width, char zoom_height)  
.................... { 
....................  unsigned char temp_symbol, a, b, zw, zh, mask;  
....................    
....................  if (symbol>127) symbol-=64;    //Убираем отсутствующую часть таблицы ASCII 
....................  for ( a = 0; a < 5; a++) //Перебираю 5 байт, составляющих символ 
....................  { 
....................     temp_symbol = font_5x8[symbol-32][a]; 
....................     zw = 0;  
....................     while(zw != zoom_width) //Вывод байта выполняется zw раз  
....................     {     
....................         mask=0x01;   
....................         
....................         SetArea( x+zw, x+zw, y, y+(zoom_height*8)-1 );                         
....................          
....................         //LCD_RS = 1; //Передаются данные      
....................          output_bit(LCD_RS,1);          
....................         for ( b = 0; b < 8; b++ ) //Цикл перебирания 8 бит байта 
....................         {          
....................             zh = zoom_height; //в zoom_height раз увеличится высота символа 
....................             while(zh != 0) //Вывод пикселя выполняется zh раз 
....................             { 
....................                 if (temp_symbol&mask)  
....................                 { 
....................                     #ifdef _8_BIT_COLOR   //(8-ми битовая цветовая палитра (256 цветов)) 
....................                     Send_to_lcd( DAT, t_color ); //Данные - задаём цвет пикселя  
....................                     #else                 //(16-ти битовая цветовая палитра (65536 цветов)) 
....................                     Send_to_lcd( DAT, (t_color >> 8) ); Send_to_lcd( DAT, t_color ); 
....................                     #endif 
....................                 } 
....................                 else  
....................                { 
....................                     #ifdef _8_BIT_COLOR   //(8-ми битовая цветовая палитра (256 цветов)) 
....................                     Send_to_lcd( DAT, b_color ); //Данные - задаём цвет пикселя  
....................                     #else                 //(16-ти битовая цветовая палитра (65536 цветов)) 
....................                     Send_to_lcd( DAT, (b_color >> 8) ); Send_to_lcd( DAT, b_color ); 
....................                     #endif 
....................                 } 
....................                 zh--; 
....................             } 
....................             mask<<=1; //Смещаю содержимое mask на 1 бит влево;     
....................         } 
....................         zw++; 
....................     } 
....................   
....................    x=x+zoom_width; //Получить адрес начального пикселя по оси x для вывода очередного байта              
....................  } 
.................... }   
....................  
.................... //=============================================================== 
.................... // Функция вывода одного символа ASCII-кода (из файла Symbols.h) 
.................... //=============================================================== 
.................... void LCD_Putchar(char symbol, char x, char y, int t_color, int b_color, char zoom_width, char zoom_height, int rot) 
.................... { 
....................     unsigned char m; 
....................     if(zoom_width == 0)   zoom_width = 1; 
....................     if(zoom_height == 0)  zoom_height = 1; 
....................     switch (rot) 
....................     { 
....................         case 0:  //Начальный адрес осей Х и У - левый верхний угол дисплея    
....................         Send_Symbol( symbol, x, y, t_color, b_color, zoom_width, zoom_height); 
....................         break; 
....................         //================================ 
....................         case 90:         
....................         Send_to_lcd(CMD, 0x36);  
....................         Send_to_lcd(DAT, 0x60); //Начальный адрес осей Х и У - правый верхний угол дисплея  
....................         Send_Symbol( symbol, x, y, t_color, b_color, zoom_width, zoom_height); 
....................         Send_to_lcd(CMD, 0x36);  
....................         Send_to_lcd(DAT, 0x00); 
....................         break; 
....................         //================================ 
....................         case 180:        
....................         Send_to_lcd(CMD, 0x36);  
....................         Send_to_lcd(DAT, 0xC0); //Начальный адрес осей Х и У - правый нижний угол дисплея  
....................         Send_Symbol( symbol, x, y, t_color, b_color, zoom_width, zoom_height); 
....................         Send_to_lcd(CMD, 0x36);  
....................         Send_to_lcd(DAT, 0x00); 
....................         break; 
....................         //================================ 
....................         case 270:        
....................         Send_to_lcd(CMD, 0x36);  
....................         Send_to_lcd(DAT, 0xA0); //Начальный адрес осей Х и У - левый нижний угол дисплея   
....................         Send_Symbol( symbol, x, y, t_color, b_color, zoom_width, zoom_height); 
....................         Send_to_lcd(CMD, 0x36);  
....................         Send_to_lcd(DAT, 0x00); 
....................         break; 
....................         //================================ 
....................         default: 
....................         Send_to_lcd(CMD, 0x36);  
....................         Send_to_lcd(DAT, 0x00); //Начальный адрес осей Х и У - левый верхний угол дисплея   
....................         Send_Symbol( symbol, x, y, t_color, b_color, zoom_width, zoom_height); 
....................         Send_to_lcd(CMD, 0x36);  
....................         Send_to_lcd(DAT, 0x00); 
....................         //=================================     
....................     };   
.................... } 
....................  
.................... //=============================================================== 
.................... //          Функция вывода строки, расположенной в ram  
.................... //=============================================================== 
.................... void LCD_Puts(char *str, int x, int y,  int t_color, int b_color, char zoom_width, char zoom_height, int rot) 
.................... { 
....................  unsigned char i=0; 
....................                
....................  if(zoom_width == 0)   zoom_width = 1; 
....................  if(zoom_height == 0)  zoom_height = 1; 
....................     
....................  while (str[i]) //x и y - адрес пикселя начальной позиции; с увеличением переменной i адрес вывода очередного символа смещается на i*6 (чем организуются столбцы дисплея)   
....................  {       
....................   LCD_Putchar(str[i], x+(i*6*zoom_width), y, t_color, b_color, zoom_width, zoom_height, rot); 
....................   i++; 
....................  }   
.................... } 
....................  
....................  
.................... //=============================================================== 
.................... //     Функция прорисовки символа на дисплее без цвета фона 
.................... //=============================================================== 
.................... void Send_Symbol_Shadow (unsigned char symbol, char x, char y, int t_color, char zoom_width, char zoom_height)  
.................... { 
....................  unsigned char temp_symbol, a, b, zw, zh, mask;  
....................  char m, n; 
....................  m=x;  
....................  n=y; 
....................  if (symbol>127) symbol-=64;    //Убираем отсутствующую часть таблицы ASCII 
....................  for ( a = 0; a < 5; a++) //Перебираю 5 байт, составляющих символ 
....................  {   
....................   temp_symbol = font_5x8[symbol-32][a]; 
....................   zw = 0;  
....................   while(zw != zoom_width) //Вывод байта выполняется zw раз  
....................   {     
....................    n=y;       
....................     
....................    mask=0x01;      
....................    for ( b = 0; b < 8; b++ ) //Цикл перебирания 8 бит байта 
....................    {          
....................     zh = 0; //в zoom_height раз увеличится высота символа 
....................     while(zh != zoom_height) //Вывод пикселя выполняется zh раз 
....................     { 
....................      
....................       if (temp_symbol&mask)  
....................       { 
....................        Put_Pixel (m+zw, n+zh, t_color); 
....................       } 
....................       
....................      zh++; 
....................     } 
....................     mask<<=1; //Смещаю содержимое mask на 1 бит влево; 
....................     n=n+zoom_height;                    
....................    } 
....................    zw++;    
....................   } 
....................    m=m+zoom_width;            
....................  } 
.................... }  
....................  
.................... //=============================================================== 
.................... // Функция вывода одного символа ASCII-кода без цвета фона 
.................... //=============================================================== 
.................... void LCD_Putchar_Shadow (char symbol, char x, char y, int t_color, char zoom_width, char zoom_height, int rot){ 
....................  unsigned char m; 
....................  if(zoom_width == 0)   zoom_width = 1; 
....................  if(zoom_height == 0)  zoom_height = 1; 
....................  switch (rot) 
....................  { 
....................   case 0:  //Начальный адрес осей Х и У - левый верхний угол дисплея    
....................   Send_Symbol_Shadow( symbol, x, y, t_color, zoom_width, zoom_height); 
....................   break; 
....................   //================================ 
....................   case 90:   
....................   Send_to_lcd(CMD, 0x36);  
....................   Send_to_lcd(DAT, 0x60); //Начальный адрес осей Х и У - правый верхний угол дисплея  
....................   Send_Symbol_Shadow( symbol, x, y, t_color, zoom_width, zoom_height); 
....................   Send_to_lcd(CMD, 0x36);  
....................   Send_to_lcd(DAT, 0x00); 
....................   break; 
....................   //================================ 
....................   case 180:        
....................   Send_to_lcd(CMD, 0x36);  
....................   Send_to_lcd(DAT, 0xC0); //Начальный адрес осей Х и У - правый нижний угол дисплея  
....................   Send_Symbol_Shadow( symbol, x, y, t_color, zoom_width, zoom_height); 
....................   Send_to_lcd(CMD, 0x36);  
....................   Send_to_lcd(DAT, 0x00); 
....................   break; 
....................   //================================ 
....................   case 270:  
....................   Send_to_lcd(CMD, 0x36);  
....................   Send_to_lcd(DAT, 0xA0); //Начальный адрес осей Х и У - левый нижний угол дисплея   
....................   Send_Symbol_Shadow( symbol, x, y, t_color, zoom_width, zoom_height); 
....................   Send_to_lcd(CMD, 0x36);  
....................   Send_to_lcd(DAT, 0x00); 
....................   break; 
....................   //================================ 
....................   default: 
....................   Send_to_lcd(CMD, 0x36);  
....................   Send_to_lcd(DAT, 0x00); //Начальный адрес осей Х и У - левый верхний угол дисплея   
....................   Send_Symbol_Shadow( symbol, x, y, t_color, zoom_width, zoom_height); 
....................   Send_to_lcd(CMD, 0x36);  
....................   Send_to_lcd(DAT, 0x00); 
....................   //=================================     
....................  };   
.................... } 
....................  
.................... //=============================================================== 
.................... //   Функция вывода строки, расположенной в ram без цвета фона  
.................... //=============================================================== 
.................... void LCD_Puts_Shadow(char *str, int x, int y,  int t_color, char zoom_width, char zoom_height, int rot){ 
....................  unsigned char i=0; 
....................                      
....................  if(zoom_width == 0)   zoom_width = 1; 
....................  if(zoom_height == 0)  zoom_height = 1; 
....................     
....................  while (str[i]) //x и y - адрес пикселя начальной позиции; с увеличением переменной i адрес вывода очередного символа смещается на i*6 (чем организуются столбцы дисплея)   
....................  {       
....................   LCD_Putchar_Shadow(str[i], x+(i*6*zoom_width), y, t_color, zoom_width, zoom_height, rot); 
....................   i++; 
....................  }   
.................... } 
.................... #ifdef _GEOMETRICAL 
.................... //=============================================================== 
.................... //                      НАРИСОВАТЬ ЛИНИЮ 
.................... //=============================================================== 
.................... void LCD_DrawLine (char x1, char y1, char x2, char y2, int color) 
.................... {  
....................  short  x, y, d, dx, dy, i, i1, i2, kx, ky; 
....................  signed char flag; 
....................  
....................  dx = x2 - x1; 
....................  dy = y2 - y1; 
....................  if (dx == 0 && dy == 0) Put_Pixel(x1, y1, color);  //Точка 
....................  else      //Линия 
....................  { 
....................   kx = 1; 
....................   ky = 1; 
....................   if( dx < 0 ) 
....................   {  
....................    dx = -dx;  
....................    kx = -1;  
....................   } 
....................   else 
....................   if(dx == 0) kx = 0; 
....................   if(dy < 0) 
....................   {  
....................    dy = -dy;  
....................    ky = -1;  
....................   } 
....................   if(dx < dy) 
....................   {  
....................    flag = 0;  
....................    d = dx;  
....................    dx = dy;  
....................    dy = d;  
....................   } 
....................   else flag = 1; 
....................   i1 = dy + dy;  
....................   d = i1 - dx;  
....................   i2 = d - dx; 
....................   x = x1;  
....................   y = y1; 
....................  
....................   for(i=0; i < dx; i++) 
....................   { 
....................    Put_Pixel(x, y, color); 
....................    if(flag) x += kx; 
....................    else y += ky; 
....................    if( d < 0 ) d += i1; 
....................    else 
....................    { 
....................     d += i2; 
....................     if(flag) y += ky; 
....................     else x += kx; 
....................    } 
....................   } 
....................   Put_Pixel(x, y, color); 
....................  } 
.................... }    
....................    
.................... //=============================================================== 
.................... //                     НАРИСОВАТЬ РАМКУ                 
.................... //=============================================================== 
.................... void LCD_DrawRect (char x1, char y1, char width, char height, char size, int color) 
.................... { 
....................  unsigned int i; 
....................  char x2=x1+(width-1), y2=y1+(height-1); //Конечные размеры рамки по осям х и у 
....................  for( i=1; i<=size; i++)   // size - толщина рамки 
....................  { 
....................   LCD_DrawLine(x1, y1, x1, y2, color); 
....................   LCD_DrawLine(x2, y1, x2, y2, color); 
....................   LCD_DrawLine(x1, y1, x2, y1, color); 
....................   LCD_DrawLine(x1, y2, x2, y2, color); 
....................   x1++; // Увеличиваю толщину рамки, если это задано 
....................   y1++; 
....................   x2--; 
....................   y2--; 
....................  } 
.................... } 
....................  
.................... //=============================================================== 
.................... //              ЗАПОЛНИТЬ ПРЯМОУГОЛЬНИК ЦВЕТОМ COLOR 
.................... //=============================================================== 
.................... void LCD_FillRect (char x1, char y1, char width, char height, int color) 
.................... { 
....................  unsigned int x, y; 
....................         
....................  SetArea( x1, x1+(width-1), y1, y1+(height-1) ); 
....................  LCD_RS = 1; 
....................   
....................  y = width * height;           //Количество пикселей в прямоугольнике 
....................  for (x = 0; x < y; x++)  
....................  {    
....................   #ifdef _8_BIT_COLOR   //(8-ми битовая цветовая палитра (256 цветов)) 
....................   Send_to_lcd( DAT, color ); //Данные - задаём цвет пикселя  
....................   #else         //(16-ти битовая цветовая палитра (65536 цветов)) 
....................   Send_to_lcd( DAT, (color >> 8) ); Send_to_lcd( DAT, color ); 
....................   #endif 
....................  }    
.................... }   
....................   
.................... //=============================================================== 
.................... //                  НАРИСОВАТЬ ОКРУЖНОСТЬ 
.................... //=============================================================== 
.................... void LCD_DrawCircle (char xcenter, char ycenter, char rad, int color) 
.................... { 
....................  signed char tswitch, x1=0, y1;  
....................  char d; 
....................  
....................  d = ycenter - xcenter; 
....................  y1 = rad; 
....................  tswitch = 3 - 2 * rad; 
....................  while (x1 <= y1)  
....................  { 
....................   Put_Pixel(xcenter + x1, ycenter + y1, color);  
....................   Put_Pixel(xcenter + x1, ycenter - y1, color); 
....................   Put_Pixel(xcenter - x1, ycenter + y1, color);    
....................   Put_Pixel(xcenter - x1, ycenter - y1, color); 
....................   Put_Pixel(ycenter + y1 - d, ycenter + x1, color);  
....................   Put_Pixel(ycenter + y1 - d, ycenter - x1, color); 
....................   Put_Pixel(ycenter - y1 - d, ycenter + x1, color); 
....................   Put_Pixel(ycenter - y1 - d, ycenter - x1, color); 
....................  
....................   if (tswitch < 0) tswitch += (4 * x1 + 6); 
....................   else  
....................   { 
....................    tswitch += (4 * (x1 - y1) + 10); 
....................    y1--; 
....................   } 
....................   x1++; 
....................  } 
.................... }     
....................  
.................... //=============================================================== 
.................... //                 ЗАПОЛНИТЬ КРУГ ЦВЕТОМ COLOR 
.................... //=============================================================== 
.................... void LCD_FillCircle (char xcenter, char ycenter, char rad, int color) 
.................... { 
....................  signed int x1=0, y1, tswitch;  
....................  y1 = rad; 
....................  tswitch = 1 - rad; 
....................  
....................  do 
....................  { 
....................   LCD_DrawLine(xcenter-x1, ycenter+y1, xcenter+x1, ycenter+y1, color); 
....................   LCD_DrawLine(xcenter-x1, ycenter-y1, xcenter+x1, ycenter-y1, color); 
....................   LCD_DrawLine(xcenter-y1, ycenter+x1, xcenter+y1, ycenter+x1, color); 
....................   LCD_DrawLine(xcenter-y1, ycenter-x1, xcenter+y1, ycenter-x1, color); 
....................  
....................   if(tswitch < 0) 
....................   tswitch+= 3 + 2*x1++; 
....................   else 
....................   tswitch+= 5 + 2*(x1++ - y1--); 
....................  } while(x1 <= y1); 
.................... } 
....................  
.................... //=============================================================== 
.................... //                     НАРИСОВАТЬ ТРЕУГОЛЬНИК 
.................... //=============================================================== 
.................... void LCD_DrawTriangle(char x1, char y1, char x2, char y2, char x3, char y3, int color) 
.................... { 
....................  LCD_DrawLine(x1, y1, x2, y2, color); 
....................  LCD_DrawLine(x3, y3, x1, y1, color); 
....................  LCD_DrawLine(x3, y3, x2, y2, color);   
.................... } 
....................  
.................... //=============================================================== 
.................... //              ЗАПОЛНИТЬ ТРЕУГОЛЬНИК ЦВЕТОМ COLOR 
.................... //=============================================================== 
.................... void LCD_FillTriangle(char x1, char y1, char x2, char y2, char x3, char y3, int color) 
.................... { 
....................  LCD_FillTriangleA(x1, y1, x2, y2, x3, y3, color); 
....................  LCD_FillTriangleA(x3, y3, x1, y1, x2, y2, color); 
....................  LCD_FillTriangleA(x3, y3, x2, y2, x1, y1, color); 
.................... }     
....................  
.................... //=============================================================== 
.................... void LCD_FillTriangleA(char x1, char y1, char x2, char y2, char x3, char y3, int color) 
.................... { 
....................  signed long x, y, addx, dx, dy; 
....................  signed long P; 
....................  int i; 
....................  long a1,a2,b1,b2; 
....................  if(y1>y2)  {b1=y2; b2=y1; a1=x2; a2=x1;} 
....................  else       {b1=y1; b2=y2; a1=x1; a2=x2;} 
....................  dx = a2 -a1; 
....................  dy = b2 - b1; 
....................  if(dx<0)dx=-dx; 
....................  if(dy<0)dy=-dy; 
....................  x = a1; 
....................  y = b1; 
....................     
....................  if(a1 > a2)    addx = -1; 
....................  else           addx = 1; 
....................     
....................  if(dx >= dy) 
....................  { 
....................   P = 2*dy - dx; 
....................   for(i=0; i<=dx; ++i) 
....................   { 
....................    LCD_DrawLine((int)x, (int)y, x3, y3, color); 
....................    if(P < 0) 
....................    { 
....................     P += 2*dy; 
....................     x += addx; 
....................    } 
....................    else 
....................    { 
....................     P += 2*dy - 2*dx; 
....................     x += addx; 
....................     y ++; 
....................    } 
....................   } 
....................  } 
....................  else 
....................  { 
....................   P = 2*dx - dy; 
....................   for(i=0; i<=dy; ++i) 
....................   { 
....................    LCD_DrawLine((int)x, (int)y, x3, y3, color); 
....................    if(P < 0) 
....................    { 
....................     P += 2*dx; 
....................     y ++; 
....................    } 
....................    else 
....................    { 
....................     P += 2*dx - 2*dy; 
....................     x += addx; 
....................     y ++; 
....................    } 
....................   } 
....................  } 
.................... } 
....................  
.................... //=============================================================== 
.................... #endif 
....................  
....................  
....................      
....................  
....................  
.................... #define LED_STATUS   pin_a1 
....................  
.................... #define SPI_MODE_0  (SPI_L_TO_H | SPI_XMIT_L_TO_H) 
.................... #define SPI_MODE_1  (SPI_L_TO_H) 
.................... #define SPI_MODE_2  (SPI_H_TO_L) 
.................... #define SPI_MODE_3  (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... int tempo; 
.................... char text[30]; 
....................  
.................... #int_TIMER0 
.................... void  TIMER0_isr(void){ 
....................    tempo++; 
*
0033:  INCF   2A,F
....................    if(tempo == 70){   //  46 * 21,8ms =~ 1002,8ms ou 1,002 segundos  
0034:  MOVF   2A,W
0035:  SUBLW  46
0036:  BTFSS  03.2
0037:  GOTO   03E
....................       tempo=0; 
0038:  CLRF   2A
....................       output_toggle(LED_STATUS); 
0039:  BSF    03.5
003A:  BCF    05.1
003B:  MOVLW  02
003C:  BCF    03.5
003D:  XORWF  05,F
....................    } 
....................    output_toggle(pin_c4);    
003E:  BCF    29.4
003F:  MOVF   29,W
0040:  BSF    03.5
0041:  MOVWF  07
0042:  MOVLW  10
0043:  BCF    03.5
0044:  XORWF  07,F
.................... } 
0045:  BCF    0B.2
0046:  BCF    0A.3
0047:  BCF    0A.4
0048:  GOTO   01D
.................... void main(void){ 
*
0176:  CLRF   04
0177:  BCF    03.7
0178:  MOVLW  1F
0179:  ANDWF  03,F
017A:  MOVLW  FF
017B:  MOVWF  29
017C:  BSF    03.5
017D:  BSF    1F.0
017E:  BSF    1F.1
017F:  BSF    1F.2
0180:  BCF    1F.3
....................    int i; 
....................    setup_spi(SPI_MASTER | SPI_MODE_0 | SPI_CLK_DIV_4 );    
0181:  BCF    03.5
0182:  BCF    14.5
0183:  BCF    29.5
0184:  MOVF   29,W
0185:  BSF    03.5
0186:  MOVWF  07
0187:  BCF    03.5
0188:  BSF    29.4
0189:  MOVF   29,W
018A:  BSF    03.5
018B:  MOVWF  07
018C:  BCF    03.5
018D:  BCF    29.3
018E:  MOVF   29,W
018F:  BSF    03.5
0190:  MOVWF  07
0191:  MOVLW  20
0192:  BCF    03.5
0193:  MOVWF  14
0194:  MOVLW  40
0195:  BSF    03.5
0196:  MOVWF  14
....................    //setup_spi(SPI_SS_DISABLED); 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_32|RTCC_8_bit);  //RTCC_DIV_256    //21.8 ms overflow 
0197:  MOVF   01,W
0198:  ANDLW  C0
0199:  IORLW  04
019A:  MOVWF  01
....................    setup_adc_ports(NO_ANALOGS); 
019B:  BSF    1F.0
019C:  BSF    1F.1
019D:  BSF    1F.2
019E:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
019F:  BCF    03.5
01A0:  BCF    1F.0
....................    enable_interrupts(INT_TIMER0); 
01A1:  BSF    0B.5
....................    enable_interrupts(GLOBAL);    
01A2:  MOVLW  C0
01A3:  IORWF  0B,F
....................     
....................    delay_ms(1000); 
01A4:  MOVLW  04
01A5:  MOVWF  4A
01A6:  MOVLW  FA
01A7:  MOVWF  4B
01A8:  CALL   049
01A9:  DECFSZ 4A,F
01AA:  GOTO   1A6
....................    LCD_init(); 
01AB:  GOTO   095
....................    LCD_FillScreen(RED);   // 0bRRRGGGBB 
01AC:  MOVLW  F8
01AD:  MOVWF  4B
01AE:  CLRF   4A
01AF:  CALL   135
....................    delay_ms(1000); 
01B0:  MOVLW  04
01B1:  MOVWF  4A
01B2:  MOVLW  FA
01B3:  MOVWF  4B
01B4:  CALL   049
01B5:  DECFSZ 4A,F
01B6:  GOTO   1B2
....................    LCD_FillScreen(GREEN);   // 0bRRRGGGBB 
01B7:  MOVLW  07
01B8:  MOVWF  4B
01B9:  MOVLW  E0
01BA:  MOVWF  4A
01BB:  CALL   135
....................    delay_ms(1000); 
01BC:  MOVLW  04
01BD:  MOVWF  4A
01BE:  MOVLW  FA
01BF:  MOVWF  4B
01C0:  CALL   049
01C1:  DECFSZ 4A,F
01C2:  GOTO   1BE
....................    LCD_FillScreen(BLUE);   // 0bRRRGGGBB 
01C3:  CLRF   4B
01C4:  MOVLW  1F
01C5:  MOVWF  4A
01C6:  CALL   135
....................    delay_ms(1000); 
01C7:  MOVLW  04
01C8:  MOVWF  4A
01C9:  MOVLW  FA
01CA:  MOVWF  4B
01CB:  CALL   049
01CC:  DECFSZ 4A,F
01CD:  GOTO   1C9
....................    /*LCD_Putchar('M', 30, 30, WHITE, BLUE, 1, 1, 0); 
....................    LCD_Putchar('a', 37, 30, WHITE, RED, 1, 1, 0); 
....................    LCD_Putchar('r', 43, 30, WHITE, BLACK, 1, 1, 0);    
....................    LCD_Putchar('l', 50, 30, WHITE, BLACK, 1, 1, 0);*/ 
....................    /*LCD_FillScreen(WHITE);   // 0bRRRGGGBB 
....................    delay_ms(1000); 
....................    Put_Pixel(10,10, GREEN); 
....................    delay_ms(500); 
....................    LCD_Putchar('M', 30, 30, WHITE, BLACK, 1, 1, 1); */   
....................    while(true){} 
01CE:  GOTO   1CE
.................... } 
....................  
.................... //--------------------------------------------------------------------------------- 
01CF:  SLEEP

Configuration Fuses:
   Word  1: 3D3A   HS NOWDT NOPUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
