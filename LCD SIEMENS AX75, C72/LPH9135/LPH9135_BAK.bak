//-Библиотека дисплея Siemens А31, C72, АХ72, АХ75, С76-
//           Зеленый текстолит LPH9135
//              128х128 пикселей
//                    v 1.0
//              ==== Кизим Игорь ====
//------------------------------------------------------


#include <delay.h>
#include "Symbols.h"

//#define _8_BIT_COLOR  //Если закомментировано - 16-ти битный цвет
#define _GEOMETRICAL  //Использование функций вывода геометрических фигур

//===============================================================
//                  Назначение выводов порта 
//===============================================================
#define LCD_CS       PORTA.0 //Выбор чипа
#define LCD_RESET    PORTA.1 //Сброс
#define LCD_RS       PORTA.2   //CD - тип передаваемых данных
#define LCD_CLK    PORTA.3 //Синхронизация
#define LCD_DATA    PORTA.4 //Данные

//*************************************************************
//Команда/Данные
#define CMD 0
#define DAT 1
char RS_old;
  
//===============================================================
//                  Определение цветов
//===============================================================
#ifdef _8_BIT_COLOR
//8-ми битовая цветовая палитра (256 цветов)
#define GREEN       0x1C
#define DARK_GREEN  0x15
#define RED         0xE0
#define BLUE        0x1F    
#define DARK_BLUE   0x03
#define YELLOW      0xFC
#define ORANGE      0xEC
#define VIOLET      0xE3
#define WHITE       0xFF
#define BLACK       0x00
#define GREY        0x6D

#else
//16-ти битовая цветовая палитра (65536 цветов)
#define    BLACK                0x0000 
#define    WHITE                0xFFFF 
#define    GRAY                 0xE79C
#define    GREEN                0x07E0 
#define    BLUE                 0x001F 
#define    RED                  0xF800 
#define    SKY                  0x5d1c 
#define    YELLOW               0xffe0 
#define    MAGENTA              0xf81f
#define    CYAN                 0x07ff
#define    ORANGE               0xfca0 
#define    PINK                 0xF97F
#define    BROWN                0x8200
#define    VIOLET               0x9199
#define    SILVER               0xa510
#define    GOLD                 0xa508
#define    BEGH                 0xf77b
#define    NAVY                 0x000F      
#define    DARK_GREEN           0x03E0      
#define    DARK_CYAN            0x03EF      
#define    MAROON               0x7800      
#define    PURPLE               0x780F      
#define    OLIVE                0x7BE0      
#define    LIGHT_GREY           0xC618      
#define    DARK_GREY            0x7BEF
#endif

//*************************************************************
//ПРОТОТИПЫ ФУНКЦИЙ
void LCD_init (void);
void Send_to_lcd (unsigned char RS, unsigned char data);
void SetArea (char x1, char x2, char y1, char y2);
void Put_Pixel (char x, char y, unsigned int color);
void Send_Symbol (unsigned char symbol, char x, char y, int t_color, int b_color, char zoom_width, char zoom_height);  
void LCD_Putchar (char symbol, char x, char y, int t_color, int b_color, char zoom_width, char zoom_height, int rot);    
void LCD_Puts(char *str, int x, int y,  int t_color, int b_color, char zoom_width, char zoom_height, int rot);
void LCD_Putsf(flash char *str, int x, int y,  int t_color, int b_color, char zoom_width, char zoom_height, int rot);
void Send_Symbol_Shadow (unsigned char symbol, char x, char y, int t_color, char zoom_width, char zoom_height);
void LCD_Putchar_Shadow (char symbol, char x, char y, int t_color, char zoom_width, char zoom_height, int rot);
void LCD_Puts_Shadow (char *str, int x, int y,  int t_color, char zoom_width, char zoom_height, int rot);
void LCD_Putsf_Shadow (flash char *str, int x, int y,  int t_color, char zoom_width, char zoom_height, int rot);
void LCD_FillScreen (unsigned int color);
void LCD_Output_image (char x, char y, char width, char height, flash char *img, int rot);
void Send_Image (char x, char y, char width, char height, flash char *img);
#ifdef _GEOMETRICAL
void LCD_DrawLine (char x1, char y1, char x2, char y2, int color);
void LCD_DrawRect (char x1, char y1, char width, char height, char size, int color);
void LCD_FillRect (char x1, char y1, char width, char height, int color);
void LCD_DrawCircle (char xcenter, char ycenter, char rad, int color);
void LCD_FillCircle (char xcenter, char ycenter, char rad, int color);
void LCD_DrawTriangle (char x1, char y1, char x2, char y2, char x3, char y3, int color);
void LCD_FillTriangle (char x1, char y1, char x2, char y2, char x3, char y3, int color);
void LCD_FillTriangleA (char x1, char y1, char x2, char y2, char x3, char y3, int color);
#endif 

//===============================================================
//                        ИНИЦИАЛИЗАЦИЯ
//===============================================================
void LCD_init(void)
{
 LCD_CS=0;
 LCD_DATA=0;
 LCD_CLK=1;
 LCD_RESET = 1;
 LCD_RESET = 0;
 LCD_RESET = 1;
 LCD_CLK=1;
 LCD_DATA=1;
 LCD_CLK=1;
 delay_ms(10);
 Send_to_lcd(CMD, 0x01); //Программный сброс
 Send_to_lcd(CMD, 0x25); //Wtite Contrast
 Send_to_lcd(DAT, 0x40);    
 Send_to_lcd(CMD, 0x11); //Выход из спящего режима
 //sendCMD(0x03); // Booster on
 delay_ms(10);
 Send_to_lcd(CMD, 0x20); //Display Inversion Off
 Send_to_lcd(CMD, 0xB9);
 Send_to_lcd(CMD, 0x38); //Idle Mod Off
 Send_to_lcd(CMD, 0x29); //Включение дисплея
 Send_to_lcd(CMD, 0x13); //Normal Mod On
 Send_to_lcd(CMD, 0x36); //Memory Access Control
 Send_to_lcd(DAT, 0x00);
 Send_to_lcd(CMD, 0x3a); //Установка цветовой палитры
 #ifdef _8_BIT_COLOR
 Send_to_lcd(DAT, 0x02); //Байт на пиксель 256 цветов
 #else
 Send_to_lcd(DAT, 0x05); //Два байта на пиксель 65536 цветов
 #endif
 Send_to_lcd(CMD, 0x2A); //X_Adress Area
 Send_to_lcd(DAT, 0x00);
 Send_to_lcd(DAT, 0x7F);
 Send_to_lcd(CMD, 0xB4); //Frame Frequency Select
 Send_to_lcd(DAT, 0x03);
 Send_to_lcd(DAT, 0x08);
 Send_to_lcd(DAT, 0x0B);
 Send_to_lcd(DAT, 0x0E);
 Send_to_lcd(CMD, 0xBA); //Display Control
 Send_to_lcd(DAT, 0x07);
 Send_to_lcd(DAT, 0x0D);
 Send_to_lcd(CMD, 0x2B); //Page Adress Set
 Send_to_lcd(DAT, 0x00);
 Send_to_lcd(DAT, 0x7F);    
}

//===============================================================
//Функция записи команды/данных в LCD (RS==0 - команда, RS==1 - данные)
//===============================================================
void Send_to_lcd (unsigned char RS, unsigned char data){
 //unsigned char count;  
 LCD_CLK = 0;
 LCD_DATA = 0;
 if ((RS_old != RS) || (!RS_old && !RS)) //проверяем старое значение RS (если поступают одни команды то дергаем CS)
 { 
  LCD_CS=1;   // Установка CS 
  LCD_RS=RS;   
  LCD_CS=0;   // Сброс CS 
 }
 //******************************************************************************
 //Такой цикл обеспечивает более компактный код при записи байта в дисплей 
 //******************************************************************************
 /*
 for (count = 0; count < 8; count++) //Цикл передачи данных
 { 
  if(data&0x80)      LCD_DATA=1;
  else             LCD_DATA=0;
  LCD_CLK=1;  
  data <<= 1;
  LCD_CLK=0;    
 } 
 */
 //******************************************************************************
 //Такой прямой код (без цикла) обеспечивает более быструю запись байта в дисплей 
 //******************************************************************************
 LCD_DATA = 0;
 if ((data & 128) == 128)  LCD_DATA = 1; 
 LCD_CLK=1;
 LCD_CLK=0;
 LCD_DATA = 0;
 if ((data & 64) == 64)  LCD_DATA = 1; 
 LCD_CLK=1;
 LCD_CLK=0;
 LCD_DATA = 0;
 if ((data & 32) == 32)  LCD_DATA = 1; 
 LCD_CLK=1;
 LCD_CLK=0;
 LCD_DATA = 0;
 if ((data & 16) ==16)  LCD_DATA = 1; 
 LCD_CLK=1;
 LCD_CLK=0;
 LCD_DATA = 0;
 if ((data & 8) == 8)  LCD_DATA = 1; 
 LCD_CLK=1;
 LCD_CLK=0;
 LCD_DATA = 0;
 if ((data & 4) == 4)  LCD_DATA = 1; 
 LCD_CLK=1;
 LCD_CLK=0;
 LCD_DATA = 0;
 if ((data & 2) == 2)  LCD_DATA = 1; 
 LCD_CLK=1;
 LCD_CLK=0;
 LCD_DATA = 0;
 if ((data & 1) == 1)  LCD_DATA = 1; 
 LCD_CLK=1;
 LCD_CLK=0;
 
 RS_old=RS;  //запоминаю значение RS   
 LCD_DATA = 0;
}

//===============================================================
//              Задание прямоугольной области экрана
//===============================================================
void SetArea(char x1, char x2, char y1, char y2)
{
 Send_to_lcd( CMD, 0x2A );  //задаем область по X
 Send_to_lcd( DAT, x1 );    //начальная
 Send_to_lcd( DAT, x2 );    //конечная

 Send_to_lcd( CMD, 0x2B );  //задаем область по Y
 Send_to_lcd( DAT, y1 );    //начальная 
 Send_to_lcd( DAT, y2 );    //конечная

 Send_to_lcd( CMD, 0x2C );  //отправляем команду на начало записи в память и начинаем посылать данные
}                 

//===============================================================
//                          Рисуем точку 
//=============================================================== 
void Put_Pixel (char x, char y, unsigned int color) 
{
 signed char i;
 SetArea( x, x, y, y ); 
 LCD_RS = 1;    
 
 #ifdef _8_BIT_COLOR   //(8-ми битовая цветовая палитра (256 цветов))
 Send_to_lcd( DAT, color ); //Данные - задаём цвет пикселя 
 #else                 //(16-ти битовая цветовая палитра (65536 цветов))
 Send_to_lcd( DAT, (color >> 8) ); 
 Send_to_lcd( DAT, color );
 #endif
}  
                   
//===============================================================
//           Функция прорисовки символа на дисплее
//===============================================================
void Send_Symbol (unsigned char symbol, char x, char y, int t_color, int b_color, char zoom_width, char zoom_height) 
{
 unsigned char temp_symbol, a, b, zw, zh, mask; 
  
 if (symbol>127) symbol-=64;    //Убираем отсутствующую часть таблицы ASCII
 for ( a = 0; a < 5; a++) //Перебираю 5 байт, составляющих символ
 {
    temp_symbol = font_5x8[symbol-32][a];
    zw = 0; 
    while(zw != zoom_width) //Вывод байта выполняется zw раз 
    {    
        mask=0x01;  
       
        SetArea( x+zw, x+zw, y, y+(zoom_height*8)-1 );                        
        
        LCD_RS = 1; //Передаются данные          
        for ( b = 0; b < 8; b++ ) //Цикл перебирания 8 бит байта
        {         
            zh = zoom_height; //в zoom_height раз увеличится высота символа
            while(zh != 0) //Вывод пикселя выполняется zh раз
            {
                if (temp_symbol&mask) 
                {
                    #ifdef _8_BIT_COLOR   //(8-ми битовая цветовая палитра (256 цветов))
                    Send_to_lcd( DAT, t_color ); //Данные - задаём цвет пикселя 
                    #else                 //(16-ти битовая цветовая палитра (65536 цветов))
                    Send_to_lcd( DAT, (t_color >> 8) ); Send_to_lcd( DAT, t_color );
                    #endif
                }
                else 
               {
                    #ifdef _8_BIT_COLOR   //(8-ми битовая цветовая палитра (256 цветов))
                    Send_to_lcd( DAT, b_color ); //Данные - задаём цвет пикселя 
                    #else                 //(16-ти битовая цветовая палитра (65536 цветов))
                    Send_to_lcd( DAT, (b_color >> 8) ); Send_to_lcd( DAT, b_color );
                    #endif
                }
                zh--;
            }
            mask<<=1; //Смещаю содержимое mask на 1 бит влево;    
        }
        zw++;
    }
 
   x=x+zoom_width; //Получить адрес начального пикселя по оси x для вывода очередного байта             
 }
}  

//===============================================================
// Функция вывода одного символа ASCII-кода (из файла Symbols.h)
//===============================================================
void LCD_Putchar(char symbol, char x, char y, int t_color, int b_color, char zoom_width, char zoom_height, int rot)
{
    unsigned char m;
    if(zoom_width == 0)   zoom_width = 1;
    if(zoom_height == 0)  zoom_height = 1;
    switch (rot)
    {
        case 0:  //Начальный адрес осей Х и У - левый верхний угол дисплея   
        Send_Symbol( symbol, x, y, t_color, b_color, zoom_width, zoom_height);
        break;
        //================================
        case 90:        
        Send_to_lcd(CMD, 0x36); 
        Send_to_lcd(DAT, 0x60); //Начальный адрес осей Х и У - правый верхний угол дисплея 
        Send_Symbol( symbol, x, y, t_color, b_color, zoom_width, zoom_height);
        Send_to_lcd(CMD, 0x36); 
        Send_to_lcd(DAT, 0x00);
        break;
        //================================
        case 180:       
        Send_to_lcd(CMD, 0x36); 
        Send_to_lcd(DAT, 0xC0); //Начальный адрес осей Х и У - правый нижний угол дисплея 
        Send_Symbol( symbol, x, y, t_color, b_color, zoom_width, zoom_height);
        Send_to_lcd(CMD, 0x36); 
        Send_to_lcd(DAT, 0x00);
        break;
        //================================
        case 270:       
        Send_to_lcd(CMD, 0x36); 
        Send_to_lcd(DAT, 0xA0); //Начальный адрес осей Х и У - левый нижний угол дисплея  
        Send_Symbol( symbol, x, y, t_color, b_color, zoom_width, zoom_height);
        Send_to_lcd(CMD, 0x36); 
        Send_to_lcd(DAT, 0x00);
        break;
        //================================
        default:
        Send_to_lcd(CMD, 0x36); 
        Send_to_lcd(DAT, 0x00); //Начальный адрес осей Х и У - левый верхний угол дисплея  
        Send_Symbol( symbol, x, y, t_color, b_color, zoom_width, zoom_height);
        Send_to_lcd(CMD, 0x36); 
        Send_to_lcd(DAT, 0x00);
        //=================================    
    };  
}

//===============================================================
//          Функция вывода строки, расположенной в ram 
//===============================================================
void LCD_Puts(char *str, int x, int y,  int t_color, int b_color, char zoom_width, char zoom_height, int rot)
{
 unsigned char i=0;
              
 if(zoom_width == 0)   zoom_width = 1;
 if(zoom_height == 0)  zoom_height = 1;
   
 while (str[i]) //x и y - адрес пикселя начальной позиции; с увеличением переменной i адрес вывода очередного символа смещается на i*6 (чем организуются столбцы дисплея)  
 {      
  LCD_Putchar(str[i], x+(i*6*zoom_width), y, t_color, b_color, zoom_width, zoom_height, rot);
  i++;
 }  
}

//===============================================================
//          Функция вывода строки, расположенной во flash
//===============================================================
void LCD_Putsf(flash char *str, int x, int y,  int t_color, int b_color, char zoom_width, char zoom_height, int rot)
{
 unsigned char i=0;
        
 if(zoom_width == 0)   zoom_width = 1;
 if(zoom_height == 0)  zoom_height = 1;
   
 while (str[i]) //x и y - адрес пикселя начальной позиции; с увеличением переменной i адрес вывода очередного символа смещается на i*6 (чем организуются столбцы дисплея)  
 {      
  LCD_Putchar(str[i], x+(i*6*zoom_width), y, t_color, b_color, zoom_width, zoom_height, rot);
  i++;
 }  
}    

//===============================================================
//     Функция прорисовки символа на дисплее без цвета фона
//===============================================================
void Send_Symbol_Shadow (unsigned char symbol, char x, char y, int t_color, char zoom_width, char zoom_height) 
{
 unsigned char temp_symbol, a, b, zw, zh, mask; 
 char m, n;
 m=x; 
 n=y;
 if (symbol>127) symbol-=64;    //Убираем отсутствующую часть таблицы ASCII
 for ( a = 0; a < 5; a++) //Перебираю 5 байт, составляющих символ
 {  
  temp_symbol = font_5x8[symbol-32][a];
  zw = 0; 
  while(zw != zoom_width) //Вывод байта выполняется zw раз 
  {    
   n=y;      
   
   mask=0x01;     
   for ( b = 0; b < 8; b++ ) //Цикл перебирания 8 бит байта
   {         
    zh = 0; //в zoom_height раз увеличится высота символа
    while(zh != zoom_height) //Вывод пикселя выполняется zh раз
    {
    
      if (temp_symbol&mask) 
      {
       Put_Pixel (m+zw, n+zh, t_color);
      }
     
     zh++;
    }
    mask<<=1; //Смещаю содержимое mask на 1 бит влево;
    n=n+zoom_height;                   
   }
   zw++;   
  }
   m=m+zoom_width;           
 }
} 

//===============================================================
// Функция вывода одного символа ASCII-кода без цвета фона
//===============================================================
void LCD_Putchar_Shadow (char symbol, char x, char y, int t_color, char zoom_width, char zoom_height, int rot)
{
 unsigned char m;
 if(zoom_width == 0)   zoom_width = 1;
 if(zoom_height == 0)  zoom_height = 1;
 switch (rot)
 {
  case 0:  //Начальный адрес осей Х и У - левый верхний угол дисплея   
  Send_Symbol_Shadow( symbol, x, y, t_color, zoom_width, zoom_height);
  break;
  //================================
  case 90:  
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x60); //Начальный адрес осей Х и У - правый верхний угол дисплея 
  Send_Symbol_Shadow( symbol, x, y, t_color, zoom_width, zoom_height);
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x00);
  break;
  //================================
  case 180:       
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0xC0); //Начальный адрес осей Х и У - правый нижний угол дисплея 
  Send_Symbol_Shadow( symbol, x, y, t_color, zoom_width, zoom_height);
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x00);
  break;
  //================================
  case 270: 
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0xA0); //Начальный адрес осей Х и У - левый нижний угол дисплея  
  Send_Symbol_Shadow( symbol, x, y, t_color, zoom_width, zoom_height);
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x00);
  break;
  //================================
  default:
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x00); //Начальный адрес осей Х и У - левый верхний угол дисплея  
  Send_Symbol_Shadow( symbol, x, y, t_color, zoom_width, zoom_height);
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x00);
  //=================================    
 };  
}

//===============================================================
//   Функция вывода строки, расположенной в ram без цвета фона 
//===============================================================
void LCD_Puts_Shadow(char *str, int x, int y,  int t_color, char zoom_width, char zoom_height, int rot)
{
 unsigned char i=0;
                    
 if(zoom_width == 0)   zoom_width = 1;
 if(zoom_height == 0)  zoom_height = 1;
   
 while (str[i]) //x и y - адрес пикселя начальной позиции; с увеличением переменной i адрес вывода очередного символа смещается на i*6 (чем организуются столбцы дисплея)  
 {      
  LCD_Putchar_Shadow(str[i], x+(i*6*zoom_width), y, t_color, zoom_width, zoom_height, rot);
  i++;
 }  
}

//===============================================================
// Функция вывода строки, расположенной во flash без цвета фона
//===============================================================
void LCD_Putsf_Shadow(flash char *str, int x, int y,  int t_color, char zoom_width, char zoom_height, int rot)
{
 unsigned char i=0;
           
 if(zoom_width == 0)   zoom_width = 1;
 if(zoom_height == 0)  zoom_height = 1;
   
 while (str[i])   
 {      
  LCD_Putchar_Shadow(str[i], x+(i*6*zoom_width), y, t_color, zoom_width, zoom_height, rot);
  i++;
 }  
} 
   
//===============================================================
//                  ЗАЛИВКА ЭКРАНА ЦВЕТОМ 
//===============================================================
void LCD_FillScreen (unsigned int color)
{ 
 unsigned int x; 
 signed char i;
 SetArea( 0, 127, 0, 127 );   //Область всего экрана 
 LCD_RS = 1;    
 
 //Данные - задаём цвет пикселя
 for (x = 0; x < 16384; x++)  // 16384 - это 128 * 128
 {   
  #ifdef _8_BIT_COLOR   //(8-ми битовая цветовая палитра (256 цветов))
  Send_to_lcd( DAT, color ); //Данные - задаём цвет пикселя 
  #else         //(16-ти битовая цветовая палитра (65536 цветов))
  Send_to_lcd( DAT, (color >> 8) ); Send_to_lcd( DAT, color );
  #endif
 }                 
} 

//===============================================================
//                 ФУНКЦИЯ ВЫВОДА ИЗОБРАЖЕНИЯ
//===============================================================
void LCD_Output_image (char x, char y, char width, char height, flash char *img, int rot)
{ 
 unsigned char m;
 switch (rot)
 {
  case 0:  //Начальный адрес осей Х и У - левый верхний угол дисплея    
  Send_Image (x, y, width, height, img);
  break;
  //================================
  case 90:   
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x60); //Начальный адрес осей Х и У - правый верхний угол дисплея 
  Send_Image (x, y, width, height, img);
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x00);
  break;
  //================================
  case 180:       
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0xC0); //Начальный адрес осей Х и У - правый нижний угол дисплея 
  Send_Image (x, y, width, height, img);
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x00);
  break;
  //================================
  case 270:      
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0xA0); //Начальный адрес осей Х и У - левый нижний угол дисплея  
  Send_Image (x, y, width, height, img);
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x00);
  break;
  //================================
  default:
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x00); //Начальный адрес осей Х и У - левый верхний угол дисплея  
  Send_Image (x, y, width, height, img);
  Send_to_lcd(CMD, 0x36); 
  Send_to_lcd(DAT, 0x00);
  //=================================    
 };
}   

//===============================================================
//          Функция для обеспечения вывода изображения   
//===============================================================
//Вывод картинки с Image2Lcd и NokiaImageCreator должен выполняться слева-направо сверху-вниз.
//x, y - начало области вывода изображения; width и height - ширина и высота изображения   
void Send_Image (char x, char y, char width, char height, flash char *img)  
{  
 unsigned int idx=0, size_array;  //Индекс массива img и значение размера массива
 
 Send_to_lcd( CMD, 0x2A );          //задаем область по X
 Send_to_lcd( DAT, x );             //начальная
 Send_to_lcd( DAT, x+(width-1) );   //конечная

 Send_to_lcd( CMD, 0x2B );          //задаем область по Y
 Send_to_lcd( DAT, y );             //начальная 
 Send_to_lcd( DAT, y+(height-1) );  //конечная

 Send_to_lcd( CMD, 0x2C );  //отправляем команду на начало записи в память и начинаем посылать данные
 
 size_array= width * height;  //Определяем размер массива
 for (idx = 0; idx < size_array; idx++)  //Перебираю индекс массива
 { 
  #ifdef _8_BIT_COLOR        
  Send_to_lcd( DAT, *img++ );   //Последовательно вывожу пиксели из массива img
  #else                      
  Send_to_lcd( DAT, *img++ ); Send_to_lcd( DAT, *img++ );
  #endif 
 }
} 

#ifdef _GEOMETRICAL
//===============================================================
//                      НАРИСОВАТЬ ЛИНИЮ
//===============================================================
void LCD_DrawLine (char x1, char y1, char x2, char y2, int color)
{ 
 short  x, y, d, dx, dy, i, i1, i2, kx, ky;
 signed char flag;

 dx = x2 - x1;
 dy = y2 - y1;
 if (dx == 0 && dy == 0) Put_Pixel(x1, y1, color);  //Точка
 else      //Линия
 {
  kx = 1;
  ky = 1;
  if( dx < 0 )
  { 
   dx = -dx; 
   kx = -1; 
  }
  else
  if(dx == 0) kx = 0;
  if(dy < 0)
  { 
   dy = -dy; 
   ky = -1; 
  }
  if(dx < dy)
  { 
   flag = 0; 
   d = dx; 
   dx = dy; 
   dy = d; 
  }
  else flag = 1;
  i1 = dy + dy; 
  d = i1 - dx; 
  i2 = d - dx;
  x = x1; 
  y = y1;

  for(i=0; i < dx; i++)
  {
   Put_Pixel(x, y, color);
   if(flag) x += kx;
   else y += ky;
   if( d < 0 ) d += i1;
   else
   {
    d += i2;
    if(flag) y += ky;
    else x += kx;
   }
  }
  Put_Pixel(x, y, color);
 }
}   
  
//===============================================================
//                     НАРИСОВАТЬ РАМКУ                
//===============================================================
void LCD_DrawRect (char x1, char y1, char width, char height, char size, int color)
{
 unsigned int i;
 char x2=x1+(width-1), y2=y1+(height-1); //Конечные размеры рамки по осям х и у
 for( i=1; i<=size; i++)   // size - толщина рамки
 {
  LCD_DrawLine(x1, y1, x1, y2, color);
  LCD_DrawLine(x2, y1, x2, y2, color);
  LCD_DrawLine(x1, y1, x2, y1, color);
  LCD_DrawLine(x1, y2, x2, y2, color);
  x1++; // Увеличиваю толщину рамки, если это задано
  y1++;
  x2--;
  y2--;
 }
}

//===============================================================
//              ЗАПОЛНИТЬ ПРЯМОУГОЛЬНИК ЦВЕТОМ COLOR
//===============================================================
void LCD_FillRect (char x1, char y1, char width, char height, int color)
{
 unsigned int x, y;
       
 SetArea( x1, x1+(width-1), y1, y1+(height-1) );
 LCD_RS = 1;
 
 y = width * height;           //Количество пикселей в прямоугольнике
 for (x = 0; x < y; x++) 
 {   
  #ifdef _8_BIT_COLOR   //(8-ми битовая цветовая палитра (256 цветов))
  Send_to_lcd( DAT, color ); //Данные - задаём цвет пикселя 
  #else         //(16-ти битовая цветовая палитра (65536 цветов))
  Send_to_lcd( DAT, (color >> 8) ); Send_to_lcd( DAT, color );
  #endif
 }   
}  
 
//===============================================================
//                  НАРИСОВАТЬ ОКРУЖНОСТЬ
//===============================================================
void LCD_DrawCircle (char xcenter, char ycenter, char rad, int color)
{
 signed char tswitch, x1=0, y1; 
 char d;

 d = ycenter - xcenter;
 y1 = rad;
 tswitch = 3 - 2 * rad;
 while (x1 <= y1) 
 {
  Put_Pixel(xcenter + x1, ycenter + y1, color); 
  Put_Pixel(xcenter + x1, ycenter - y1, color);
  Put_Pixel(xcenter - x1, ycenter + y1, color);   
  Put_Pixel(xcenter - x1, ycenter - y1, color);
  Put_Pixel(ycenter + y1 - d, ycenter + x1, color); 
  Put_Pixel(ycenter + y1 - d, ycenter - x1, color);
  Put_Pixel(ycenter - y1 - d, ycenter + x1, color);
  Put_Pixel(ycenter - y1 - d, ycenter - x1, color);

  if (tswitch < 0) tswitch += (4 * x1 + 6);
  else 
  {
   tswitch += (4 * (x1 - y1) + 10);
   y1--;
  }
  x1++;
 }
}    

//===============================================================
//                 ЗАПОЛНИТЬ КРУГ ЦВЕТОМ COLOR
//===============================================================
void LCD_FillCircle (char xcenter, char ycenter, char rad, int color)
{
 signed int x1=0, y1, tswitch; 
 y1 = rad;
 tswitch = 1 - rad;

 do
 {
  LCD_DrawLine(xcenter-x1, ycenter+y1, xcenter+x1, ycenter+y1, color);
  LCD_DrawLine(xcenter-x1, ycenter-y1, xcenter+x1, ycenter-y1, color);
  LCD_DrawLine(xcenter-y1, ycenter+x1, xcenter+y1, ycenter+x1, color);
  LCD_DrawLine(xcenter-y1, ycenter-x1, xcenter+y1, ycenter-x1, color);

  if(tswitch < 0)
  tswitch+= 3 + 2*x1++;
  else
  tswitch+= 5 + 2*(x1++ - y1--);
 } while(x1 <= y1);
}

//===============================================================
//                     НАРИСОВАТЬ ТРЕУГОЛЬНИК
//===============================================================
void LCD_DrawTriangle(char x1, char y1, char x2, char y2, char x3, char y3, int color)
{
 LCD_DrawLine(x1, y1, x2, y2, color);
 LCD_DrawLine(x3, y3, x1, y1, color);
 LCD_DrawLine(x3, y3, x2, y2, color);  
}

//===============================================================
//              ЗАПОЛНИТЬ ТРЕУГОЛЬНИК ЦВЕТОМ COLOR
//===============================================================
void LCD_FillTriangle(char x1, char y1, char x2, char y2, char x3, char y3, int color)
{
 LCD_FillTriangleA(x1, y1, x2, y2, x3, y3, color);
 LCD_FillTriangleA(x3, y3, x1, y1, x2, y2, color);
 LCD_FillTriangleA(x3, y3, x2, y2, x1, y1, color);
}    

//===============================================================
void LCD_FillTriangleA(char x1, char y1, char x2, char y2, char x3, char y3, int color)
{
 signed long x, y, addx, dx, dy;
 signed long P;
 int i;
 long a1,a2,b1,b2;
 if(y1>y2)  {b1=y2; b2=y1; a1=x2; a2=x1;}
 else       {b1=y1; b2=y2; a1=x1; a2=x2;}
 dx = a2 -a1;
 dy = b2 - b1;
 if(dx<0)dx=-dx;
 if(dy<0)dy=-dy;
 x = a1;
 y = b1;
   
 if(a1 > a2)    addx = -1;
 else           addx = 1;
   
 if(dx >= dy)
 {
  P = 2*dy - dx;
  for(i=0; i<=dx; ++i)
  {
   LCD_DrawLine((int)x, (int)y, x3, y3, color);
   if(P < 0)
   {
    P += 2*dy;
    x += addx;
   }
   else
   {
    P += 2*dy - 2*dx;
    x += addx;
    y ++;
   }
  }
 }
 else
 {
  P = 2*dx - dy;
  for(i=0; i<=dy; ++i)
  {
   LCD_DrawLine((int)x, (int)y, x3, y3, color);
   if(P < 0)
   {
    P += 2*dx;
    y ++;
   }
   else
   {
    P += 2*dx - 2*dy;
    x += addx;
    y ++;
   }
  }
 }
}

//===============================================================
#endif


    
