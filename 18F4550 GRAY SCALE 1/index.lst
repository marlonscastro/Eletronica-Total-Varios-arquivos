CCS PCH C Compiler, Version 4.114, 93460303               24-abr-13 10:45

               Filename: D:\SkyDrive\Eletronica\PROJETOS PIC CCS\18F4550 GRAY SCALE 1\index.lst

               ROM used: 610 bytes (2%)
                         Largest free fragment is 32158
               RAM used: 12 (1%) at main() level
                         23 (1%) worst case
               Stack:    6 locations

*
0000:  GOTO   01B8
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #use delay(clock=48000000) 
*
0004:  MOVLW  01
0006:  SUBWF  0C,F
0008:  BNC   0022
000A:  CLRF   FEA
000C:  MOVLW  0C
000E:  MOVWF  FE9
0010:  MOVF   FEF,W
0012:  BZ    0022
0014:  MOVLW  02
0016:  MOVWF  00
0018:  DECFSZ 00,F
001A:  BRA    0018
001C:  BRA    001E
001E:  DECFSZ FEF,F
0020:  BRA    0014
0022:  RETLW  00
*
004C:  CLRF   FEA
004E:  MOVLW  0C
0050:  MOVWF  FE9
0052:  MOVF   FEF,W
0054:  BZ    0072
0056:  MOVLW  0F
0058:  MOVWF  01
005A:  CLRF   00
005C:  DECFSZ 00,F
005E:  BRA    005C
0060:  DECFSZ 01,F
0062:  BRA    005A
0064:  MOVLW  8F
0066:  MOVWF  00
0068:  DECFSZ 00,F
006A:  BRA    0068
006C:  NOP   
006E:  DECFSZ FEF,F
0070:  BRA    0056
0072:  RETLW  00
.................... #fuses HSPLL, PLL4, CPUDIV1, PUT, NOWDT, NOBROWNOUT, NOLVP 
.................... #include "HMF6598SYH-PY.c" 
.................... /*const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01\ 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x00, 0x41, 0x49, 0x49, 0x36, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x00, 0x27, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x00, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x7e, 0x00, // A      34 
....................                          0x7F, 0x49, 0x49, 0x36, 0x00, // B 
....................                          0x3E, 0x41, 0x41, 0x22, 0x00, // C 
....................                          0x7F, 0x41, 0x41, 0x3e, 0x00, // D      37 
....................                          0x7F, 0x49, 0x49, 0x41, 0x00, // E 
....................                          0x7F, 0x09, 0x09, 0x01, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x08, 0x7f, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x3f, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x3e, 0x00, // O 
....................                          0x7F, 0x09, 0x09, 0x06, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x09, 0x76, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x32, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x40, 0x3f, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x08, 0x04, 0x78, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x04, 0x78, 0x00, // n 
....................                          0x38, 0x44, 0x44, 0x38, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x00, 0x3c, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x3c, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... */ 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x41, 0x49, 0x49, 0x36, 0x00, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x27, 0x45, 0x45, 0x39, 0x00, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x71, 0x09, 0x09, 0x07, 0x00,  // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x7e, 0x00, 0x00, // A      34 
....................                          0x7F, 0x49, 0x36, 0x00, 0x00, // B 
....................                          0x3E, 0x41, 0x22, 0x00, 0x00, // C 
....................                          0x7F, 0x41, 0x3e, 0x00, 0x00, // D      37 
....................                          0x7F, 0x49, 0x41, 0x00, 0x00, // E 
....................                          0x7F, 0x09, 0x01, 0x00, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x7f, 0x00, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x3f, 0x00, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x3e, 0x00, 0x00, // O 
....................                          0x7F, 0x09, 0x06, 0x00, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x76, 0x00, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x32, 0x00, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x3f, 0x00, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x00, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x04, 0x78, 0x00, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x78, 0x00, 0x00, // n 
....................                          0x38, 0x44, 0x38, 0x00, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x3c, 0x40, 0x7c, 0x00, 0x00, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x3c, 0x00, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... #define HMF6598_RS    pin_A0 
.................... #define HMF6598_RES   pin_A1 
.................... #define HMF6598_CS1   pin_A2 
.................... #define HMF6598_RD    pin_A3 
.................... #define HMF6598_WR    pin_A4 
....................  
.................... #define ON   1 
.................... #define OFF  0 
....................  
.................... int8 CurrentLine = 0; 
.................... int8 QuantChrLine = 0; 
.................... int8 OffsetX = 0; 
....................  
.................... void    HMF6598_InitLcd(void); 
.................... void    HMF6598_Write_command(char byte_command); 
.................... void    HMF6598_Write_data(char byte_data); 
.................... char    HMF6598_Read_data(); 
.................... void    HMF6598_Gotoxy(int8 x, int y); 
.................... void    HMF6598_Printchar(char cvar); 
.................... void    HMF6598_PutPixel(int8 x,int8 y, int1 COLOR); 
.................... void    HMF6598_OutPort(char byteDC); 
.................... void    clear_screen(void); 
.................... void    newLine(void); 
.................... void    HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR); 
.................... void    HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR); 
....................  
.................... void    HMF6598_InitLcd(void){ 
....................     
....................    output_low(HMF6598_CS1); // Chip Enabled 
*
0140:  BCF    F92.2
0142:  BCF    F89.2
....................    output_low(HMF6598_RES); 
0144:  BCF    F92.1
0146:  BCF    F89.1
....................    delay_us(200); 
0148:  MOVLW  C8
014A:  MOVWF  0C
014C:  RCALL  0004
....................    output_high(HMF6598_RES);  
014E:  BCF    F92.1
0150:  BSF    F89.1
....................    delay_us(200);    
0152:  MOVLW  C8
0154:  MOVWF  0C
0156:  RCALL  0004
....................  
....................    HMF6598_Write_command(0xc8);   // Duty = 65    
0158:  MOVLW  C8
015A:  MOVWF  13
015C:  RCALL  0040
....................    HMF6598_Write_command(0xa3);   // BIAS 1/9 
015E:  MOVLW  A3
0160:  MOVWF  13
0162:  RCALL  0040
....................    HMF6598_Write_command(0xa0);   // ADC Select 
0164:  MOVLW  A0
0166:  MOVWF  13
0168:  RCALL  0040
....................    HMF6598_Write_command(0xa6);   // Normal display 0xa6:  Reverse Display :0xa7 
016A:  MOVLW  A6
016C:  MOVWF  13
016E:  RCALL  0040
....................    HMF6598_Write_command(0x2c);   //---------------------------------------------  
0170:  MOVLW  2C
0172:  MOVWF  13
0174:  RCALL  0040
....................    delay_ms(3);                   // 
0176:  MOVLW  03
0178:  MOVWF  0C
017A:  RCALL  004C
....................    HMF6598_Write_command(0x2e);   // Power Control Set VR, VC, VF  
017C:  MOVLW  2E
017E:  MOVWF  13
0180:  RCALL  0040
....................    delay_ms(3);                   // 
0182:  MOVLW  03
0184:  MOVWF  0C
0186:  RCALL  004C
....................    HMF6598_Write_command(0x2f);   //--------------------------------------------- 
0188:  MOVLW  2F
018A:  MOVWF  13
018C:  RCALL  0040
....................    HMF6598_Write_command(0x20);   // 1+Rb/Ra Ratio    
018E:  MOVLW  20
0190:  MOVWF  13
0192:  RCALL  0040
....................    HMF6598_Write_command(0x40);   // EVER register Set    
0194:  MOVLW  40
0196:  MOVWF  13
0198:  RCALL  0040
....................     
....................    //Set Brightness   
....................    HMF6598_Write_command(0x81);  
019A:  MOVLW  81
019C:  MOVWF  13
019E:  RCALL  0040
....................    HMF6598_Write_command(0x32); 
01A0:  MOVLW  32
01A2:  MOVWF  13
01A4:  RCALL  0040
....................     
....................    HMF6598_Write_command(0xe0);   // Set Modify Read  0xee to cancel / 0xe0 to activate 
01A6:  MOVLW  E0
01A8:  MOVWF  13
01AA:  RCALL  0040
....................  
....................    clear_screen(); 
01AC:  BRA    0110
....................    HMF6598_Write_command(0xaf);   // Display ON 
01AE:  MOVLW  AF
01B0:  MOVWF  13
01B2:  RCALL  0040
.................... } 
01B4:  GOTO   01D8 (RETURN)
....................  
.................... void HMF6598_OutPort(char byteDC){ 
....................   set_tris_b(0x00); 
*
0024:  MOVLW  00
0026:  MOVWF  F93
....................   output_low(HMF6598_CS1); 
0028:  BCF    F92.2
002A:  BCF    F89.2
....................   output_high(HMF6598_RD);  
002C:  BCF    F92.3
002E:  BSF    F89.3
....................   output_low(HMF6598_WR);   
0030:  BCF    F92.4
0032:  BCF    F89.4
....................   output_b(byteDC); 
0034:  CLRF   F93
0036:  MOVFF  14,F8A
....................   output_high(HMF6598_CS1);     
003A:  BCF    F92.2
003C:  BSF    F89.2
.................... } 
003E:  RETLW  00
.................... void    HMF6598_Write_command(char byte_command){ 
....................   output_low(HMF6598_RS);          // Write Command Enabled 
0040:  BCF    F92.0
0042:  BCF    F89.0
....................   HMF6598_OutPort(byte_command); 
0044:  MOVFF  13,14
0048:  RCALL  0024
.................... } 
004A:  RETLW  00
.................... void    HMF6598_Write_data(char byte_data){ 
....................   output_high(HMF6598_RS);         // Write data Enabled 
*
00F8:  BCF    F92.0
00FA:  BSF    F89.0
....................   HMF6598_OutPort(byte_data); 
00FC:  MOVFF  0E,14
0100:  RCALL  0024
....................   OffsetX++; 
0102:  INCF   06,F
....................   HMF6598_Gotoxy(OffsetX,CurrentLine); 
0104:  MOVFF  06,0F
0108:  MOVFF  04,10
010C:  RCALL  009C
.................... } 
010E:  RETLW  00
....................  
.................... char    HMF6598_Read_data(){ 
....................  
.................... /*  set_tris_b(0xff); 
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................    
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1);    */  
....................    
....................   set_tris_b(0xff);     
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................   output_low(HMF6598_CS1); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1); 
.................... } 
....................  
.................... void newLine(){ 
....................   if(CurrentLine < 7){  // New Line Command 
....................       HMF6598_Write_command((CurrentLine+1)|0xb0);  // Set Page Address to 0 (0 a 7) 
....................       HMF6598_Write_command(0x00);  // Set LSB for index Column 
....................       HMF6598_Write_command(0x10);  // Set MSB for index Column    
....................       CurrentLine+=1; 
....................   } 
....................   QuantChrLine = 1; 
....................   OffsetX = 0; 
.................... } 
.................... void clear_screen(void) { 
....................    int p, c; 
....................    for(p = 0; p < 8; p++) { 
0110:  CLRF   0C
0112:  MOVF   0C,W
0114:  SUBLW  07
0116:  BNC   0136
....................       for(c = 0; c < 128; c++) { 
0118:  CLRF   0D
011A:  MOVF   0D,W
011C:  SUBLW  7F
011E:  BNC   0132
....................          HMF6598_Gotoxy(c,p); 
0120:  MOVFF  0D,0F
0124:  MOVFF  0C,10
0128:  RCALL  009C
....................          HMF6598_Write_data(0x00); 
012A:  CLRF   0E
012C:  RCALL  00F8
....................       } 
012E:  INCF   0D,F
0130:  BRA    011A
....................    } 
0132:  INCF   0C,F
0134:  BRA    0112
....................    HMF6598_Gotoxy(0,0);    
0136:  CLRF   0F
0138:  CLRF   10
013A:  RCALL  009C
.................... } 
013C:  GOTO   01AE (RETURN)
.................... void    HMF6598_Gotoxy(int x, int y){ 
*
009C:  CLRF   11
....................    int8 OffsetChr = 0; 
....................     
....................    HMF6598_Write_command(0xb0 | y); 
009E:  MOVF   10,W
00A0:  IORLW  B0
00A2:  MOVWF  12
00A4:  MOVWF  13
00A6:  RCALL  0040
....................    HMF6598_Write_command((0x00 | x) & 0x0f); 
00A8:  MOVF   0F,W
00AA:  ANDLW  0F
00AC:  MOVWF  12
00AE:  MOVWF  13
00B0:  RCALL  0040
....................    HMF6598_Write_command(0x10|(x>>4)); 
00B2:  SWAPF  0F,W
00B4:  MOVWF  00
00B6:  MOVLW  0F
00B8:  ANDWF  00,F
00BA:  MOVF   00,W
00BC:  IORLW  10
00BE:  MOVWF  12
00C0:  MOVWF  13
00C2:  RCALL  0040
....................     
....................    OffsetChr = (x+1)/6; 
00C4:  MOVLW  01
00C6:  ADDWF  0F,W
00C8:  MOVWF  13
00CA:  MOVWF  14
00CC:  MOVLW  06
00CE:  MOVWF  15
00D0:  RCALL  0074
00D2:  MOVFF  01,11
....................    if((x+1)%6) 
00D6:  MOVLW  01
00D8:  ADDWF  0F,W
00DA:  MOVWF  13
00DC:  MOVWF  14
00DE:  MOVLW  06
00E0:  MOVWF  15
00E2:  RCALL  0074
00E4:  MOVF   00,W
00E6:  BZ    00EA
....................       OffsetChr++;    
00E8:  INCF   11,F
....................    CurrentLine = y; 
00EA:  MOVFF  10,04
....................    QuantChrLine = OffsetChr; 
00EE:  MOVFF  11,05
....................    OffsetX = x; 
00F2:  MOVFF  0F,06
.................... } 
00F6:  RETLW  00
.................... void    HMF6598_Printchar(char cvar){ 
....................    int i; 
....................    if (QuantChrLine > 21)   
....................        newLine();  
....................    else 
....................        QuantChrLine++;     
....................    if(cvar == 0x20) 
....................       for(i=0;i<2;i++) 
....................          HMF6598_Write_data(0x00); 
....................    else{ 
....................       for(i=0;i<5;i++){ 
....................          if (cvar < 0x53){ 
....................             if(TEXT[cvar-0x20][i])          
....................                HMF6598_Write_data(TEXT[cvar-0x20][i]);       
....................          } 
....................          else { 
....................             if(TEXT2[cvar-0x53][i])                
....................                HMF6598_Write_data(TEXT2[cvar-0x53][i]);                
....................          } 
....................       } 
....................    } 
....................    HMF6598_Write_data(0x00); 
.................... } 
.................... void HMF6598_PutPixel(int x, int y, int1 COLOR){ 
....................    char BytePlot = 0, tempByte; 
....................    if((x > 127)||(y > 63)) 
....................       return; 
....................    BytePlot |= 1; 
....................    BytePlot<<=(y%8); 
....................    tempByte = BytePlot; 
....................    HMF6598_Gotoxy(x,(y/8)); 
....................    BytePlot|=HMF6598_Read_data(); 
....................    if(COLOR == OFF) 
....................       BytePlot-=tempByte; 
....................    HMF6598_Write_data(BytePlot); 
.................... } 
....................  
.................... void HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR){ 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................    do{ 
....................       if(fill){ 
....................          HMF6598_line(x-a, y+b, x+a, y+b, color); 
....................          HMF6598_line(x-a, y-b, x+a, y-b, color); 
....................          HMF6598_line(x-b, y+a, x+b, y+a, color); 
....................          HMF6598_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else{ 
....................          HMF6598_PutPixel(a+x, b+y, color); 
....................          HMF6598_PutPixel(b+x, a+y, color); 
....................          HMF6598_PutPixel(x-a, b+y, color); 
....................          HMF6598_PutPixel(x-b, a+y, color); 
....................          HMF6598_PutPixel(b+x, y-a, color); 
....................          HMF6598_PutPixel(a+x, y-b, color); 
....................          HMF6598_PutPixel(x-a, y-b, color); 
....................          HMF6598_PutPixel(x-b, y-a, color); 
....................       } 
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... void HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR){ 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................  
....................    if(x1 > x2) 
....................       addx = -1; 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................       addy = -1; 
....................    else 
....................       addy = 1; 
....................    if(dx >= dy){ 
....................       P = 2*dy - dx; 
....................       for(i=0; i<=dx; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................          if(P < 0){ 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else{ 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else{ 
....................       P = 2*dx - dy; 
....................       for(i=0; i<=dy; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................  
....................          if(P < 0){ 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else{ 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... void main(void){ 
*
01B8:  CLRF   FF8
01BA:  BCF    FD0.7
01BC:  CLRF   FEA
01BE:  CLRF   FE9
01C0:  CLRF   04
01C2:  CLRF   05
01C4:  CLRF   06
01C6:  MOVF   FC1,W
01C8:  ANDLW  C0
01CA:  IORLW  0F
01CC:  MOVWF  FC1
01CE:  MOVLW  07
01D0:  MOVWF  FB4
01D2:  CLRF   07
01D4:  CLRF   08
....................    int i, j, t; 
....................    HMF6598_InitLcd(); 
01D6:  BRA    0140
....................    t = 0; 
01D8:  CLRF   0B
....................    while(true){ 
....................       HMF6598_Gotoxy(0,0); 
01DA:  CLRF   0F
01DC:  CLRF   10
01DE:  RCALL  009C
....................       for(i=0;i<8;i++) 
01E0:  CLRF   09
01E2:  MOVF   09,W
01E4:  SUBLW  07
01E6:  BNC   01F2
....................          HMF6598_Write_data(0xff); 
01E8:  MOVLW  FF
01EA:  MOVWF  0E
01EC:  RCALL  00F8
01EE:  INCF   09,F
01F0:  BRA    01E2
....................       HMF6598_Gotoxy(0,1); 
01F2:  CLRF   0F
01F4:  MOVLW  01
01F6:  MOVWF  10
01F8:  RCALL  009C
....................       if (t<3) 
01FA:  MOVF   0B,W
01FC:  SUBLW  02
01FE:  BNC   0214
....................          for(i=0;i<8;i++){ 
0200:  CLRF   09
0202:  MOVF   09,W
0204:  SUBLW  07
0206:  BNC   0212
....................             HMF6598_Write_data(0xff); 
0208:  MOVLW  FF
020A:  MOVWF  0E
020C:  RCALL  00F8
....................          } 
020E:  INCF   09,F
0210:  BRA    0202
....................       else 
0212:  BRA    0224
....................          for(i=0;i<8;i++){ 
0214:  CLRF   09
0216:  MOVF   09,W
0218:  SUBLW  07
021A:  BNC   0224
....................             HMF6598_Write_data(0x00); 
021C:  CLRF   0E
021E:  RCALL  00F8
....................          } 
0220:  INCF   09,F
0222:  BRA    0216
....................       HMF6598_Gotoxy(0,2); 
0224:  CLRF   0F
0226:  MOVLW  02
0228:  MOVWF  10
022A:  RCALL  009C
....................       if (t<1) 
022C:  MOVF   0B,F
022E:  BNZ   0244
....................          for(i=0;i<8;i++){ 
0230:  CLRF   09
0232:  MOVF   09,W
0234:  SUBLW  07
0236:  BNC   0242
....................             HMF6598_Write_data(0xff); 
0238:  MOVLW  FF
023A:  MOVWF  0E
023C:  RCALL  00F8
....................          } 
023E:  INCF   09,F
0240:  BRA    0232
....................       else 
0242:  BRA    0254
....................          for(i=0;i<8;i++){ 
0244:  CLRF   09
0246:  MOVF   09,W
0248:  SUBLW  07
024A:  BNC   0254
....................             HMF6598_Write_data(0x00); 
024C:  CLRF   0E
024E:  RCALL  00F8
....................          }          
0250:  INCF   09,F
0252:  BRA    0246
....................       t++; 
0254:  INCF   0B,F
....................       if (t > 9) 
0256:  MOVF   0B,W
0258:  SUBLW  09
025A:  BC    025E
....................          t = 0; 
025C:  CLRF   0B
....................    } 
025E:  BRA    01DA
....................   
....................     
.................... } 
0260:  SLEEP 

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV20 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICPRT NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
