CCS PCH C Compiler, Version 4.114, 93460303               04-abr-13 20:18

               Filename: D:\SkyDrive\Eletronica\PROJETOS PIC CCS\GAME_TEST\MOVE_SPRITE_E_CENARIO_ROLANDO\index.lst

               ROM used: 2436 bytes (7%)
                         Largest free fragment is 30328
               RAM used: 39 (2%) at main() level
                         51 (2%) worst case
               Stack:    7 worst case (6 in main + 1 for interrupts)

*
0000:  GOTO   08A0
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   04D4
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #use delay(clock=48000000) 
*
0520:  MOVLW  01
0522:  SUBWF  25,F
0524:  BNC   053E
0526:  CLRF   FEA
0528:  MOVLW  25
052A:  MOVWF  FE9
052C:  MOVF   FEF,W
052E:  BZ    053E
0530:  MOVLW  02
0532:  MOVWF  00
0534:  DECFSZ 00,F
0536:  BRA    0534
0538:  BRA    053A
053A:  DECFSZ FEF,F
053C:  BRA    0530
053E:  RETLW  00
*
0568:  CLRF   FEA
056A:  MOVLW  25
056C:  MOVWF  FE9
056E:  MOVF   FEF,W
0570:  BZ    058E
0572:  MOVLW  0F
0574:  MOVWF  01
0576:  CLRF   00
0578:  DECFSZ 00,F
057A:  BRA    0578
057C:  DECFSZ 01,F
057E:  BRA    0576
0580:  MOVLW  8F
0582:  MOVWF  00
0584:  DECFSZ 00,F
0586:  BRA    0584
0588:  NOP   
058A:  DECFSZ FEF,F
058C:  BRA    0572
058E:  RETLW  00
.................... #fuses HSPLL, PLL4, CPUDIV1, PUT, NOWDT, NOBROWNOUT, NOLVP 
.................... #include "HMF6598SYH-PY.c" 
.................... const BYTE cenario[8][128] =  
.................... { 
.................... 0x00,0x00,0x80,0xC0,0x40,0x70,0x0C,0x04, 
.................... 0x04,0x04,0x04,0x0C,0x18,0x38,0x0C,0x04, 
.................... 0x04,0x04,0x04,0x0C,0x18,0x18,0x0C,0x04, 
.................... 0x04,0x04,0x0C,0x08,0x08,0x18,0xF0,0xE0, 
.................... 0x00,0x00,0x00,0x00,0x00,0x78,0xCC,0x8C, 
.................... 0x84,0x84,0x04,0x0C,0x18,0x0C,0x84,0x84, 
.................... 0xC4,0x44,0x74,0x18,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x10,0x28,0x24,0x24,0x18,0x00, 
.................... 0x00,0x00,0x00,0x00,0x20,0xFC,0x84,0x04, 
.................... 0x06,0x0E,0x12,0x02,0x02,0x02,0x04,0x08, 
.................... 0x08,0x08,0x88,0xCC,0x64,0x44,0xC4,0x84, 
.................... 0x84,0x84,0x8C,0x82,0x82,0x82,0x82,0x42, 
.................... 0x42,0x66,0x3C,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x38,0xEC,0x84,0x02,0x02,0x01,0x01, 
.................... 0x01,0x02,0x04,0x04,0x04,0x08,0x98,0x10, 
.................... 0x08,0x08,0x84,0x84,0xC4,0x44,0x6C,0x30, 
.................... 0x00,0x00,0x07,0x0E,0x18,0x18,0x18,0x1C, 
.................... 0x1C,0x0F,0x08,0x18,0x10,0x10,0x10,0x10, 
.................... 0x10,0x18,0x0F,0x03,0x0C,0x08,0x08,0x0C, 
.................... 0x0C,0x0C,0x0C,0x0C,0x06,0x07,0x07,0x03, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01, 
.................... 0x03,0x02,0x06,0x04,0x04,0x04,0x04,0x06, 
.................... 0x02,0x03,0x01,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x01,0x03,0x02,0x02,0x06, 
.................... 0x04,0x04,0x04,0x02,0x03,0x01,0x01,0x03, 
.................... 0x06,0x04,0x08,0x08,0x05,0x03,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x10,0x10,0x10,0xF0,0x90,0x10, 
.................... 0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00, 
.................... 0xFF,0xFF,0x01,0x01,0x19,0x01,0x01,0x01, 
.................... 0x01,0x01,0x01,0x39,0x01,0x01,0x01,0xFF, 
.................... 0x00,0x00,0x10,0x10,0xF8,0x10,0x10,0x10, 
.................... 0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0x01,0x01,0x19,0x19,0x01,0x01,0x01, 
.................... 0x01,0x19,0x01,0xFF,0x00,0x00,0x00,0x00, 
.................... 0xE0,0x20,0x3F,0x21,0x21,0x21,0x21,0x3F, 
.................... 0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0xE0,0xE2,0x22,0x3E,0xA3,0xE2, 
.................... 0x22,0x20,0x24,0xFC,0x24,0x64,0x60,0xE0, 
.................... 0xE0,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xB8, 
.................... 0xAC,0xA6,0xEB,0xB5,0x9C,0x87,0x80,0x80, 
.................... 0xFF,0xFF,0x00,0x00,0x18,0x00,0x00,0x00, 
.................... 0x00,0x00,0x04,0x3C,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x01,0x19,0x19,0x01,0x01,0x01,0x01, 
.................... 0x01,0x01,0x19,0x19,0x01,0x01,0x01,0xFF, 
.................... 0x00,0x00,0x20,0x30,0x70,0xF0,0x18,0x08, 
.................... 0x00,0x01,0x03,0x0E,0x7E,0xCC,0x00,0x00, 
.................... 0xFF,0x00,0x00,0xC3,0xC3,0x00,0x00,0x00, 
.................... 0x00,0xC3,0x00,0xFF,0xFC,0x04,0x04,0x04, 
.................... 0x87,0x84,0x04,0x1C,0x04,0x04,0x84,0x84, 
.................... 0x07,0x04,0x04,0x1C,0x04,0x84,0x04,0x04, 
.................... 0x04,0x04,0xFF,0xFF,0x00,0xF0,0x1F,0x00, 
.................... 0x00,0xFC,0x03,0x01,0x00,0x00,0x00,0x00, 
.................... 0x01,0x0F,0xFF,0x00,0x00,0x80,0x80,0xC0, 
.................... 0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00,0x08, 
.................... 0x08,0x08,0x00,0x00,0x1C,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00, 
.................... 0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x86,0x86,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x83,0x83,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x01,0x01,0x11,0x11,0x01,0x01,0x01, 
.................... 0x01,0x01,0x11,0x11,0x01,0x01,0x01,0xFF, 
.................... 0xFF,0x00,0x00,0x30,0x30,0x00,0x00,0x00, 
.................... 0x00,0x30,0x00,0xFF,0xFF,0x00,0x00,0x00, 
.................... 0x31,0x31,0x00,0x00,0x00,0x00,0x31,0x31, 
.................... 0x00,0x00,0x00,0x00,0x00,0x71,0x00,0x00, 
.................... 0x00,0x00,0xFF,0xFF,0x00,0x00,0x0F,0x30, 
.................... 0xE0,0x00,0x03,0x0C,0x30,0x60,0x80,0x00, 
.................... 0x00,0x00,0xFF,0xF0,0x13,0x11,0x91,0x97, 
.................... 0x1C,0x10,0x10,0x13,0x9C,0x14,0x10,0xF0, 
.................... 0xFF,0x00,0x00,0x0F,0x0F,0x00,0x00,0x00, 
.................... 0x04,0x04,0x00,0x00,0x0F,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0xC7,0xC7,0x00,0x00, 
.................... 0x00,0x00,0x00,0x43,0xC0,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x61,0x61,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x61,0x61,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x04,0x04,0x00,0x00,0x00, 
.................... 0x00,0x00,0x04,0x04,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00,0x00, 
.................... 0x00,0x0C,0x00,0xFF,0xFF,0x00,0x00,0x00, 
.................... 0x1C,0x1C,0x00,0x00,0x00,0x00,0x1C,0x1C, 
.................... 0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x00, 
.................... 0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00, 
.................... 0xE1,0x1F,0x00,0x00,0x00,0x00,0x01,0x0F, 
.................... 0xF8,0x00,0xFF,0xFF,0x00,0x00,0xE3,0xE3, 
.................... 0x00,0x00,0x00,0x00,0xE3,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x8F,0x8F,0x00,0x00,0x04, 
.................... 0x04,0x04,0x00,0x00,0x1F,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0x30,0x30,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x73,0x00,0x00,0xFF, 
.................... 0xFF,0x80,0x8C,0x8C,0x80,0x80,0xC0,0xC0, 
.................... 0xC0,0x80,0x8C,0x8C,0x80,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x82,0x82,0x80,0xC0,0xC0, 
.................... 0xC0,0xC0,0x82,0x82,0x80,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x83,0x83,0x80,0x80,0x80, 
.................... 0x80,0x83,0x80,0xFF,0xFF,0x80,0x80,0x80, 
.................... 0x8E,0xCE,0xC0,0xC0,0xC0,0xC0,0xCE,0xCE, 
.................... 0xC0,0xC0,0xC0,0xC0,0xC0,0x8E,0x80,0x80, 
.................... 0x80,0x80,0xFF,0xFF,0x80,0x80,0x80,0xC0, 
.................... 0xBF,0x80,0x80,0x80,0x80,0xA0,0xB0,0x9C, 
.................... 0x87,0x80,0xFF,0xFF,0x80,0x80,0x98,0x98, 
.................... 0x80,0x80,0x80,0x80,0x98,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x87,0x87,0x80,0x80,0x82, 
.................... 0x82,0x82,0x80,0x80,0x87,0x80,0x80,0x80, 
.................... 0xFF,0xFF,0x80,0x80,0x86,0x86,0x80,0x80, 
.................... 0x80,0x80,0x80,0x80,0x86,0x80,0x80,0xFF}; 
.................... /* 
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01\ 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x00, 0x41, 0x49, 0x49, 0x36, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x00, 0x27, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x00, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x7e, 0x00, // A      34 
....................                          0x7F, 0x49, 0x49, 0x36, 0x00, // B 
....................                          0x3E, 0x41, 0x41, 0x22, 0x00, // C 
....................                          0x7F, 0x41, 0x41, 0x3e, 0x00, // D      37 
....................                          0x7F, 0x49, 0x49, 0x41, 0x00, // E 
....................                          0x7F, 0x09, 0x09, 0x01, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x08, 0x7f, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x3f, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x3e, 0x00, // O 
....................                          0x7F, 0x09, 0x09, 0x06, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x09, 0x76, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x32, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x40, 0x3f, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x08, 0x04, 0x78, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x04, 0x78, 0x00, // n 
....................                          0x38, 0x44, 0x44, 0x38, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x00, 0x3c, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x3c, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... */ 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x41, 0x49, 0x49, 0x36, 0x00, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x27, 0x45, 0x45, 0x39, 0x00, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x71, 0x09, 0x09, 0x07, 0x00,  // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x7e, 0x00, 0x00, // A      34 
....................                          0x7F, 0x49, 0x36, 0x00, 0x00, // B 
....................                          0x3E, 0x41, 0x22, 0x00, 0x00, // C 
....................                          0x7F, 0x41, 0x3e, 0x00, 0x00, // D      37 
....................                          0x7F, 0x49, 0x41, 0x00, 0x00, // E 
....................                          0x7F, 0x09, 0x01, 0x00, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x7f, 0x00, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x3f, 0x00, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x3e, 0x00, 0x00, // O 
....................                          0x7F, 0x09, 0x06, 0x00, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x76, 0x00, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x32, 0x00, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x3f, 0x00, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x00, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x04, 0x78, 0x00, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x78, 0x00, 0x00, // n 
....................                          0x38, 0x44, 0x38, 0x00, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x3c, 0x40, 0x7c, 0x00, 0x00, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x3c, 0x00, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... #define HMF6598_RS    pin_A0 
.................... #define HMF6598_RES   pin_A1 
.................... #define HMF6598_CS1   pin_A2 
.................... #define HMF6598_RD    pin_A3 
.................... #define HMF6598_WR    pin_A4 
....................  
.................... #define ON   1 
.................... #define OFF  0 
....................  
.................... int8 CurrentLine = 0; 
.................... int8 QuantChrLine = 0; 
.................... int8 OffsetX = 0; 
....................  
.................... void    HMF6598_InitLcd(void); 
.................... void    HMF6598_Write_command(char byte_command); 
.................... void    HMF6598_Write_data(char byte_data); 
.................... char    HMF6598_Read_data(); 
.................... void    HMF6598_Gotoxy(int8 x, int y); 
.................... void    HMF6598_Printchar(char cvar); 
.................... void    HMF6598_PutPixel(int8 x,int8 y, int1 COLOR); 
.................... void    HMF6598_OutPort(char byteDC); 
.................... void    clear_screen(void); 
.................... void    newLine(void); 
.................... void    HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR); 
.................... void    HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR); 
....................  
.................... void    HMF6598_InitLcd(void){ 
....................     
....................    output_low(HMF6598_CS1); // Chip Enabled 
*
065C:  BCF    F92.2
065E:  BCF    F89.2
....................    output_low(HMF6598_RES); 
0660:  BCF    F92.1
0662:  BCF    F89.1
....................    delay_us(200); 
0664:  MOVLW  C8
0666:  MOVWF  25
0668:  RCALL  0520
....................    output_high(HMF6598_RES);  
066A:  BCF    F92.1
066C:  BSF    F89.1
....................    delay_us(200);    
066E:  MOVLW  C8
0670:  MOVWF  25
0672:  RCALL  0520
....................  
....................    HMF6598_Write_command(0xc8);   // Duty = 65    
0674:  MOVLW  C8
0676:  MOVWF  2F
0678:  RCALL  055C
....................    HMF6598_Write_command(0xa3);   // BIAS 1/9 
067A:  MOVLW  A3
067C:  MOVWF  2F
067E:  RCALL  055C
....................    HMF6598_Write_command(0xa0);   // ADC Select 
0680:  MOVLW  A0
0682:  MOVWF  2F
0684:  RCALL  055C
....................    HMF6598_Write_command(0xa6);   // Normal display 0xa6:  Reverse Display :0xa7 
0686:  MOVLW  A6
0688:  MOVWF  2F
068A:  RCALL  055C
....................    HMF6598_Write_command(0x2c);   //---------------------------------------------  
068C:  MOVLW  2C
068E:  MOVWF  2F
0690:  RCALL  055C
....................    delay_ms(3);                   // 
0692:  MOVLW  03
0694:  MOVWF  25
0696:  RCALL  0568
....................    HMF6598_Write_command(0x2e);   // Power Control Set VR, VC, VF  
0698:  MOVLW  2E
069A:  MOVWF  2F
069C:  RCALL  055C
....................    delay_ms(3);                   // 
069E:  MOVLW  03
06A0:  MOVWF  25
06A2:  RCALL  0568
....................    HMF6598_Write_command(0x2f);   //--------------------------------------------- 
06A4:  MOVLW  2F
06A6:  MOVWF  2F
06A8:  RCALL  055C
....................    HMF6598_Write_command(0x20);   // 1+Rb/Ra Ratio    
06AA:  MOVLW  20
06AC:  MOVWF  2F
06AE:  RCALL  055C
....................    HMF6598_Write_command(0x40);   // EVER register Set    
06B0:  MOVLW  40
06B2:  MOVWF  2F
06B4:  RCALL  055C
....................     
....................    //Set Brightness   
....................    HMF6598_Write_command(0x81);  
06B6:  MOVLW  81
06B8:  MOVWF  2F
06BA:  RCALL  055C
....................    HMF6598_Write_command(0x32); 
06BC:  MOVLW  32
06BE:  MOVWF  2F
06C0:  RCALL  055C
....................     
....................    HMF6598_Write_command(0xe0);   // Set Modify Read  0xee to cancel / 0xe0 to activate 
06C2:  MOVLW  E0
06C4:  MOVWF  2F
06C6:  RCALL  055C
....................  
....................    clear_screen(); 
06C8:  BRA    062C
....................    HMF6598_Write_command(0xaf);   // Display ON 
06CA:  MOVLW  AF
06CC:  MOVWF  2F
06CE:  RCALL  055C
.................... } 
06D0:  GOTO   08C4 (RETURN)
....................  
.................... void HMF6598_OutPort(char byteDC){ 
....................   set_tris_b(0x00); 
*
0540:  MOVLW  00
0542:  MOVWF  F93
....................   output_low(HMF6598_CS1); 
0544:  BCF    F92.2
0546:  BCF    F89.2
....................   output_high(HMF6598_RD);  
0548:  BCF    F92.3
054A:  BSF    F89.3
....................   output_low(HMF6598_WR);   
054C:  BCF    F92.4
054E:  BCF    F89.4
....................   output_b(byteDC); 
0550:  CLRF   F93
0552:  MOVFF  30,F8A
....................   output_high(HMF6598_CS1);     
0556:  BCF    F92.2
0558:  BSF    F89.2
.................... } 
055A:  RETLW  00
.................... void    HMF6598_Write_command(char byte_command){ 
....................   output_low(HMF6598_RS);          // Write Command Enabled 
055C:  BCF    F92.0
055E:  BCF    F89.0
....................   HMF6598_OutPort(byte_command); 
0560:  MOVFF  2F,30
0564:  RCALL  0540
.................... } 
0566:  RETLW  00
.................... void    HMF6598_Write_data(char byte_data){ 
....................   output_high(HMF6598_RS);         // Write data Enabled 
*
0614:  BCF    F92.0
0616:  BSF    F89.0
....................   HMF6598_OutPort(byte_data); 
0618:  MOVFF  2A,30
061C:  RCALL  0540
....................   OffsetX++; 
061E:  INCF   1B,F
....................   HMF6598_Gotoxy(OffsetX,CurrentLine); 
0620:  MOVFF  1B,2B
0624:  MOVFF  19,2C
0628:  RCALL  05B8
.................... } 
062A:  RETLW  00
....................  
.................... char    HMF6598_Read_data(){ 
....................  
.................... /*  set_tris_b(0xff); 
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................    
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1);    */  
....................    
....................   set_tris_b(0xff);     
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................   output_low(HMF6598_CS1); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1); 
.................... } 
....................  
.................... void newLine(){ 
....................   if(CurrentLine < 7){  // New Line Command 
....................       HMF6598_Write_command((CurrentLine+1)|0xb0);  // Set Page Address to 0 (0 a 7) 
....................       HMF6598_Write_command(0x00);  // Set LSB for index Column 
....................       HMF6598_Write_command(0x10);  // Set MSB for index Column    
....................       CurrentLine+=1; 
....................   } 
....................   QuantChrLine = 1; 
....................   OffsetX = 0; 
.................... } 
.................... void clear_screen(void) { 
....................    int p, c; 
....................    for(p = 0; p < 8; p++) { 
062C:  CLRF   25
062E:  MOVF   25,W
0630:  SUBLW  07
0632:  BNC   0652
....................       for(c = 0; c < 128; c++) { 
0634:  CLRF   26
0636:  MOVF   26,W
0638:  SUBLW  7F
063A:  BNC   064E
....................          HMF6598_Gotoxy(c,p); 
063C:  MOVFF  26,2B
0640:  MOVFF  25,2C
0644:  RCALL  05B8
....................          HMF6598_Write_data(0x00); 
0646:  CLRF   2A
0648:  RCALL  0614
....................       } 
064A:  INCF   26,F
064C:  BRA    0636
....................    } 
064E:  INCF   25,F
0650:  BRA    062E
....................    HMF6598_Gotoxy(0,0);    
0652:  CLRF   2B
0654:  CLRF   2C
0656:  RCALL  05B8
.................... } 
0658:  GOTO   06CA (RETURN)
.................... void    HMF6598_Gotoxy(int x, int y){ 
*
05B8:  CLRF   2D
....................    int8 OffsetChr = 0; 
....................     
....................    HMF6598_Write_command(0xb0 | y); 
05BA:  MOVF   2C,W
05BC:  IORLW  B0
05BE:  MOVWF  2E
05C0:  MOVWF  2F
05C2:  RCALL  055C
....................    HMF6598_Write_command((0x00 | x) & 0x0f); 
05C4:  MOVF   2B,W
05C6:  ANDLW  0F
05C8:  MOVWF  2E
05CA:  MOVWF  2F
05CC:  RCALL  055C
....................    HMF6598_Write_command(0x10|(x>>4)); 
05CE:  SWAPF  2B,W
05D0:  MOVWF  00
05D2:  MOVLW  0F
05D4:  ANDWF  00,F
05D6:  MOVF   00,W
05D8:  IORLW  10
05DA:  MOVWF  2E
05DC:  MOVWF  2F
05DE:  RCALL  055C
....................     
....................    OffsetChr = (x+1)/6; 
05E0:  MOVLW  01
05E2:  ADDWF  2B,W
05E4:  MOVWF  2F
05E6:  MOVWF  30
05E8:  MOVLW  06
05EA:  MOVWF  31
05EC:  RCALL  0590
05EE:  MOVFF  01,2D
....................    if((x+1)%6) 
05F2:  MOVLW  01
05F4:  ADDWF  2B,W
05F6:  MOVWF  2F
05F8:  MOVWF  30
05FA:  MOVLW  06
05FC:  MOVWF  31
05FE:  RCALL  0590
0600:  MOVF   00,W
0602:  BZ    0606
....................       OffsetChr++;    
0604:  INCF   2D,F
....................    CurrentLine = y; 
0606:  MOVFF  2C,19
....................    QuantChrLine = OffsetChr; 
060A:  MOVFF  2D,1A
....................    OffsetX = x; 
060E:  MOVFF  2B,1B
.................... } 
0612:  RETLW  00
.................... void    HMF6598_Printchar(char cvar){ 
....................    int i; 
....................    if (QuantChrLine > 21)   
....................        newLine();  
....................    else 
....................        QuantChrLine++;     
....................    if(cvar == 0x20) 
....................       for(i=0;i<2;i++) 
....................          HMF6598_Write_data(0x00); 
....................    else{ 
....................       for(i=0;i<5;i++){ 
....................          if (cvar < 0x53){ 
....................             if(TEXT[cvar-0x20][i])          
....................                HMF6598_Write_data(TEXT[cvar-0x20][i]);       
....................          } 
....................          else { 
....................             if(TEXT2[cvar-0x53][i])                
....................                HMF6598_Write_data(TEXT2[cvar-0x53][i]);                
....................          } 
....................       } 
....................    } 
....................    HMF6598_Write_data(0x00); 
.................... } 
.................... void HMF6598_PutPixel(int x, int y, int1 COLOR){ 
....................    char BytePlot = 0, tempByte; 
....................    if((x > 127)||(y > 63)) 
....................       return; 
....................    BytePlot |= 1; 
....................    BytePlot<<=(y%8); 
....................    tempByte = BytePlot; 
....................    HMF6598_Gotoxy(x,(y/8)); 
....................    BytePlot|=HMF6598_Read_data(); 
....................    if(COLOR == OFF) 
....................       BytePlot-=tempByte; 
....................    HMF6598_Write_data(BytePlot); 
.................... } 
....................  
.................... void HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR){ 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................    do{ 
....................       if(fill){ 
....................          HMF6598_line(x-a, y+b, x+a, y+b, color); 
....................          HMF6598_line(x-a, y-b, x+a, y-b, color); 
....................          HMF6598_line(x-b, y+a, x+b, y+a, color); 
....................          HMF6598_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else{ 
....................          HMF6598_PutPixel(a+x, b+y, color); 
....................          HMF6598_PutPixel(b+x, a+y, color); 
....................          HMF6598_PutPixel(x-a, b+y, color); 
....................          HMF6598_PutPixel(x-b, a+y, color); 
....................          HMF6598_PutPixel(b+x, y-a, color); 
....................          HMF6598_PutPixel(a+x, y-b, color); 
....................          HMF6598_PutPixel(x-a, y-b, color); 
....................          HMF6598_PutPixel(x-b, y-a, color); 
....................       } 
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... void HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR){ 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................  
....................    if(x1 > x2) 
....................       addx = -1; 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................       addy = -1; 
....................    else 
....................       addy = 1; 
....................    if(dx >= dy){ 
....................       P = 2*dy - dx; 
....................       for(i=0; i<=dx; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................          if(P < 0){ 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else{ 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else{ 
....................       P = 2*dx - dy; 
....................       for(i=0; i<=dy; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................  
....................          if(P < 0){ 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else{ 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... int x_ext, y_ext; 
.................... int t = 0, i, j; 
....................  
.................... void putSprite(int x, int y){ 
....................    const BYTE bloco[8] = {0xFF,0xFF,0x81,0x81,0x81,0x81,0xFF,0xFF}; 
....................    int i; 
....................    char Sp1, Sp2; 
....................    if(x < 121) 
*
06F2:  MOVF   25,W
06F4:  SUBLW  78
06F6:  BNC   06FC
....................       x_ext = x; 
06F8:  MOVFF  25,1E
....................    if(y < 57) 
06FC:  MOVF   26,W
06FE:  SUBLW  38
0700:  BNC   0706
....................       y_ext = y; 
0702:  MOVFF  26,1F
....................    for(i=0;i<8;i++){ 
0706:  CLRF   27
0708:  MOVF   27,W
070A:  SUBLW  07
070C:  BTFSS  FD8.0
070E:  BRA    0898
....................       Sp1 = bloco[i] <<(y_ext%8); 
0710:  CLRF   03
0712:  MOVF   27,W
0714:  RCALL  04BC
0716:  MOVWF  2A
0718:  MOVF   1F,W
071A:  ANDLW  07
071C:  MOVWF  01
071E:  MOVFF  2A,28
0722:  MOVF   01,F
0724:  BZ    072E
0726:  BCF    FD8.0
0728:  RLCF   28,F
072A:  DECFSZ 01,F
072C:  BRA    0726
....................       Sp2 = bloco[i] >>(8-(y_ext%8));       
072E:  CLRF   03
0730:  MOVF   27,W
0732:  RCALL  04BC
0734:  MOVWF  2A
0736:  MOVF   1F,W
0738:  ANDLW  07
073A:  XORLW  FF
073C:  ADDLW  09
073E:  MOVWF  01
0740:  MOVFF  2A,29
0744:  MOVF   01,F
0746:  BZ    0750
0748:  BCF    FD8.0
074A:  RRCF   29,F
074C:  DECFSZ 01,F
074E:  BRA    0748
....................       if (x_ext + t > 127){ 
0750:  MOVF   20,W
0752:  ADDWF  1E,W
0754:  SUBLW  7F
0756:  BC    07DA
....................          Sp1 |= cenario[y_ext/8][x_ext+t-128]; 
0758:  RRCF   1F,W
075A:  MOVWF  00
075C:  RRCF   00,F
075E:  RRCF   00,F
0760:  MOVLW  1F
0762:  ANDWF  00,F
0764:  MOVFF  00,2B
0768:  CLRF   2D
076A:  MOVFF  00,2C
076E:  CLRF   2F
0770:  MOVLW  80
0772:  MOVWF  2E
0774:  RCALL  06D4
0776:  MOVFF  02,2B
077A:  MOVFF  01,2A
077E:  MOVF   20,W
0780:  ADDWF  1E,W
0782:  ADDLW  80
0784:  ADDWF  01,W
0786:  MOVWF  01
0788:  MOVLW  00
078A:  ADDWFC 02,W
078C:  MOVWF  03
078E:  MOVF   01,W
0790:  MOVFF  03,FF7
0794:  RCALL  00AE
0796:  IORWF  28,F
....................          Sp2 |= cenario[(y_ext/8)+1][x_ext+t-128];          
0798:  RRCF   1F,W
079A:  MOVWF  00
079C:  RRCF   00,F
079E:  RRCF   00,F
07A0:  MOVLW  1F
07A2:  ANDWF  00,F
07A4:  MOVF   00,W
07A6:  ADDLW  01
07A8:  MOVWF  2B
07AA:  CLRF   2D
07AC:  MOVWF  2C
07AE:  CLRF   2F
07B0:  MOVLW  80
07B2:  MOVWF  2E
07B4:  RCALL  06D4
07B6:  MOVFF  02,2B
07BA:  MOVFF  01,2A
07BE:  MOVF   20,W
07C0:  ADDWF  1E,W
07C2:  ADDLW  80
07C4:  ADDWF  01,W
07C6:  MOVWF  01
07C8:  MOVLW  00
07CA:  ADDWFC 02,W
07CC:  MOVWF  03
07CE:  MOVF   01,W
07D0:  MOVFF  03,FF7
07D4:  RCALL  00AE
07D6:  IORWF  29,F
....................       } 
....................       else{ 
07D8:  BRA    0856
....................          Sp1 |= cenario[y_ext/8][x_ext+t];       
07DA:  RRCF   1F,W
07DC:  MOVWF  00
07DE:  RRCF   00,F
07E0:  RRCF   00,F
07E2:  MOVLW  1F
07E4:  ANDWF  00,F
07E6:  MOVFF  00,2B
07EA:  CLRF   2D
07EC:  MOVFF  00,2C
07F0:  CLRF   2F
07F2:  MOVLW  80
07F4:  MOVWF  2E
07F6:  RCALL  06D4
07F8:  MOVFF  02,2B
07FC:  MOVFF  01,2A
0800:  MOVF   20,W
0802:  ADDWF  1E,W
0804:  ADDWF  01,W
0806:  MOVWF  01
0808:  MOVLW  00
080A:  ADDWFC 02,W
080C:  MOVWF  03
080E:  MOVF   01,W
0810:  MOVFF  03,FF7
0814:  RCALL  00AE
0816:  IORWF  28,F
....................          Sp2 |= cenario[(y_ext/8)+1][x_ext+t]; 
0818:  RRCF   1F,W
081A:  MOVWF  00
081C:  RRCF   00,F
081E:  RRCF   00,F
0820:  MOVLW  1F
0822:  ANDWF  00,F
0824:  MOVF   00,W
0826:  ADDLW  01
0828:  MOVWF  2B
082A:  CLRF   2D
082C:  MOVWF  2C
082E:  CLRF   2F
0830:  MOVLW  80
0832:  MOVWF  2E
0834:  RCALL  06D4
0836:  MOVFF  02,2B
083A:  MOVFF  01,2A
083E:  MOVF   20,W
0840:  ADDWF  1E,W
0842:  ADDWF  01,W
0844:  MOVWF  01
0846:  MOVLW  00
0848:  ADDWFC 02,W
084A:  MOVWF  03
084C:  MOVF   01,W
084E:  MOVFF  03,FF7
0852:  RCALL  00AE
0854:  IORWF  29,F
....................       } 
....................       HMF6598_Gotoxy(x_ext,(y_ext/8)); 
0856:  RRCF   1F,W
0858:  MOVWF  2A
085A:  RRCF   2A,F
085C:  RRCF   2A,F
085E:  MOVLW  1F
0860:  ANDWF  2A,F
0862:  MOVFF  1E,2B
0866:  MOVFF  2A,2C
086A:  RCALL  05B8
....................       HMF6598_Write_data(Sp1); 
086C:  MOVFF  28,2A
0870:  RCALL  0614
....................       HMF6598_Gotoxy(x_ext,(y_ext/8)+1);  
0872:  RRCF   1F,W
0874:  MOVWF  00
0876:  RRCF   00,F
0878:  RRCF   00,F
087A:  MOVLW  1F
087C:  ANDWF  00,F
087E:  MOVF   00,W
0880:  ADDLW  01
0882:  MOVWF  2A
0884:  MOVFF  1E,2B
0888:  MOVWF  2C
088A:  RCALL  05B8
....................       HMF6598_Write_data(Sp2); 
088C:  MOVFF  29,2A
0890:  RCALL  0614
....................       x_ext++; 
0892:  INCF   1E,F
....................    } 
0894:  INCF   27,F
0896:  BRA    0708
....................    x_ext -= 8; 
0898:  MOVLW  08
089A:  SUBWF  1E,F
.................... } 
089C:  GOTO   096A (RETURN)
....................  
.................... #INT_TIMER0 
.................... void RTTC_isr(void){ 
....................    //output_toggle(pin_d0);  
....................    if(!input(pin_D7)){  // Direita 
*
04D4:  BSF    F95.7
04D6:  BTFSC  F83.7
04D8:  BRA    04E4
....................       if(x_ext < 120) 
04DA:  MOVF   1E,W
04DC:  SUBLW  77
04DE:  BNC   04E4
....................          x_ext = x_ext + 1; 
04E0:  MOVLW  01
04E2:  ADDWF  1E,F
....................    } 
....................    if(!input(pin_D6)){  // Cima 
04E4:  BSF    F95.6
04E6:  BTFSC  F83.6
04E8:  BRA    04F2
....................       if(y_ext > 0) 
04EA:  MOVF   1F,F
04EC:  BZ    04F2
....................          y_ext = y_ext - 1;      
04EE:  MOVLW  01
04F0:  SUBWF  1F,F
....................    } 
....................    if(!input(pin_D5)){  // Baixo 
04F2:  BSF    F95.5
04F4:  BTFSC  F83.5
04F6:  BRA    0502
....................       if(y_ext < 55) 
04F8:  MOVF   1F,W
04FA:  SUBLW  36
04FC:  BNC   0502
....................          y_ext = y_ext + 1;       
04FE:  MOVLW  01
0500:  ADDWF  1F,F
....................    } 
....................    if(!input(pin_D4)){  // Esquerda 
0502:  BSF    F95.4
0504:  BTFSC  F83.4
0506:  BRA    0510
....................       if(x_ext > 0) 
0508:  MOVF   1E,F
050A:  BZ    0510
....................          x_ext = x_ext - 1;       
050C:  MOVLW  01
050E:  SUBWF  1E,F
....................    } 
....................    disable_interrupts (INT_TIMER0);  
0510:  BCF    FF2.5
....................    disable_interrupts(GLOBAL);     
0512:  BCF    FF2.6
0514:  BCF    FF2.7
0516:  BTFSC  FF2.7
0518:  BRA    0514
.................... } 
....................  
051A:  BCF    FF2.2
051C:  GOTO   0060
.................... void main(void){ 
*
08A0:  CLRF   FF8
08A2:  BCF    FD0.7
08A4:  BSF    07.7
08A6:  CLRF   FEA
08A8:  CLRF   FE9
08AA:  CLRF   19
08AC:  CLRF   1A
08AE:  CLRF   1B
08B0:  CLRF   20
08B2:  MOVF   FC1,W
08B4:  ANDLW  C0
08B6:  IORLW  0F
08B8:  MOVWF  FC1
08BA:  MOVLW  07
08BC:  MOVWF  FB4
08BE:  CLRF   1C
08C0:  CLRF   1D
....................    int i, j; 
....................    HMF6598_InitLcd(); 
08C2:  BRA    065C
....................    setup_timer_0 (RTCC_DIV_4); 
08C4:  MOVLW  81
08C6:  MOVWF  FD5
....................    // ------ SPRITE DE FUNDO rolando ------- 
....................    x_ext = 3; 
08C8:  MOVLW  03
08CA:  MOVWF  1E
....................    y_ext = 3; 
08CC:  MOVWF  1F
....................    while(true){ 
....................       for(i=0;i<8;i++){ 
08CE:  CLRF   23
08D0:  MOVF   23,W
08D2:  SUBLW  07
08D4:  BNC   0960
....................          HMF6598_Gotoxy(0,i); 
08D6:  CLRF   2B
08D8:  MOVFF  23,2C
08DC:  RCALL  05B8
....................          for(j=t;j<128;j++) 
08DE:  MOVFF  20,24
08E2:  MOVF   24,W
08E4:  SUBLW  7F
08E6:  BNC   091E
....................             HMF6598_Write_data(cenario[i][j]);            
08E8:  CLRF   2D
08EA:  MOVFF  23,2C
08EE:  CLRF   2F
08F0:  MOVLW  80
08F2:  MOVWF  2E
08F4:  RCALL  06D4
08F6:  MOVFF  02,26
08FA:  MOVFF  01,25
08FE:  MOVF   24,W
0900:  ADDWF  01,W
0902:  MOVWF  01
0904:  MOVLW  00
0906:  ADDWFC 02,W
0908:  MOVWF  03
090A:  MOVF   01,W
090C:  MOVFF  03,FF7
0910:  CALL   00AE
0914:  MOVWF  25
0916:  MOVWF  2A
0918:  RCALL  0614
091A:  INCF   24,F
091C:  BRA    08E2
....................          for(j=0;j<t;j++)    
091E:  CLRF   24
0920:  MOVF   20,W
0922:  SUBWF  24,W
0924:  BC    095C
....................             HMF6598_Write_data(cenario[i][j]); 
0926:  CLRF   2D
0928:  MOVFF  23,2C
092C:  CLRF   2F
092E:  MOVLW  80
0930:  MOVWF  2E
0932:  RCALL  06D4
0934:  MOVFF  02,26
0938:  MOVFF  01,25
093C:  MOVF   24,W
093E:  ADDWF  01,W
0940:  MOVWF  01
0942:  MOVLW  00
0944:  ADDWFC 02,W
0946:  MOVWF  03
0948:  MOVF   01,W
094A:  MOVFF  03,FF7
094E:  CALL   00AE
0952:  MOVWF  25
0954:  MOVWF  2A
0956:  RCALL  0614
0958:  INCF   24,F
095A:  BRA    0920
....................       } 
095C:  INCF   23,F
095E:  BRA    08D0
....................       putSprite(x_ext, y_ext); 
0960:  MOVFF  1E,25
0964:  MOVFF  1F,26
0968:  BRA    06F2
....................       set_timer0(0); 
096A:  CLRF   FD7
096C:  CLRF   FD6
....................       enable_interrupts (INT_TIMER0);  
096E:  BSF    FF2.5
....................       enable_interrupts(GLOBAL);        
0970:  MOVLW  C0
0972:  IORWF  FF2,F
....................       delay_ms(40); 
0974:  MOVLW  28
0976:  MOVWF  25
0978:  RCALL  0568
....................       t++; 
097A:  INCF   20,F
....................       if(t>127) 
097C:  MOVF   20,W
097E:  SUBLW  7F
0980:  BC    0984
....................          t = 0; 
0982:  CLRF   20
....................    } 
0984:  BRA    08CE
....................    // -------------------------------------- 
.................... } 
0986:  SLEEP 

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV20 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICPRT NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
