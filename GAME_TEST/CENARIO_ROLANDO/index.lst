CCS PCH C Compiler, Version 4.114, 93460303               20-abr-13 20:30

               Filename: D:\SkyDrive\Eletronica\PROJETOS PIC CCS\GAME_TEST\CENARIO_ROLANDO\index.lst

               ROM used: 2716 bytes (8%)
                         Largest free fragment is 30052
               RAM used: 17 (1%) at main() level
                         29 (1%) worst case
               Stack:    6 locations

*
0000:  GOTO   071A
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #use delay(clock=48000000) 
*
042A:  MOVLW  01
042C:  SUBWF  0E,F
042E:  BNC   0448
0430:  CLRF   FEA
0432:  MOVLW  0E
0434:  MOVWF  FE9
0436:  MOVF   FEF,W
0438:  BZ    0448
043A:  MOVLW  02
043C:  MOVWF  00
043E:  DECFSZ 00,F
0440:  BRA    043E
0442:  BRA    0444
0444:  DECFSZ FEF,F
0446:  BRA    043A
0448:  RETLW  00
*
0472:  CLRF   FEA
0474:  MOVLW  0E
0476:  MOVWF  FE9
0478:  MOVF   FEF,W
047A:  BZ    0498
047C:  MOVLW  0F
047E:  MOVWF  01
0480:  CLRF   00
0482:  DECFSZ 00,F
0484:  BRA    0482
0486:  DECFSZ 01,F
0488:  BRA    0480
048A:  MOVLW  8F
048C:  MOVWF  00
048E:  DECFSZ 00,F
0490:  BRA    048E
0492:  NOP   
0494:  DECFSZ FEF,F
0496:  BRA    047C
0498:  RETLW  00
.................... #fuses HSPLL, PLL4, CPUDIV1, PUT, NOWDT, NOBROWNOUT, NOLVP 
.................... #include "HMF6598SYH-PY.c" 
.................... const BYTE cenario[8][128] =  
.................... { 
.................... 0x00,0x00,0x80,0xC0,0x40,0x70,0x0C,0x04, 
.................... 0x04,0x04,0x04,0x0C,0x18,0x38,0x0C,0x04, 
.................... 0x04,0x04,0x04,0x0C,0x18,0x18,0x0C,0x04, 
.................... 0x04,0x04,0x0C,0x08,0x08,0x18,0xF0,0xE0, 
.................... 0x00,0x00,0x00,0x00,0x00,0x78,0xCC,0x8C, 
.................... 0x84,0x84,0x04,0x0C,0x18,0x0C,0x84,0x84, 
.................... 0xC4,0x44,0x74,0x18,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x10,0x28,0x24,0x24,0x18,0x00, 
.................... 0x00,0x00,0x00,0x00,0x20,0xFC,0x84,0x04, 
.................... 0x06,0x0E,0x12,0x02,0x02,0x02,0x04,0x08, 
.................... 0x08,0x08,0x88,0xCC,0x64,0x44,0xC4,0x84, 
.................... 0x84,0x84,0x8C,0x82,0x82,0x82,0x82,0x42, 
.................... 0x42,0x66,0x3C,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x38,0xEC,0x84,0x02,0x02,0x01,0x01, 
.................... 0x01,0x02,0x04,0x04,0x04,0x08,0x98,0x10, 
.................... 0x08,0x08,0x84,0x84,0xC4,0x44,0x6C,0x30, 
.................... 0x00,0x00,0x07,0x0E,0x18,0x18,0x18,0x1C, 
.................... 0x1C,0x0F,0x08,0x18,0x10,0x10,0x10,0x10, 
.................... 0x10,0x18,0x0F,0x03,0x0C,0x08,0x08,0x0C, 
.................... 0x0C,0x0C,0x0C,0x0C,0x06,0x07,0x07,0x03, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01, 
.................... 0x03,0x02,0x06,0x04,0x04,0x04,0x04,0x06, 
.................... 0x02,0x03,0x01,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x01,0x03,0x02,0x02,0x06, 
.................... 0x04,0x04,0x04,0x02,0x03,0x01,0x01,0x03, 
.................... 0x06,0x04,0x08,0x08,0x05,0x03,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x10,0x10,0x10,0xF0,0x90,0x10, 
.................... 0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00, 
.................... 0xFF,0xFF,0x01,0x01,0x19,0x01,0x01,0x01, 
.................... 0x01,0x01,0x01,0x39,0x01,0x01,0x01,0xFF, 
.................... 0x00,0x00,0x10,0x10,0xF8,0x10,0x10,0x10, 
.................... 0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0x01,0x01,0x19,0x19,0x01,0x01,0x01, 
.................... 0x01,0x19,0x01,0xFF,0x00,0x00,0x00,0x00, 
.................... 0xE0,0x20,0x3F,0x21,0x21,0x21,0x21,0x3F, 
.................... 0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0xE0,0xE2,0x22,0x3E,0xA3,0xE2, 
.................... 0x22,0x20,0x24,0xFC,0x24,0x64,0x60,0xE0, 
.................... 0xE0,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xB8, 
.................... 0xAC,0xA6,0xEB,0xB5,0x9C,0x87,0x80,0x80, 
.................... 0xFF,0xFF,0x00,0x00,0x18,0x00,0x00,0x00, 
.................... 0x00,0x00,0x04,0x3C,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x01,0x19,0x19,0x01,0x01,0x01,0x01, 
.................... 0x01,0x01,0x19,0x19,0x01,0x01,0x01,0xFF, 
.................... 0x00,0x00,0x20,0x30,0x70,0xF0,0x18,0x08, 
.................... 0x00,0x01,0x03,0x0E,0x7E,0xCC,0x00,0x00, 
.................... 0xFF,0x00,0x00,0xC3,0xC3,0x00,0x00,0x00, 
.................... 0x00,0xC3,0x00,0xFF,0xFC,0x04,0x04,0x04, 
.................... 0x87,0x84,0x04,0x1C,0x04,0x04,0x84,0x84, 
.................... 0x07,0x04,0x04,0x1C,0x04,0x84,0x04,0x04, 
.................... 0x04,0x04,0xFF,0xFF,0x00,0xF0,0x1F,0x00, 
.................... 0x00,0xFC,0x03,0x01,0x00,0x00,0x00,0x00, 
.................... 0x01,0x0F,0xFF,0x00,0x00,0x80,0x80,0xC0, 
.................... 0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00,0x08, 
.................... 0x08,0x08,0x00,0x00,0x1C,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00, 
.................... 0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x86,0x86,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x83,0x83,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x01,0x01,0x11,0x11,0x01,0x01,0x01, 
.................... 0x01,0x01,0x11,0x11,0x01,0x01,0x01,0xFF, 
.................... 0xFF,0x00,0x00,0x30,0x30,0x00,0x00,0x00, 
.................... 0x00,0x30,0x00,0xFF,0xFF,0x00,0x00,0x00, 
.................... 0x31,0x31,0x00,0x00,0x00,0x00,0x31,0x31, 
.................... 0x00,0x00,0x00,0x00,0x00,0x71,0x00,0x00, 
.................... 0x00,0x00,0xFF,0xFF,0x00,0x00,0x0F,0x30, 
.................... 0xE0,0x00,0x03,0x0C,0x30,0x60,0x80,0x00, 
.................... 0x00,0x00,0xFF,0xF0,0x13,0x11,0x91,0x97, 
.................... 0x1C,0x10,0x10,0x13,0x9C,0x14,0x10,0xF0, 
.................... 0xFF,0x00,0x00,0x0F,0x0F,0x00,0x00,0x00, 
.................... 0x04,0x04,0x00,0x00,0x0F,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0xC7,0xC7,0x00,0x00, 
.................... 0x00,0x00,0x00,0x43,0xC0,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x61,0x61,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x61,0x61,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x04,0x04,0x00,0x00,0x00, 
.................... 0x00,0x00,0x04,0x04,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00,0x00, 
.................... 0x00,0x0C,0x00,0xFF,0xFF,0x00,0x00,0x00, 
.................... 0x1C,0x1C,0x00,0x00,0x00,0x00,0x1C,0x1C, 
.................... 0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x00, 
.................... 0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00, 
.................... 0xE1,0x1F,0x00,0x00,0x00,0x00,0x01,0x0F, 
.................... 0xF8,0x00,0xFF,0xFF,0x00,0x00,0xE3,0xE3, 
.................... 0x00,0x00,0x00,0x00,0xE3,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x8F,0x8F,0x00,0x00,0x04, 
.................... 0x04,0x04,0x00,0x00,0x1F,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0x30,0x30,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x73,0x00,0x00,0xFF, 
.................... 0xFF,0x80,0x8C,0x8C,0x80,0x80,0xC0,0xC0, 
.................... 0xC0,0x80,0x8C,0x8C,0x80,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x82,0x82,0x80,0xC0,0xC0, 
.................... 0xC0,0xC0,0x82,0x82,0x80,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x83,0x83,0x80,0x80,0x80, 
.................... 0x80,0x83,0x80,0xFF,0xFF,0x80,0x80,0x80, 
.................... 0x8E,0xCE,0xC0,0xC0,0xC0,0xC0,0xCE,0xCE, 
.................... 0xC0,0xC0,0xC0,0xC0,0xC0,0x8E,0x80,0x80, 
.................... 0x80,0x80,0xFF,0xFF,0x80,0x80,0x80,0xC0, 
.................... 0xBF,0x80,0x80,0x80,0x80,0xA0,0xB0,0x9C, 
.................... 0x87,0x80,0xFF,0xFF,0x80,0x80,0x98,0x98, 
.................... 0x80,0x80,0x80,0x80,0x98,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x87,0x87,0x80,0x80,0x82, 
.................... 0x82,0x82,0x80,0x80,0x87,0x80,0x80,0x80, 
.................... 0xFF,0xFF,0x80,0x80,0x86,0x86,0x80,0x80, 
.................... 0x80,0x80,0x80,0x80,0x86,0x80,0x80,0xFF}; 
.................... /* 
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01\ 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x00, 0x41, 0x49, 0x49, 0x36, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x00, 0x27, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x00, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x7e, 0x00, // A      34 
....................                          0x7F, 0x49, 0x49, 0x36, 0x00, // B 
....................                          0x3E, 0x41, 0x41, 0x22, 0x00, // C 
....................                          0x7F, 0x41, 0x41, 0x3e, 0x00, // D      37 
....................                          0x7F, 0x49, 0x49, 0x41, 0x00, // E 
....................                          0x7F, 0x09, 0x09, 0x01, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x08, 0x7f, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x3f, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x3e, 0x00, // O 
....................                          0x7F, 0x09, 0x09, 0x06, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x09, 0x76, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x32, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x40, 0x3f, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x08, 0x04, 0x78, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x04, 0x78, 0x00, // n 
....................                          0x38, 0x44, 0x44, 0x38, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x00, 0x3c, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x3c, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... */ 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x41, 0x49, 0x49, 0x36, 0x00, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x27, 0x45, 0x45, 0x39, 0x00, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x71, 0x09, 0x09, 0x07, 0x00,  // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x7e, 0x00, 0x00, // A      34 
....................                          0x7F, 0x49, 0x36, 0x00, 0x00, // B 
....................                          0x3E, 0x41, 0x22, 0x00, 0x00, // C 
....................                          0x7F, 0x41, 0x3e, 0x00, 0x00, // D      37 
....................                          0x7F, 0x49, 0x41, 0x00, 0x00, // E 
....................                          0x7F, 0x09, 0x01, 0x00, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x7f, 0x00, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x3f, 0x00, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x3e, 0x00, 0x00, // O 
....................                          0x7F, 0x09, 0x06, 0x00, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x76, 0x00, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x32, 0x00, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x3f, 0x00, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x00, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x04, 0x78, 0x00, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x78, 0x00, 0x00, // n 
....................                          0x38, 0x44, 0x38, 0x00, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x3c, 0x40, 0x7c, 0x00, 0x00, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x3c, 0x00, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... #define HMF6598_RS    pin_A0 
.................... #define HMF6598_RES   pin_A1 
.................... #define HMF6598_CS1   pin_A2 
.................... #define HMF6598_RD    pin_A3 
.................... #define HMF6598_WR    pin_A4 
....................  
.................... #define ON   1 
.................... #define OFF  0 
....................  
.................... int8 CurrentLine = 0; 
.................... int8 QuantChrLine = 0; 
.................... int8 OffsetX = 0; 
....................  
.................... void    HMF6598_InitLcd(void); 
.................... void    HMF6598_Write_command(char byte_command); 
.................... void    HMF6598_Write_data(char byte_data); 
.................... char    HMF6598_Read_data(); 
.................... void    HMF6598_Gotoxy(int8 x, int y); 
.................... void    HMF6598_Printchar(char cvar); 
.................... void    HMF6598_PutPixel(int8 x,int8 y, int1 COLOR); 
.................... void    HMF6598_OutPort(char byteDC); 
.................... void    clear_screen(void); 
.................... void    newLine(void); 
.................... void    HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR); 
.................... void    HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR); 
....................  
.................... void    HMF6598_InitLcd(void){ 
....................     
....................    output_low(HMF6598_CS1); // Chip Enabled 
*
0566:  BCF    F92.2
0568:  BCF    F89.2
....................    output_low(HMF6598_RES); 
056A:  BCF    F92.1
056C:  BCF    F89.1
....................    delay_us(200); 
056E:  MOVLW  C8
0570:  MOVWF  0E
0572:  RCALL  042A
....................    output_high(HMF6598_RES);  
0574:  BCF    F92.1
0576:  BSF    F89.1
....................    delay_us(200);    
0578:  MOVLW  C8
057A:  MOVWF  0E
057C:  RCALL  042A
....................  
....................    HMF6598_Write_command(0xc8);   // Duty = 65    
057E:  MOVLW  C8
0580:  MOVWF  19
0582:  RCALL  0466
....................    HMF6598_Write_command(0xa3);   // BIAS 1/9 
0584:  MOVLW  A3
0586:  MOVWF  19
0588:  RCALL  0466
....................    HMF6598_Write_command(0xa0);   // ADC Select 
058A:  MOVLW  A0
058C:  MOVWF  19
058E:  RCALL  0466
....................    HMF6598_Write_command(0xa6);   // Normal display 0xa6:  Reverse Display :0xa7 
0590:  MOVLW  A6
0592:  MOVWF  19
0594:  RCALL  0466
....................    HMF6598_Write_command(0x2c);   //---------------------------------------------  
0596:  MOVLW  2C
0598:  MOVWF  19
059A:  RCALL  0466
....................    delay_ms(3);                   // 
059C:  MOVLW  03
059E:  MOVWF  0E
05A0:  RCALL  0472
....................    HMF6598_Write_command(0x2e);   // Power Control Set VR, VC, VF  
05A2:  MOVLW  2E
05A4:  MOVWF  19
05A6:  RCALL  0466
....................    delay_ms(3);                   // 
05A8:  MOVLW  03
05AA:  MOVWF  0E
05AC:  RCALL  0472
....................    HMF6598_Write_command(0x2f);   //--------------------------------------------- 
05AE:  MOVLW  2F
05B0:  MOVWF  19
05B2:  RCALL  0466
....................    HMF6598_Write_command(0x20);   // 1+Rb/Ra Ratio    
05B4:  MOVLW  20
05B6:  MOVWF  19
05B8:  RCALL  0466
....................    HMF6598_Write_command(0x40);   // EVER register Set    
05BA:  MOVLW  40
05BC:  MOVWF  19
05BE:  RCALL  0466
....................     
....................    //Set Brightness   
....................    HMF6598_Write_command(0x81);  
05C0:  MOVLW  81
05C2:  MOVWF  19
05C4:  RCALL  0466
....................    HMF6598_Write_command(0x32); 
05C6:  MOVLW  32
05C8:  MOVWF  19
05CA:  RCALL  0466
....................     
....................    HMF6598_Write_command(0xe0);   // Set Modify Read  0xee to cancel / 0xe0 to activate 
05CC:  MOVLW  E0
05CE:  MOVWF  19
05D0:  RCALL  0466
....................  
....................    clear_screen(); 
05D2:  BRA    0536
....................    HMF6598_Write_command(0xaf);   // Display ON 
05D4:  MOVLW  AF
05D6:  MOVWF  19
05D8:  RCALL  0466
.................... } 
05DA:  GOTO   073A (RETURN)
....................  
.................... void HMF6598_OutPort(char byteDC){ 
....................   set_tris_b(0x00); 
*
044A:  MOVLW  00
044C:  MOVWF  F93
....................   output_low(HMF6598_CS1); 
044E:  BCF    F92.2
0450:  BCF    F89.2
....................   output_high(HMF6598_RD);  
0452:  BCF    F92.3
0454:  BSF    F89.3
....................   output_low(HMF6598_WR);   
0456:  BCF    F92.4
0458:  BCF    F89.4
....................   output_b(byteDC); 
045A:  CLRF   F93
045C:  MOVFF  1A,F8A
....................   output_high(HMF6598_CS1);     
0460:  BCF    F92.2
0462:  BSF    F89.2
.................... } 
0464:  RETLW  00
.................... void    HMF6598_Write_command(char byte_command){ 
....................   output_low(HMF6598_RS);          // Write Command Enabled 
0466:  BCF    F92.0
0468:  BCF    F89.0
....................   HMF6598_OutPort(byte_command); 
046A:  MOVFF  19,1A
046E:  RCALL  044A
.................... } 
0470:  RETLW  00
.................... void    HMF6598_Write_data(char byte_data){ 
....................   output_high(HMF6598_RS);         // Write data Enabled 
*
051E:  BCF    F92.0
0520:  BSF    F89.0
....................   HMF6598_OutPort(byte_data); 
0522:  MOVFF  14,1A
0526:  RCALL  044A
....................   OffsetX++; 
0528:  INCF   06,F
....................   HMF6598_Gotoxy(OffsetX,CurrentLine); 
052A:  MOVFF  06,15
052E:  MOVFF  04,16
0532:  RCALL  04C2
.................... } 
0534:  RETLW  00
....................  
.................... char    HMF6598_Read_data(){ 
....................  
.................... /*  set_tris_b(0xff); 
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................    
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1);    */  
....................    
....................   set_tris_b(0xff);     
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................   output_low(HMF6598_CS1); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1); 
.................... } 
....................  
.................... void newLine(){ 
....................   if(CurrentLine < 7){  // New Line Command 
....................       HMF6598_Write_command((CurrentLine+1)|0xb0);  // Set Page Address to 0 (0 a 7) 
....................       HMF6598_Write_command(0x00);  // Set LSB for index Column 
....................       HMF6598_Write_command(0x10);  // Set MSB for index Column    
....................       CurrentLine+=1; 
....................   } 
....................   QuantChrLine = 1; 
....................   OffsetX = 0; 
.................... } 
.................... void clear_screen(void) { 
....................    int p, c; 
....................    for(p = 0; p < 8; p++) { 
0536:  CLRF   0E
0538:  MOVF   0E,W
053A:  SUBLW  07
053C:  BNC   055C
....................       for(c = 0; c < 128; c++) { 
053E:  CLRF   0F
0540:  MOVF   0F,W
0542:  SUBLW  7F
0544:  BNC   0558
....................          HMF6598_Gotoxy(c,p); 
0546:  MOVFF  0F,15
054A:  MOVFF  0E,16
054E:  RCALL  04C2
....................          HMF6598_Write_data(0x00); 
0550:  CLRF   14
0552:  RCALL  051E
....................       } 
0554:  INCF   0F,F
0556:  BRA    0540
....................    } 
0558:  INCF   0E,F
055A:  BRA    0538
....................    HMF6598_Gotoxy(0,0);    
055C:  CLRF   15
055E:  CLRF   16
0560:  RCALL  04C2
.................... } 
0562:  GOTO   05D4 (RETURN)
.................... void    HMF6598_Gotoxy(int x, int y){ 
*
04C2:  CLRF   17
....................    int8 OffsetChr = 0; 
....................     
....................    HMF6598_Write_command(0xb0 | y); 
04C4:  MOVF   16,W
04C6:  IORLW  B0
04C8:  MOVWF  18
04CA:  MOVWF  19
04CC:  RCALL  0466
....................    HMF6598_Write_command((0x00 | x) & 0x0f); 
04CE:  MOVF   15,W
04D0:  ANDLW  0F
04D2:  MOVWF  18
04D4:  MOVWF  19
04D6:  RCALL  0466
....................    HMF6598_Write_command(0x10|(x>>4)); 
04D8:  SWAPF  15,W
04DA:  MOVWF  00
04DC:  MOVLW  0F
04DE:  ANDWF  00,F
04E0:  MOVF   00,W
04E2:  IORLW  10
04E4:  MOVWF  18
04E6:  MOVWF  19
04E8:  RCALL  0466
....................     
....................    OffsetChr = (x+1)/6; 
04EA:  MOVLW  01
04EC:  ADDWF  15,W
04EE:  MOVWF  19
04F0:  MOVWF  1A
04F2:  MOVLW  06
04F4:  MOVWF  1B
04F6:  RCALL  049A
04F8:  MOVFF  01,17
....................    if((x+1)%6) 
04FC:  MOVLW  01
04FE:  ADDWF  15,W
0500:  MOVWF  19
0502:  MOVWF  1A
0504:  MOVLW  06
0506:  MOVWF  1B
0508:  RCALL  049A
050A:  MOVF   00,W
050C:  BZ    0510
....................       OffsetChr++;    
050E:  INCF   17,F
....................    CurrentLine = y; 
0510:  MOVFF  16,04
....................    QuantChrLine = OffsetChr; 
0514:  MOVFF  17,05
....................    OffsetX = x; 
0518:  MOVFF  15,06
.................... } 
051C:  RETLW  00
.................... void    HMF6598_Printchar(char cvar){ 
....................    int i; 
....................    if (QuantChrLine > 21)   
....................        newLine();  
....................    else 
....................        QuantChrLine++;     
....................    if(cvar == 0x20) 
....................       for(i=0;i<2;i++) 
....................          HMF6598_Write_data(0x00); 
....................    else{ 
....................       for(i=0;i<5;i++){ 
....................          if (cvar < 0x53){ 
....................             if(TEXT[cvar-0x20][i])          
....................                HMF6598_Write_data(TEXT[cvar-0x20][i]);       
....................          } 
....................          else { 
....................             if(TEXT2[cvar-0x53][i])                
....................                HMF6598_Write_data(TEXT2[cvar-0x53][i]);                
....................          } 
....................       } 
....................    } 
....................    HMF6598_Write_data(0x00); 
.................... } 
.................... void HMF6598_PutPixel(int x, int y, int1 COLOR){ 
....................    char BytePlot = 0, tempByte; 
....................    if((x > 127)||(y > 63)) 
....................       return; 
....................    BytePlot |= 1; 
....................    BytePlot<<=(y%8); 
....................    tempByte = BytePlot; 
....................    HMF6598_Gotoxy(x,(y/8)); 
....................    BytePlot|=HMF6598_Read_data(); 
....................    if(COLOR == OFF) 
....................       BytePlot-=tempByte; 
....................    HMF6598_Write_data(BytePlot); 
.................... } 
....................  
.................... void HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR){ 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................    do{ 
....................       if(fill){ 
....................          HMF6598_line(x-a, y+b, x+a, y+b, color); 
....................          HMF6598_line(x-a, y-b, x+a, y-b, color); 
....................          HMF6598_line(x-b, y+a, x+b, y+a, color); 
....................          HMF6598_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else{ 
....................          HMF6598_PutPixel(a+x, b+y, color); 
....................          HMF6598_PutPixel(b+x, a+y, color); 
....................          HMF6598_PutPixel(x-a, b+y, color); 
....................          HMF6598_PutPixel(x-b, a+y, color); 
....................          HMF6598_PutPixel(b+x, y-a, color); 
....................          HMF6598_PutPixel(a+x, y-b, color); 
....................          HMF6598_PutPixel(x-a, y-b, color); 
....................          HMF6598_PutPixel(x-b, y-a, color); 
....................       } 
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... void HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR){ 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................  
....................    if(x1 > x2) 
....................       addx = -1; 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................       addy = -1; 
....................    else 
....................       addy = 1; 
....................    if(dx >= dy){ 
....................       P = 2*dy - dx; 
....................       for(i=0; i<=dx; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................          if(P < 0){ 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else{ 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else{ 
....................       P = 2*dx - dy; 
....................       for(i=0; i<=dy; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................  
....................          if(P < 0){ 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else{ 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... int x_ext, y_ext; 
.................... void putSprite(int x, int y){ 
....................    const BYTE bloco[8] = {0xFF,0xFF,0x81,0x81,0x81,0x81,0xFF,0xFF}; 
....................    int i; 
....................    char Sp1, Sp2; 
....................    if(x < 121) 
*
05FC:  MOVF   0F,W
05FE:  SUBLW  78
0600:  BNC   0606
....................       x_ext = x; 
0602:  MOVFF  0F,09
....................    if(y < 57) 
0606:  MOVF   10,W
0608:  SUBLW  38
060A:  BNC   0610
....................       y_ext = y; 
060C:  MOVFF  10,0A
....................    for(i=0;i<8;i++){ 
0610:  CLRF   11
0612:  MOVF   11,W
0614:  SUBLW  07
0616:  BTFSS  FD8.0
0618:  BRA    0714
....................       Sp1 = bloco[i] <<(y_ext%8); 
061A:  CLRF   03
061C:  MOVF   11,W
061E:  RCALL  0412
0620:  MOVWF  14
0622:  MOVF   0A,W
0624:  ANDLW  07
0626:  MOVWF  01
0628:  MOVFF  14,12
062C:  MOVF   01,F
062E:  BZ    0638
0630:  BCF    FD8.0
0632:  RLCF   12,F
0634:  DECFSZ 01,F
0636:  BRA    0630
....................       Sp2 = bloco[i] >>(8-(y_ext%8));       
0638:  CLRF   03
063A:  MOVF   11,W
063C:  RCALL  0412
063E:  MOVWF  14
0640:  MOVF   0A,W
0642:  ANDLW  07
0644:  XORLW  FF
0646:  ADDLW  09
0648:  MOVWF  01
064A:  MOVFF  14,13
064E:  MOVF   01,F
0650:  BZ    065A
0652:  BCF    FD8.0
0654:  RRCF   13,F
0656:  DECFSZ 01,F
0658:  BRA    0652
....................       HMF6598_Gotoxy(x_ext,(y_ext/8)); 
065A:  RRCF   0A,W
065C:  MOVWF  14
065E:  RRCF   14,F
0660:  RRCF   14,F
0662:  MOVLW  1F
0664:  ANDWF  14,F
0666:  MOVFF  09,15
066A:  MOVFF  14,16
066E:  RCALL  04C2
....................       Sp1 |= cenario[y_ext/8][x_ext];       
0670:  RRCF   0A,W
0672:  MOVWF  00
0674:  RRCF   00,F
0676:  RRCF   00,F
0678:  MOVLW  1F
067A:  ANDWF  00,F
067C:  MOVFF  00,15
0680:  CLRF   17
0682:  MOVFF  00,16
0686:  CLRF   19
0688:  MOVLW  80
068A:  MOVWF  18
068C:  RCALL  05DE
068E:  MOVFF  02,15
0692:  MOVFF  01,14
0696:  MOVF   09,W
0698:  ADDWF  01,W
069A:  MOVWF  01
069C:  MOVLW  00
069E:  ADDWFC 02,W
06A0:  MOVWF  03
06A2:  MOVF   01,W
06A4:  MOVFF  03,FF7
06A8:  RCALL  0004
06AA:  IORWF  12,F
....................       HMF6598_Write_data(Sp1); 
06AC:  MOVFF  12,14
06B0:  RCALL  051E
....................       HMF6598_Gotoxy(x_ext,(y_ext/8)+1);  
06B2:  RRCF   0A,W
06B4:  MOVWF  00
06B6:  RRCF   00,F
06B8:  RRCF   00,F
06BA:  MOVLW  1F
06BC:  ANDWF  00,F
06BE:  MOVF   00,W
06C0:  ADDLW  01
06C2:  MOVWF  14
06C4:  MOVFF  09,15
06C8:  MOVWF  16
06CA:  RCALL  04C2
....................       Sp2 |= cenario[(y_ext/8)+1][x_ext]; 
06CC:  RRCF   0A,W
06CE:  MOVWF  00
06D0:  RRCF   00,F
06D2:  RRCF   00,F
06D4:  MOVLW  1F
06D6:  ANDWF  00,F
06D8:  MOVF   00,W
06DA:  ADDLW  01
06DC:  MOVWF  15
06DE:  CLRF   17
06E0:  MOVWF  16
06E2:  CLRF   19
06E4:  MOVLW  80
06E6:  MOVWF  18
06E8:  RCALL  05DE
06EA:  MOVFF  02,15
06EE:  MOVFF  01,14
06F2:  MOVF   09,W
06F4:  ADDWF  01,W
06F6:  MOVWF  01
06F8:  MOVLW  00
06FA:  ADDWFC 02,W
06FC:  MOVWF  03
06FE:  MOVF   01,W
0700:  MOVFF  03,FF7
0704:  RCALL  0004
0706:  IORWF  13,F
....................       HMF6598_Write_data(Sp2); 
0708:  MOVFF  13,14
070C:  RCALL  051E
....................       x_ext++; 
070E:  INCF   09,F
....................    } 
0710:  INCF   11,F
0712:  BRA    0612
....................    x_ext -= 8; 
0714:  MOVLW  08
0716:  SUBWF  09,F
.................... } 
0718:  RETLW  00
....................  
.................... void main(void){ 
071A:  CLRF   FF8
071C:  BCF    FD0.7
071E:  CLRF   FEA
0720:  CLRF   FE9
0722:  CLRF   04
0724:  CLRF   05
0726:  CLRF   06
0728:  MOVF   FC1,W
072A:  ANDLW  C0
072C:  IORLW  0F
072E:  MOVWF  FC1
0730:  MOVLW  07
0732:  MOVWF  FB4
0734:  CLRF   07
0736:  CLRF   08
....................    int i, j, t; 
....................    HMF6598_InitLcd(); 
0738:  BRA    0566
....................    // ------ SPRITE DE FUNDO rolando ------- 
....................    t = 0; 
073A:  CLRF   0D
....................    while(true){ 
....................       for(i=0;i<8;i++){ 
073C:  CLRF   0B
073E:  MOVF   0B,W
0740:  SUBLW  07
0742:  BNC   07CA
....................          HMF6598_Gotoxy(0,i); 
0744:  CLRF   15
0746:  MOVFF  0B,16
074A:  RCALL  04C2
....................          for(j=t;j<128;j++) 
074C:  MOVFF  0D,0C
0750:  MOVF   0C,W
0752:  SUBLW  7F
0754:  BNC   078A
....................             HMF6598_Write_data(cenario[i][j]);            
0756:  CLRF   17
0758:  MOVFF  0B,16
075C:  CLRF   19
075E:  MOVLW  80
0760:  MOVWF  18
0762:  RCALL  05DE
0764:  MOVFF  02,0F
0768:  MOVFF  01,0E
076C:  MOVF   0C,W
076E:  ADDWF  01,W
0770:  MOVWF  01
0772:  MOVLW  00
0774:  ADDWFC 02,W
0776:  MOVWF  03
0778:  MOVF   01,W
077A:  MOVFF  03,FF7
077E:  RCALL  0004
0780:  MOVWF  0E
0782:  MOVWF  14
0784:  RCALL  051E
0786:  INCF   0C,F
0788:  BRA    0750
....................          for(j=0;j<t;j++)    
078A:  CLRF   0C
078C:  MOVF   0D,W
078E:  SUBWF  0C,W
0790:  BC    07C6
....................             HMF6598_Write_data(cenario[i][j]); 
0792:  CLRF   17
0794:  MOVFF  0B,16
0798:  CLRF   19
079A:  MOVLW  80
079C:  MOVWF  18
079E:  RCALL  05DE
07A0:  MOVFF  02,0F
07A4:  MOVFF  01,0E
07A8:  MOVF   0C,W
07AA:  ADDWF  01,W
07AC:  MOVWF  01
07AE:  MOVLW  00
07B0:  ADDWFC 02,W
07B2:  MOVWF  03
07B4:  MOVF   01,W
07B6:  MOVFF  03,FF7
07BA:  RCALL  0004
07BC:  MOVWF  0E
07BE:  MOVWF  14
07C0:  RCALL  051E
07C2:  INCF   0C,F
07C4:  BRA    078C
....................       } 
07C6:  INCF   0B,F
07C8:  BRA    073E
....................       //delay_ms(40); 
....................       t++; 
07CA:  INCF   0D,F
....................       if(t>127) 
07CC:  MOVF   0D,W
07CE:  SUBLW  7F
07D0:  BC    07D4
....................          t = 0; 
07D2:  CLRF   0D
....................    } 
07D4:  BRA    073C
....................    // -------------------------------------- 
....................    // ------ SPRITE DE FUNDO ------- 
....................    /*for(i=0;i<8;i++){ 
....................       HMF6598_Gotoxy(0,i); 
....................       for(j=0;j<128;j++){ 
....................          HMF6598_Write_data(cenario[i][j]);            
....................          } 
....................    }*/   
....................    // ----------------------------- 
....................    putSprite(3,3); 
07D6:  MOVLW  03
07D8:  MOVWF  0F
07DA:  MOVWF  10
07DC:  RCALL  05FC
....................    while(true){ 
....................       delay_ms(50); 
07DE:  MOVLW  32
07E0:  MOVWF  0E
07E2:  RCALL  0472
....................       if(!input(pin_D7)){    
07E4:  BSF    F95.7
07E6:  BTFSC  F83.7
07E8:  BRA    08BC
....................          putSprite(x_ext+1, y_ext); 
07EA:  MOVLW  01
07EC:  ADDWF  09,W
07EE:  MOVWF  0E
07F0:  MOVWF  0F
07F2:  MOVFF  0A,10
07F6:  RCALL  05FC
....................           
....................          HMF6598_Gotoxy(x_ext-1,(y_ext/8)); 
07F8:  MOVLW  01
07FA:  SUBWF  09,W
07FC:  MOVWF  0E
07FE:  RRCF   0A,W
0800:  MOVWF  0F
0802:  RRCF   0F,F
0804:  RRCF   0F,F
0806:  MOVLW  1F
0808:  ANDWF  0F,F
080A:  MOVFF  0E,15
080E:  MOVFF  0F,16
0812:  RCALL  04C2
....................          HMF6598_Write_data(cenario[y_ext/8][x_ext-1]); 
0814:  RRCF   0A,W
0816:  MOVWF  00
0818:  RRCF   00,F
081A:  RRCF   00,F
081C:  MOVLW  1F
081E:  ANDWF  00,F
0820:  MOVFF  00,0F
0824:  CLRF   17
0826:  MOVFF  00,16
082A:  CLRF   19
082C:  MOVLW  80
082E:  MOVWF  18
0830:  RCALL  05DE
0832:  MOVFF  02,0F
0836:  MOVFF  01,0E
083A:  MOVLW  01
083C:  SUBWF  09,W
083E:  ADDWF  01,W
0840:  MOVWF  01
0842:  MOVLW  00
0844:  ADDWFC 02,W
0846:  MOVWF  03
0848:  MOVF   01,W
084A:  MOVFF  03,FF7
084E:  CALL   0004
0852:  MOVWF  0E
0854:  MOVWF  14
0856:  RCALL  051E
....................          HMF6598_Gotoxy(x_ext-1,(y_ext/8)+1); 
0858:  MOVLW  01
085A:  SUBWF  09,W
085C:  MOVWF  0E
085E:  RRCF   0A,W
0860:  MOVWF  00
0862:  RRCF   00,F
0864:  RRCF   00,F
0866:  MOVLW  1F
0868:  ANDWF  00,F
086A:  MOVF   00,W
086C:  ADDLW  01
086E:  MOVWF  0F
0870:  MOVFF  0E,15
0874:  MOVWF  16
0876:  RCALL  04C2
....................          HMF6598_Write_data(cenario[(y_ext/8)+1][x_ext-1]);          
0878:  RRCF   0A,W
087A:  MOVWF  00
087C:  RRCF   00,F
087E:  RRCF   00,F
0880:  MOVLW  1F
0882:  ANDWF  00,F
0884:  MOVF   00,W
0886:  ADDLW  01
0888:  MOVWF  0F
088A:  CLRF   17
088C:  MOVWF  16
088E:  CLRF   19
0890:  MOVLW  80
0892:  MOVWF  18
0894:  RCALL  05DE
0896:  MOVFF  02,0F
089A:  MOVFF  01,0E
089E:  MOVLW  01
08A0:  SUBWF  09,W
08A2:  ADDWF  01,W
08A4:  MOVWF  01
08A6:  MOVLW  00
08A8:  ADDWFC 02,W
08AA:  MOVWF  03
08AC:  MOVF   01,W
08AE:  MOVFF  03,FF7
08B2:  CALL   0004
08B6:  MOVWF  0E
08B8:  MOVWF  14
08BA:  RCALL  051E
....................       } 
....................       if(!input(pin_D6)){    
08BC:  BSF    F95.6
08BE:  BTFSC  F83.6
08C0:  BRA    0940
....................          for(i=0;i<8;i++){ 
08C2:  CLRF   0B
08C4:  MOVF   0B,W
08C6:  SUBLW  07
08C8:  BNC   0932
....................             HMF6598_Gotoxy(x_ext+i,(y_ext/8)+1);             
08CA:  MOVF   0B,W
08CC:  ADDWF  09,W
08CE:  MOVWF  0E
08D0:  RRCF   0A,W
08D2:  MOVWF  00
08D4:  RRCF   00,F
08D6:  RRCF   00,F
08D8:  MOVLW  1F
08DA:  ANDWF  00,F
08DC:  MOVF   00,W
08DE:  ADDLW  01
08E0:  MOVWF  0F
08E2:  MOVFF  0E,15
08E6:  MOVWF  16
08E8:  RCALL  04C2
....................             HMF6598_Write_data(cenario[(y_ext/8)+1][x_ext+i]);          
08EA:  RRCF   0A,W
08EC:  MOVWF  00
08EE:  RRCF   00,F
08F0:  RRCF   00,F
08F2:  MOVLW  1F
08F4:  ANDWF  00,F
08F6:  MOVF   00,W
08F8:  ADDLW  01
08FA:  MOVWF  0F
08FC:  CLRF   17
08FE:  MOVWF  16
0900:  CLRF   19
0902:  MOVLW  80
0904:  MOVWF  18
0906:  RCALL  05DE
0908:  MOVFF  02,0F
090C:  MOVFF  01,0E
0910:  MOVF   0B,W
0912:  ADDWF  09,W
0914:  ADDWF  01,W
0916:  MOVWF  01
0918:  MOVLW  00
091A:  ADDWFC 02,W
091C:  MOVWF  03
091E:  MOVF   01,W
0920:  MOVFF  03,FF7
0924:  CALL   0004
0928:  MOVWF  0E
092A:  MOVWF  14
092C:  RCALL  051E
....................          } 
092E:  INCF   0B,F
0930:  BRA    08C4
....................          putSprite(x_ext, y_ext-1); 
0932:  MOVLW  01
0934:  SUBWF  0A,W
0936:  MOVWF  0E
0938:  MOVFF  09,0F
093C:  MOVWF  10
093E:  RCALL  05FC
....................       } 
....................       if(!input(pin_D5)){   
0940:  BSF    F95.5
0942:  BTFSC  F83.5
0944:  BRA    09C0
....................          for(i=0;i<8;i++){ 
0946:  CLRF   0B
0948:  MOVF   0B,W
094A:  SUBLW  07
094C:  BNC   09B2
....................             HMF6598_Gotoxy(x_ext+i,(y_ext/8));             
094E:  MOVF   0B,W
0950:  ADDWF  09,W
0952:  MOVWF  0E
0954:  RRCF   0A,W
0956:  MOVWF  0F
0958:  RRCF   0F,F
095A:  RRCF   0F,F
095C:  MOVLW  1F
095E:  ANDWF  0F,F
0960:  MOVFF  0E,15
0964:  MOVFF  0F,16
0968:  RCALL  04C2
....................             HMF6598_Write_data(cenario[y_ext/8][x_ext+i]);          
096A:  RRCF   0A,W
096C:  MOVWF  00
096E:  RRCF   00,F
0970:  RRCF   00,F
0972:  MOVLW  1F
0974:  ANDWF  00,F
0976:  MOVFF  00,0F
097A:  CLRF   17
097C:  MOVFF  00,16
0980:  CLRF   19
0982:  MOVLW  80
0984:  MOVWF  18
0986:  RCALL  05DE
0988:  MOVFF  02,0F
098C:  MOVFF  01,0E
0990:  MOVF   0B,W
0992:  ADDWF  09,W
0994:  ADDWF  01,W
0996:  MOVWF  01
0998:  MOVLW  00
099A:  ADDWFC 02,W
099C:  MOVWF  03
099E:  MOVF   01,W
09A0:  MOVFF  03,FF7
09A4:  CALL   0004
09A8:  MOVWF  0E
09AA:  MOVWF  14
09AC:  RCALL  051E
....................          }       
09AE:  INCF   0B,F
09B0:  BRA    0948
....................          putSprite(x_ext, y_ext+1); 
09B2:  MOVLW  01
09B4:  ADDWF  0A,W
09B6:  MOVWF  0E
09B8:  MOVFF  09,0F
09BC:  MOVWF  10
09BE:  RCALL  05FC
....................       } 
....................       if(!input(pin_D4)){    
09C0:  BSF    F95.4
09C2:  BTFSC  F83.4
09C4:  BRA    0A98
....................          putSprite(x_ext-1, y_ext); 
09C6:  MOVLW  01
09C8:  SUBWF  09,W
09CA:  MOVWF  0E
09CC:  MOVWF  0F
09CE:  MOVFF  0A,10
09D2:  RCALL  05FC
....................           
....................          HMF6598_Gotoxy(x_ext+8,(y_ext/8)); 
09D4:  MOVLW  08
09D6:  ADDWF  09,W
09D8:  MOVWF  0E
09DA:  RRCF   0A,W
09DC:  MOVWF  0F
09DE:  RRCF   0F,F
09E0:  RRCF   0F,F
09E2:  MOVLW  1F
09E4:  ANDWF  0F,F
09E6:  MOVFF  0E,15
09EA:  MOVFF  0F,16
09EE:  RCALL  04C2
....................          HMF6598_Write_data(cenario[y_ext/8][x_ext+8]); 
09F0:  RRCF   0A,W
09F2:  MOVWF  00
09F4:  RRCF   00,F
09F6:  RRCF   00,F
09F8:  MOVLW  1F
09FA:  ANDWF  00,F
09FC:  MOVFF  00,0F
0A00:  CLRF   17
0A02:  MOVFF  00,16
0A06:  CLRF   19
0A08:  MOVLW  80
0A0A:  MOVWF  18
0A0C:  RCALL  05DE
0A0E:  MOVFF  02,0F
0A12:  MOVFF  01,0E
0A16:  MOVLW  08
0A18:  ADDWF  09,W
0A1A:  ADDWF  01,W
0A1C:  MOVWF  01
0A1E:  MOVLW  00
0A20:  ADDWFC 02,W
0A22:  MOVWF  03
0A24:  MOVF   01,W
0A26:  MOVFF  03,FF7
0A2A:  CALL   0004
0A2E:  MOVWF  0E
0A30:  MOVWF  14
0A32:  RCALL  051E
....................          HMF6598_Gotoxy(x_ext+8,(y_ext/8)+1); 
0A34:  MOVLW  08
0A36:  ADDWF  09,W
0A38:  MOVWF  0E
0A3A:  RRCF   0A,W
0A3C:  MOVWF  00
0A3E:  RRCF   00,F
0A40:  RRCF   00,F
0A42:  MOVLW  1F
0A44:  ANDWF  00,F
0A46:  MOVF   00,W
0A48:  ADDLW  01
0A4A:  MOVWF  0F
0A4C:  MOVFF  0E,15
0A50:  MOVWF  16
0A52:  RCALL  04C2
....................          HMF6598_Write_data(cenario[(y_ext/8)+1][x_ext+8]);            
0A54:  RRCF   0A,W
0A56:  MOVWF  00
0A58:  RRCF   00,F
0A5A:  RRCF   00,F
0A5C:  MOVLW  1F
0A5E:  ANDWF  00,F
0A60:  MOVF   00,W
0A62:  ADDLW  01
0A64:  MOVWF  0F
0A66:  CLRF   17
0A68:  MOVWF  16
0A6A:  CLRF   19
0A6C:  MOVLW  80
0A6E:  MOVWF  18
0A70:  RCALL  05DE
0A72:  MOVFF  02,0F
0A76:  MOVFF  01,0E
0A7A:  MOVLW  08
0A7C:  ADDWF  09,W
0A7E:  ADDWF  01,W
0A80:  MOVWF  01
0A82:  MOVLW  00
0A84:  ADDWFC 02,W
0A86:  MOVWF  03
0A88:  MOVF   01,W
0A8A:  MOVFF  03,FF7
0A8E:  CALL   0004
0A92:  MOVWF  0E
0A94:  MOVWF  14
0A96:  RCALL  051E
....................       }       
....................    } 
0A98:  BRA    07DE
....................    //int i, j; 
....................    /* HMF6598_Gotoxy(0,0);    
....................    printf(HMF6598_Printchar, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");    
....................    */ 
....................    /*for(i=0;i<8;i++){ 
....................       HMF6598_Gotoxy(0,i); 
....................       for(j=0;j<128;j++){ 
....................          HMF6598_Write_data(cenario[i][j]);            
....................          } 
....................    }*/ 
....................     
.................... } 
0A9A:  SLEEP 

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV20 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICPRT NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
