CCS PCH C Compiler, Version 4.114, 93460303               30-mar-13 21:33

               Filename: D:\SkyDrive\Eletronica\PROJETOS PIC CCS\GAME_TEST\MOVE_SPRITE\index.lst

               ROM used: 986 bytes (3%)
                         Largest free fragment is 31782
               RAM used: 14 (1%) at main() level
                         27 (1%) worst case
               Stack:    6 locations

*
0000:  GOTO   0274
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #use delay(clock=48000000) 
*
001C:  MOVLW  01
001E:  SUBWF  0C,F
0020:  BNC   003A
0022:  CLRF   FEA
0024:  MOVLW  0C
0026:  MOVWF  FE9
0028:  MOVF   FEF,W
002A:  BZ    003A
002C:  MOVLW  02
002E:  MOVWF  00
0030:  DECFSZ 00,F
0032:  BRA    0030
0034:  BRA    0036
0036:  DECFSZ FEF,F
0038:  BRA    002C
003A:  RETLW  00
*
0064:  CLRF   FEA
0066:  MOVLW  0C
0068:  MOVWF  FE9
006A:  MOVF   FEF,W
006C:  BZ    008A
006E:  MOVLW  0F
0070:  MOVWF  01
0072:  CLRF   00
0074:  DECFSZ 00,F
0076:  BRA    0074
0078:  DECFSZ 01,F
007A:  BRA    0072
007C:  MOVLW  8F
007E:  MOVWF  00
0080:  DECFSZ 00,F
0082:  BRA    0080
0084:  NOP   
0086:  DECFSZ FEF,F
0088:  BRA    006E
008A:  RETLW  00
.................... #fuses HSPLL, PLL4, CPUDIV1, PUT, NOWDT, NOBROWNOUT, NOLVP 
.................... #include "HMF6598SYH-PY.c" 
.................... const BYTE cenario[8][128] =  
.................... { 
.................... 0x00,0x00,0x80,0xC0,0x40,0x70,0x0C,0x04, 
.................... 0x04,0x04,0x04,0x0C,0x18,0x38,0x0C,0x04, 
.................... 0x04,0x04,0x04,0x0C,0x18,0x18,0x0C,0x04, 
.................... 0x04,0x04,0x0C,0x08,0x08,0x18,0xF0,0xE0, 
.................... 0x00,0x00,0x00,0x00,0x00,0x78,0xCC,0x8C, 
.................... 0x84,0x84,0x04,0x0C,0x18,0x0C,0x84,0x84, 
.................... 0xC4,0x44,0x74,0x18,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x10,0x28,0x24,0x24,0x18,0x00, 
.................... 0x00,0x00,0x00,0x00,0x20,0xFC,0x84,0x04, 
.................... 0x06,0x0E,0x12,0x02,0x02,0x02,0x04,0x08, 
.................... 0x08,0x08,0x88,0xCC,0x64,0x44,0xC4,0x84, 
.................... 0x84,0x84,0x8C,0x82,0x82,0x82,0x82,0x42, 
.................... 0x42,0x66,0x3C,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x38,0xEC,0x84,0x02,0x02,0x01,0x01, 
.................... 0x01,0x02,0x04,0x04,0x04,0x08,0x98,0x10, 
.................... 0x08,0x08,0x84,0x84,0xC4,0x44,0x6C,0x30, 
.................... 0x00,0x00,0x07,0x0E,0x18,0x18,0x18,0x1C, 
.................... 0x1C,0x0F,0x08,0x18,0x10,0x10,0x10,0x10, 
.................... 0x10,0x18,0x0F,0x03,0x0C,0x08,0x08,0x0C, 
.................... 0x0C,0x0C,0x0C,0x0C,0x06,0x07,0x07,0x03, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01, 
.................... 0x03,0x02,0x06,0x04,0x04,0x04,0x04,0x06, 
.................... 0x02,0x03,0x01,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x01,0x03,0x02,0x02,0x06, 
.................... 0x04,0x04,0x04,0x02,0x03,0x01,0x01,0x03, 
.................... 0x06,0x04,0x08,0x08,0x05,0x03,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x10,0x10,0x10,0xF0,0x90,0x10, 
.................... 0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00, 
.................... 0xFF,0xFF,0x01,0x01,0x19,0x01,0x01,0x01, 
.................... 0x01,0x01,0x01,0x39,0x01,0x01,0x01,0xFF, 
.................... 0x00,0x00,0x10,0x10,0xF8,0x10,0x10,0x10, 
.................... 0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0x01,0x01,0x19,0x19,0x01,0x01,0x01, 
.................... 0x01,0x19,0x01,0xFF,0x00,0x00,0x00,0x00, 
.................... 0xE0,0x20,0x3F,0x21,0x21,0x21,0x21,0x3F, 
.................... 0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0xE0,0xE2,0x22,0x3E,0xA3,0xE2, 
.................... 0x22,0x20,0x24,0xFC,0x24,0x64,0x60,0xE0, 
.................... 0xE0,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xB8, 
.................... 0xAC,0xA6,0xEB,0xB5,0x9C,0x87,0x80,0x80, 
.................... 0xFF,0xFF,0x00,0x00,0x18,0x00,0x00,0x00, 
.................... 0x00,0x00,0x04,0x3C,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x01,0x19,0x19,0x01,0x01,0x01,0x01, 
.................... 0x01,0x01,0x19,0x19,0x01,0x01,0x01,0xFF, 
.................... 0x00,0x00,0x20,0x30,0x70,0xF0,0x18,0x08, 
.................... 0x00,0x01,0x03,0x0E,0x7E,0xCC,0x00,0x00, 
.................... 0xFF,0x00,0x00,0xC3,0xC3,0x00,0x00,0x00, 
.................... 0x00,0xC3,0x00,0xFF,0xFC,0x04,0x04,0x04, 
.................... 0x87,0x84,0x04,0x1C,0x04,0x04,0x84,0x84, 
.................... 0x07,0x04,0x04,0x1C,0x04,0x84,0x04,0x04, 
.................... 0x04,0x04,0xFF,0xFF,0x00,0xF0,0x1F,0x00, 
.................... 0x00,0xFC,0x03,0x01,0x00,0x00,0x00,0x00, 
.................... 0x01,0x0F,0xFF,0x00,0x00,0x80,0x80,0xC0, 
.................... 0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00,0x08, 
.................... 0x08,0x08,0x00,0x00,0x1C,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00, 
.................... 0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x86,0x86,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x83,0x83,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x01,0x01,0x11,0x11,0x01,0x01,0x01, 
.................... 0x01,0x01,0x11,0x11,0x01,0x01,0x01,0xFF, 
.................... 0xFF,0x00,0x00,0x30,0x30,0x00,0x00,0x00, 
.................... 0x00,0x30,0x00,0xFF,0xFF,0x00,0x00,0x00, 
.................... 0x31,0x31,0x00,0x00,0x00,0x00,0x31,0x31, 
.................... 0x00,0x00,0x00,0x00,0x00,0x71,0x00,0x00, 
.................... 0x00,0x00,0xFF,0xFF,0x00,0x00,0x0F,0x30, 
.................... 0xE0,0x00,0x03,0x0C,0x30,0x60,0x80,0x00, 
.................... 0x00,0x00,0xFF,0xF0,0x13,0x11,0x91,0x97, 
.................... 0x1C,0x10,0x10,0x13,0x9C,0x14,0x10,0xF0, 
.................... 0xFF,0x00,0x00,0x0F,0x0F,0x00,0x00,0x00, 
.................... 0x04,0x04,0x00,0x00,0x0F,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0xC7,0xC7,0x00,0x00, 
.................... 0x00,0x00,0x00,0x43,0xC0,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x61,0x61,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x61,0x61,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x04,0x04,0x00,0x00,0x00, 
.................... 0x00,0x00,0x04,0x04,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00,0x00, 
.................... 0x00,0x0C,0x00,0xFF,0xFF,0x00,0x00,0x00, 
.................... 0x1C,0x1C,0x00,0x00,0x00,0x00,0x1C,0x1C, 
.................... 0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x00, 
.................... 0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00, 
.................... 0xE1,0x1F,0x00,0x00,0x00,0x00,0x01,0x0F, 
.................... 0xF8,0x00,0xFF,0xFF,0x00,0x00,0xE3,0xE3, 
.................... 0x00,0x00,0x00,0x00,0xE3,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x8F,0x8F,0x00,0x00,0x04, 
.................... 0x04,0x04,0x00,0x00,0x1F,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0x30,0x30,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x73,0x00,0x00,0xFF, 
.................... 0xFF,0x80,0x8C,0x8C,0x80,0x80,0xC0,0xC0, 
.................... 0xC0,0x80,0x8C,0x8C,0x80,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x82,0x82,0x80,0xC0,0xC0, 
.................... 0xC0,0xC0,0x82,0x82,0x80,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x83,0x83,0x80,0x80,0x80, 
.................... 0x80,0x83,0x80,0xFF,0xFF,0x80,0x80,0x80, 
.................... 0x8E,0xCE,0xC0,0xC0,0xC0,0xC0,0xCE,0xCE, 
.................... 0xC0,0xC0,0xC0,0xC0,0xC0,0x8E,0x80,0x80, 
.................... 0x80,0x80,0xFF,0xFF,0x80,0x80,0x80,0xC0, 
.................... 0xBF,0x80,0x80,0x80,0x80,0xA0,0xB0,0x9C, 
.................... 0x87,0x80,0xFF,0xFF,0x80,0x80,0x98,0x98, 
.................... 0x80,0x80,0x80,0x80,0x98,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x87,0x87,0x80,0x80,0x82, 
.................... 0x82,0x82,0x80,0x80,0x87,0x80,0x80,0x80, 
.................... 0xFF,0xFF,0x80,0x80,0x86,0x86,0x80,0x80, 
.................... 0x80,0x80,0x80,0x80,0x86,0x80,0x80,0xFF}; 
.................... /* 
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01\ 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x00, 0x41, 0x49, 0x49, 0x36, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x00, 0x27, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x00, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x7e, 0x00, // A      34 
....................                          0x7F, 0x49, 0x49, 0x36, 0x00, // B 
....................                          0x3E, 0x41, 0x41, 0x22, 0x00, // C 
....................                          0x7F, 0x41, 0x41, 0x3e, 0x00, // D      37 
....................                          0x7F, 0x49, 0x49, 0x41, 0x00, // E 
....................                          0x7F, 0x09, 0x09, 0x01, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x08, 0x7f, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x3f, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x3e, 0x00, // O 
....................                          0x7F, 0x09, 0x09, 0x06, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x09, 0x76, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x32, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x40, 0x3f, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x08, 0x04, 0x78, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x04, 0x78, 0x00, // n 
....................                          0x38, 0x44, 0x44, 0x38, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x00, 0x3c, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x3c, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... */ 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x41, 0x49, 0x49, 0x36, 0x00, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x27, 0x45, 0x45, 0x39, 0x00, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x71, 0x09, 0x09, 0x07, 0x00,  // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x7e, 0x00, 0x00, // A      34 
....................                          0x7F, 0x49, 0x36, 0x00, 0x00, // B 
....................                          0x3E, 0x41, 0x22, 0x00, 0x00, // C 
....................                          0x7F, 0x41, 0x3e, 0x00, 0x00, // D      37 
....................                          0x7F, 0x49, 0x41, 0x00, 0x00, // E 
....................                          0x7F, 0x09, 0x01, 0x00, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x7f, 0x00, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x3f, 0x00, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x3e, 0x00, 0x00, // O 
....................                          0x7F, 0x09, 0x06, 0x00, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x76, 0x00, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x32, 0x00, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x3f, 0x00, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x00, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x04, 0x78, 0x00, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x78, 0x00, 0x00, // n 
....................                          0x38, 0x44, 0x38, 0x00, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x3c, 0x40, 0x7c, 0x00, 0x00, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x3c, 0x00, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... #define HMF6598_RS    pin_A0 
.................... #define HMF6598_RES   pin_A1 
.................... #define HMF6598_CS1   pin_A2 
.................... #define HMF6598_RD    pin_A3 
.................... #define HMF6598_WR    pin_A4 
....................  
.................... #define ON   1 
.................... #define OFF  0 
....................  
.................... int8 CurrentLine = 0; 
.................... int8 QuantChrLine = 0; 
.................... int8 OffsetX = 0; 
....................  
.................... void    HMF6598_InitLcd(void); 
.................... void    HMF6598_Write_command(char byte_command); 
.................... void    HMF6598_Write_data(char byte_data); 
.................... char    HMF6598_Read_data(); 
.................... void    HMF6598_Gotoxy(int8 x, int y); 
.................... void    HMF6598_Printchar(char cvar); 
.................... void    HMF6598_PutPixel(int8 x,int8 y, int1 COLOR); 
.................... void    HMF6598_OutPort(char byteDC); 
.................... void    clear_screen(void); 
.................... void    newLine(void); 
.................... void    HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR); 
.................... void    HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR); 
....................  
.................... void    HMF6598_InitLcd(void){ 
....................     
....................    output_low(HMF6598_CS1); // Chip Enabled 
*
0158:  BCF    F92.2
015A:  BCF    F89.2
....................    output_low(HMF6598_RES); 
015C:  BCF    F92.1
015E:  BCF    F89.1
....................    delay_us(200); 
0160:  MOVLW  C8
0162:  MOVWF  0C
0164:  RCALL  001C
....................    output_high(HMF6598_RES);  
0166:  BCF    F92.1
0168:  BSF    F89.1
....................    delay_us(200);    
016A:  MOVLW  C8
016C:  MOVWF  0C
016E:  RCALL  001C
....................  
....................    HMF6598_Write_command(0xc8);   // Duty = 65    
0170:  MOVLW  C8
0172:  MOVWF  17
0174:  RCALL  0058
....................    HMF6598_Write_command(0xa3);   // BIAS 1/9 
0176:  MOVLW  A3
0178:  MOVWF  17
017A:  RCALL  0058
....................    HMF6598_Write_command(0xa0);   // ADC Select 
017C:  MOVLW  A0
017E:  MOVWF  17
0180:  RCALL  0058
....................    HMF6598_Write_command(0xa6);   // Normal display 0xa6:  Reverse Display :0xa7 
0182:  MOVLW  A6
0184:  MOVWF  17
0186:  RCALL  0058
....................    HMF6598_Write_command(0x2c);   //---------------------------------------------  
0188:  MOVLW  2C
018A:  MOVWF  17
018C:  RCALL  0058
....................    delay_ms(3);                   // 
018E:  MOVLW  03
0190:  MOVWF  0C
0192:  RCALL  0064
....................    HMF6598_Write_command(0x2e);   // Power Control Set VR, VC, VF  
0194:  MOVLW  2E
0196:  MOVWF  17
0198:  RCALL  0058
....................    delay_ms(3);                   // 
019A:  MOVLW  03
019C:  MOVWF  0C
019E:  RCALL  0064
....................    HMF6598_Write_command(0x2f);   //--------------------------------------------- 
01A0:  MOVLW  2F
01A2:  MOVWF  17
01A4:  RCALL  0058
....................    HMF6598_Write_command(0x20);   // 1+Rb/Ra Ratio    
01A6:  MOVLW  20
01A8:  MOVWF  17
01AA:  RCALL  0058
....................    HMF6598_Write_command(0x40);   // EVER register Set    
01AC:  MOVLW  40
01AE:  MOVWF  17
01B0:  RCALL  0058
....................     
....................    //Set Brightness   
....................    HMF6598_Write_command(0x81);  
01B2:  MOVLW  81
01B4:  MOVWF  17
01B6:  RCALL  0058
....................    HMF6598_Write_command(0x32); 
01B8:  MOVLW  32
01BA:  MOVWF  17
01BC:  RCALL  0058
....................     
....................    HMF6598_Write_command(0xe0);   // Set Modify Read  0xee to cancel / 0xe0 to activate 
01BE:  MOVLW  E0
01C0:  MOVWF  17
01C2:  RCALL  0058
....................  
....................    clear_screen(); 
01C4:  BRA    0128
....................    HMF6598_Write_command(0xaf);   // Display ON 
01C6:  MOVLW  AF
01C8:  MOVWF  17
01CA:  RCALL  0058
.................... } 
01CC:  GOTO   0294 (RETURN)
....................  
.................... void HMF6598_OutPort(char byteDC){ 
....................   set_tris_b(0x00); 
*
003C:  MOVLW  00
003E:  MOVWF  F93
....................   output_low(HMF6598_CS1); 
0040:  BCF    F92.2
0042:  BCF    F89.2
....................   output_high(HMF6598_RD);  
0044:  BCF    F92.3
0046:  BSF    F89.3
....................   output_low(HMF6598_WR);   
0048:  BCF    F92.4
004A:  BCF    F89.4
....................   output_b(byteDC); 
004C:  CLRF   F93
004E:  MOVFF  18,F8A
....................   output_high(HMF6598_CS1);     
0052:  BCF    F92.2
0054:  BSF    F89.2
.................... } 
0056:  RETLW  00
.................... void    HMF6598_Write_command(char byte_command){ 
....................   output_low(HMF6598_RS);          // Write Command Enabled 
0058:  BCF    F92.0
005A:  BCF    F89.0
....................   HMF6598_OutPort(byte_command); 
005C:  MOVFF  17,18
0060:  RCALL  003C
.................... } 
0062:  RETLW  00
.................... void    HMF6598_Write_data(char byte_data){ 
....................   output_high(HMF6598_RS);         // Write data Enabled 
*
0110:  BCF    F92.0
0112:  BSF    F89.0
....................   HMF6598_OutPort(byte_data); 
0114:  MOVFF  12,18
0118:  RCALL  003C
....................   OffsetX++; 
011A:  INCF   06,F
....................   HMF6598_Gotoxy(OffsetX,CurrentLine); 
011C:  MOVFF  06,13
0120:  MOVFF  04,14
0124:  RCALL  00B4
.................... } 
0126:  RETLW  00
....................  
.................... char    HMF6598_Read_data(){ 
....................  
.................... /*  set_tris_b(0xff); 
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................    
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1);    */  
....................    
....................   set_tris_b(0xff);     
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................   output_low(HMF6598_CS1); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1); 
.................... } 
....................  
.................... void newLine(){ 
....................   if(CurrentLine < 7){  // New Line Command 
....................       HMF6598_Write_command((CurrentLine+1)|0xb0);  // Set Page Address to 0 (0 a 7) 
....................       HMF6598_Write_command(0x00);  // Set LSB for index Column 
....................       HMF6598_Write_command(0x10);  // Set MSB for index Column    
....................       CurrentLine+=1; 
....................   } 
....................   QuantChrLine = 1; 
....................   OffsetX = 0; 
.................... } 
.................... void clear_screen(void) { 
....................    int p, c; 
....................    for(p = 0; p < 8; p++) { 
0128:  CLRF   0C
012A:  MOVF   0C,W
012C:  SUBLW  07
012E:  BNC   014E
....................       for(c = 0; c < 128; c++) { 
0130:  CLRF   0D
0132:  MOVF   0D,W
0134:  SUBLW  7F
0136:  BNC   014A
....................          HMF6598_Gotoxy(c,p); 
0138:  MOVFF  0D,13
013C:  MOVFF  0C,14
0140:  RCALL  00B4
....................          HMF6598_Write_data(0x00); 
0142:  CLRF   12
0144:  RCALL  0110
....................       } 
0146:  INCF   0D,F
0148:  BRA    0132
....................    } 
014A:  INCF   0C,F
014C:  BRA    012A
....................    HMF6598_Gotoxy(0,0);    
014E:  CLRF   13
0150:  CLRF   14
0152:  RCALL  00B4
.................... } 
0154:  GOTO   01C6 (RETURN)
.................... void    HMF6598_Gotoxy(int x, int y){ 
*
00B4:  CLRF   15
....................    int8 OffsetChr = 0; 
....................     
....................    HMF6598_Write_command(0xb0 | y); 
00B6:  MOVF   14,W
00B8:  IORLW  B0
00BA:  MOVWF  16
00BC:  MOVWF  17
00BE:  RCALL  0058
....................    HMF6598_Write_command((0x00 | x) & 0x0f); 
00C0:  MOVF   13,W
00C2:  ANDLW  0F
00C4:  MOVWF  16
00C6:  MOVWF  17
00C8:  RCALL  0058
....................    HMF6598_Write_command(0x10|(x>>4)); 
00CA:  SWAPF  13,W
00CC:  MOVWF  00
00CE:  MOVLW  0F
00D0:  ANDWF  00,F
00D2:  MOVF   00,W
00D4:  IORLW  10
00D6:  MOVWF  16
00D8:  MOVWF  17
00DA:  RCALL  0058
....................     
....................    OffsetChr = (x+1)/6; 
00DC:  MOVLW  01
00DE:  ADDWF  13,W
00E0:  MOVWF  17
00E2:  MOVWF  18
00E4:  MOVLW  06
00E6:  MOVWF  19
00E8:  RCALL  008C
00EA:  MOVFF  01,15
....................    if((x+1)%6) 
00EE:  MOVLW  01
00F0:  ADDWF  13,W
00F2:  MOVWF  17
00F4:  MOVWF  18
00F6:  MOVLW  06
00F8:  MOVWF  19
00FA:  RCALL  008C
00FC:  MOVF   00,W
00FE:  BZ    0102
....................       OffsetChr++;    
0100:  INCF   15,F
....................    CurrentLine = y; 
0102:  MOVFF  14,04
....................    QuantChrLine = OffsetChr; 
0106:  MOVFF  15,05
....................    OffsetX = x; 
010A:  MOVFF  13,06
.................... } 
010E:  RETLW  00
.................... void    HMF6598_Printchar(char cvar){ 
....................    int i; 
....................    if (QuantChrLine > 21)   
....................        newLine();  
....................    else 
....................        QuantChrLine++;     
....................    if(cvar == 0x20) 
....................       for(i=0;i<2;i++) 
....................          HMF6598_Write_data(0x00); 
....................    else{ 
....................       for(i=0;i<5;i++){ 
....................          if (cvar < 0x53){ 
....................             if(TEXT[cvar-0x20][i])          
....................                HMF6598_Write_data(TEXT[cvar-0x20][i]);       
....................          } 
....................          else { 
....................             if(TEXT2[cvar-0x53][i])                
....................                HMF6598_Write_data(TEXT2[cvar-0x53][i]);                
....................          } 
....................       } 
....................    } 
....................    HMF6598_Write_data(0x00); 
.................... } 
.................... void HMF6598_PutPixel(int x, int y, int1 COLOR){ 
....................    char BytePlot = 0, tempByte; 
....................    if((x > 127)||(y > 63)) 
....................       return; 
....................    BytePlot |= 1; 
....................    BytePlot<<=(y%8); 
....................    tempByte = BytePlot; 
....................    HMF6598_Gotoxy(x,(y/8)); 
....................    BytePlot|=HMF6598_Read_data(); 
....................    if(COLOR == OFF) 
....................       BytePlot-=tempByte; 
....................    HMF6598_Write_data(BytePlot); 
.................... } 
....................  
.................... void HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR){ 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................    do{ 
....................       if(fill){ 
....................          HMF6598_line(x-a, y+b, x+a, y+b, color); 
....................          HMF6598_line(x-a, y-b, x+a, y-b, color); 
....................          HMF6598_line(x-b, y+a, x+b, y+a, color); 
....................          HMF6598_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else{ 
....................          HMF6598_PutPixel(a+x, b+y, color); 
....................          HMF6598_PutPixel(b+x, a+y, color); 
....................          HMF6598_PutPixel(x-a, b+y, color); 
....................          HMF6598_PutPixel(x-b, a+y, color); 
....................          HMF6598_PutPixel(b+x, y-a, color); 
....................          HMF6598_PutPixel(a+x, y-b, color); 
....................          HMF6598_PutPixel(x-a, y-b, color); 
....................          HMF6598_PutPixel(x-b, y-a, color); 
....................       } 
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... void HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR){ 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................  
....................    if(x1 > x2) 
....................       addx = -1; 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................       addy = -1; 
....................    else 
....................       addy = 1; 
....................    if(dx >= dy){ 
....................       P = 2*dy - dx; 
....................       for(i=0; i<=dx; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................          if(P < 0){ 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else{ 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else{ 
....................       P = 2*dx - dy; 
....................       for(i=0; i<=dy; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................  
....................          if(P < 0){ 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else{ 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... int x_ext, y_ext; 
.................... void putSprite(int x, int y){ 
....................    const BYTE bloco[8] = {0xFF,0xFF,0x81,0x81,0x81,0x81,0xFF,0xFF}; 
....................    int i; 
....................    char Sp1, Sp2; 
....................    if(x < 121) 
*
01D0:  MOVF   0D,W
01D2:  SUBLW  78
01D4:  BNC   01DA
....................       x_ext = x; 
01D6:  MOVFF  0D,09
....................    if(y < 57) 
01DA:  MOVF   0E,W
01DC:  SUBLW  38
01DE:  BNC   01E4
....................       y_ext = y; 
01E0:  MOVFF  0E,0A
....................    for(i=0;i<8;i++){ 
01E4:  CLRF   0F
01E6:  MOVF   0F,W
01E8:  SUBLW  07
01EA:  BNC   026E
....................       Sp1 = bloco[i] <<(y_ext%8); 
01EC:  CLRF   03
01EE:  MOVF   0F,W
01F0:  RCALL  0004
01F2:  MOVWF  12
01F4:  MOVF   0A,W
01F6:  ANDLW  07
01F8:  MOVWF  01
01FA:  MOVFF  12,10
01FE:  MOVF   01,F
0200:  BZ    020A
0202:  BCF    FD8.0
0204:  RLCF   10,F
0206:  DECFSZ 01,F
0208:  BRA    0202
....................       Sp2 = bloco[i] >>(8-(y_ext%8));       
020A:  CLRF   03
020C:  MOVF   0F,W
020E:  RCALL  0004
0210:  MOVWF  12
0212:  MOVF   0A,W
0214:  ANDLW  07
0216:  XORLW  FF
0218:  ADDLW  09
021A:  MOVWF  01
021C:  MOVFF  12,11
0220:  MOVF   01,F
0222:  BZ    022C
0224:  BCF    FD8.0
0226:  RRCF   11,F
0228:  DECFSZ 01,F
022A:  BRA    0224
....................       HMF6598_Gotoxy(x_ext,(y_ext/8)); 
022C:  RRCF   0A,W
022E:  MOVWF  12
0230:  RRCF   12,F
0232:  RRCF   12,F
0234:  MOVLW  1F
0236:  ANDWF  12,F
0238:  MOVFF  09,13
023C:  MOVFF  12,14
0240:  RCALL  00B4
....................       HMF6598_Write_data(Sp1); 
0242:  MOVFF  10,12
0246:  RCALL  0110
....................       HMF6598_Gotoxy(x_ext,(y_ext/8)+1);             
0248:  RRCF   0A,W
024A:  MOVWF  00
024C:  RRCF   00,F
024E:  RRCF   00,F
0250:  MOVLW  1F
0252:  ANDWF  00,F
0254:  MOVF   00,W
0256:  ADDLW  01
0258:  MOVWF  12
025A:  MOVFF  09,13
025E:  MOVWF  14
0260:  RCALL  00B4
....................       HMF6598_Write_data(Sp2); 
0262:  MOVFF  11,12
0266:  RCALL  0110
....................       x_ext++; 
0268:  INCF   09,F
....................    } 
026A:  INCF   0F,F
026C:  BRA    01E6
....................    x_ext -= 8; 
026E:  MOVLW  08
0270:  SUBWF  09,F
.................... } 
0272:  RETLW  00
....................  
.................... void main(void){ 
0274:  CLRF   FF8
0276:  BCF    FD0.7
0278:  CLRF   FEA
027A:  CLRF   FE9
027C:  CLRF   04
027E:  CLRF   05
0280:  CLRF   06
0282:  MOVF   FC1,W
0284:  ANDLW  C0
0286:  IORLW  0F
0288:  MOVWF  FC1
028A:  MOVLW  07
028C:  MOVWF  FB4
028E:  CLRF   07
0290:  CLRF   08
....................    int v; 
....................    HMF6598_InitLcd(); 
0292:  BRA    0158
....................    putSprite(3, 3); 
0294:  MOVLW  03
0296:  MOVWF  0D
0298:  MOVWF  0E
029A:  RCALL  01D0
....................    while(true){ 
....................       delay_ms(50); 
029C:  MOVLW  32
029E:  MOVWF  0C
02A0:  RCALL  0064
....................       if(!input(pin_D7)){    
02A2:  BSF    F95.7
02A4:  BTFSC  F83.7
02A6:  BRA    02FA
....................          putSprite(x_ext+1, y_ext); 
02A8:  MOVLW  01
02AA:  ADDWF  09,W
02AC:  MOVWF  0C
02AE:  MOVWF  0D
02B0:  MOVFF  0A,0E
02B4:  RCALL  01D0
....................           
....................          HMF6598_Gotoxy(x_ext-1,(y_ext/8)); 
02B6:  MOVLW  01
02B8:  SUBWF  09,W
02BA:  MOVWF  0C
02BC:  RRCF   0A,W
02BE:  MOVWF  0D
02C0:  RRCF   0D,F
02C2:  RRCF   0D,F
02C4:  MOVLW  1F
02C6:  ANDWF  0D,F
02C8:  MOVFF  0C,13
02CC:  MOVFF  0D,14
02D0:  RCALL  00B4
....................          HMF6598_Write_data(0x00); 
02D2:  CLRF   12
02D4:  RCALL  0110
....................          HMF6598_Gotoxy(x_ext-1,(y_ext/8)+1); 
02D6:  MOVLW  01
02D8:  SUBWF  09,W
02DA:  MOVWF  0C
02DC:  RRCF   0A,W
02DE:  MOVWF  00
02E0:  RRCF   00,F
02E2:  RRCF   00,F
02E4:  MOVLW  1F
02E6:  ANDWF  00,F
02E8:  MOVF   00,W
02EA:  ADDLW  01
02EC:  MOVWF  0D
02EE:  MOVFF  0C,13
02F2:  MOVWF  14
02F4:  RCALL  00B4
....................          HMF6598_Write_data(0x00);          
02F6:  CLRF   12
02F8:  RCALL  0110
....................       } 
....................       if(!input(pin_D6)){    
02FA:  BSF    F95.6
02FC:  BTFSC  F83.6
02FE:  BRA    033E
....................          for(v=0;v<8;v++){ 
0300:  CLRF   0B
0302:  MOVF   0B,W
0304:  SUBLW  07
0306:  BNC   0330
....................             HMF6598_Gotoxy(x_ext+v,(y_ext/8)+1);             
0308:  MOVF   0B,W
030A:  ADDWF  09,W
030C:  MOVWF  0C
030E:  RRCF   0A,W
0310:  MOVWF  00
0312:  RRCF   00,F
0314:  RRCF   00,F
0316:  MOVLW  1F
0318:  ANDWF  00,F
031A:  MOVF   00,W
031C:  ADDLW  01
031E:  MOVWF  0D
0320:  MOVFF  0C,13
0324:  MOVWF  14
0326:  RCALL  00B4
....................             HMF6598_Write_data(0x00);          
0328:  CLRF   12
032A:  RCALL  0110
....................          } 
032C:  INCF   0B,F
032E:  BRA    0302
....................          putSprite(x_ext, y_ext-1); 
0330:  MOVLW  01
0332:  SUBWF  0A,W
0334:  MOVWF  0C
0336:  MOVFF  09,0D
033A:  MOVWF  0E
033C:  RCALL  01D0
....................       } 
....................       if(!input(pin_D5)){   
033E:  BSF    F95.5
0340:  BTFSC  F83.5
0342:  BRA    037E
....................          for(v=0;v<8;v++){ 
0344:  CLRF   0B
0346:  MOVF   0B,W
0348:  SUBLW  07
034A:  BNC   0370
....................             HMF6598_Gotoxy(x_ext+v,(y_ext/8));             
034C:  MOVF   0B,W
034E:  ADDWF  09,W
0350:  MOVWF  0C
0352:  RRCF   0A,W
0354:  MOVWF  0D
0356:  RRCF   0D,F
0358:  RRCF   0D,F
035A:  MOVLW  1F
035C:  ANDWF  0D,F
035E:  MOVFF  0C,13
0362:  MOVFF  0D,14
0366:  RCALL  00B4
....................             HMF6598_Write_data(0x00);          
0368:  CLRF   12
036A:  RCALL  0110
....................          }       
036C:  INCF   0B,F
036E:  BRA    0346
....................          putSprite(x_ext, y_ext+1); 
0370:  MOVLW  01
0372:  ADDWF  0A,W
0374:  MOVWF  0C
0376:  MOVFF  09,0D
037A:  MOVWF  0E
037C:  RCALL  01D0
....................       } 
....................       if(!input(pin_D4)){    
037E:  BSF    F95.4
0380:  BTFSC  F83.4
0382:  BRA    03D6
....................          putSprite(x_ext-1, y_ext); 
0384:  MOVLW  01
0386:  SUBWF  09,W
0388:  MOVWF  0C
038A:  MOVWF  0D
038C:  MOVFF  0A,0E
0390:  RCALL  01D0
....................           
....................          HMF6598_Gotoxy(x_ext+8,(y_ext/8)); 
0392:  MOVLW  08
0394:  ADDWF  09,W
0396:  MOVWF  0C
0398:  RRCF   0A,W
039A:  MOVWF  0D
039C:  RRCF   0D,F
039E:  RRCF   0D,F
03A0:  MOVLW  1F
03A2:  ANDWF  0D,F
03A4:  MOVFF  0C,13
03A8:  MOVFF  0D,14
03AC:  RCALL  00B4
....................          HMF6598_Write_data(0x00); 
03AE:  CLRF   12
03B0:  RCALL  0110
....................          HMF6598_Gotoxy(x_ext+8,(y_ext/8)+1); 
03B2:  MOVLW  08
03B4:  ADDWF  09,W
03B6:  MOVWF  0C
03B8:  RRCF   0A,W
03BA:  MOVWF  00
03BC:  RRCF   00,F
03BE:  RRCF   00,F
03C0:  MOVLW  1F
03C2:  ANDWF  00,F
03C4:  MOVF   00,W
03C6:  ADDLW  01
03C8:  MOVWF  0D
03CA:  MOVFF  0C,13
03CE:  MOVWF  14
03D0:  RCALL  00B4
....................          HMF6598_Write_data(0x00);            
03D2:  CLRF   12
03D4:  RCALL  0110
....................       }       
....................    } 
03D6:  BRA    029C
....................    //int i, j; 
....................    /* HMF6598_Gotoxy(0,0);    
....................    printf(HMF6598_Printchar, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");    
....................    */ 
....................    /*for(i=0;i<8;i++){ 
....................       HMF6598_Gotoxy(0,i); 
....................       for(j=0;j<128;j++){ 
....................          HMF6598_Write_data(cenario[i][j]);            
....................          } 
....................    }*/ 
....................     
.................... } 
03D8:  SLEEP 

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV20 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICPRT NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
