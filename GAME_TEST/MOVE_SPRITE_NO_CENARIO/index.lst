CCS PCH C Compiler, Version 4.114, 93460303               30-mar-13 21:47

               Filename: D:\SkyDrive\Eletronica\PROJETOS PIC CCS\GAME_TEST\MOVE_SPRITE_NO_CENARIO\index.lst

               ROM used: 2638 bytes (8%)
                         Largest free fragment is 30130
               RAM used: 16 (1%) at main() level
                         28 (1%) worst case
               Stack:    6 locations

*
0000:  GOTO   071A
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #use delay(clock=48000000) 
*
042A:  MOVLW  01
042C:  SUBWF  0D,F
042E:  BNC   0448
0430:  CLRF   FEA
0432:  MOVLW  0D
0434:  MOVWF  FE9
0436:  MOVF   FEF,W
0438:  BZ    0448
043A:  MOVLW  02
043C:  MOVWF  00
043E:  DECFSZ 00,F
0440:  BRA    043E
0442:  BRA    0444
0444:  DECFSZ FEF,F
0446:  BRA    043A
0448:  RETLW  00
*
0472:  CLRF   FEA
0474:  MOVLW  0D
0476:  MOVWF  FE9
0478:  MOVF   FEF,W
047A:  BZ    0498
047C:  MOVLW  0F
047E:  MOVWF  01
0480:  CLRF   00
0482:  DECFSZ 00,F
0484:  BRA    0482
0486:  DECFSZ 01,F
0488:  BRA    0480
048A:  MOVLW  8F
048C:  MOVWF  00
048E:  DECFSZ 00,F
0490:  BRA    048E
0492:  NOP   
0494:  DECFSZ FEF,F
0496:  BRA    047C
0498:  RETLW  00
.................... #fuses HSPLL, PLL4, CPUDIV1, PUT, NOWDT, NOBROWNOUT, NOLVP 
.................... #include "HMF6598SYH-PY.c" 
.................... const BYTE cenario[8][128] =  
.................... { 
.................... 0x00,0x00,0x80,0xC0,0x40,0x70,0x0C,0x04, 
.................... 0x04,0x04,0x04,0x0C,0x18,0x38,0x0C,0x04, 
.................... 0x04,0x04,0x04,0x0C,0x18,0x18,0x0C,0x04, 
.................... 0x04,0x04,0x0C,0x08,0x08,0x18,0xF0,0xE0, 
.................... 0x00,0x00,0x00,0x00,0x00,0x78,0xCC,0x8C, 
.................... 0x84,0x84,0x04,0x0C,0x18,0x0C,0x84,0x84, 
.................... 0xC4,0x44,0x74,0x18,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x10,0x28,0x24,0x24,0x18,0x00, 
.................... 0x00,0x00,0x00,0x00,0x20,0xFC,0x84,0x04, 
.................... 0x06,0x0E,0x12,0x02,0x02,0x02,0x04,0x08, 
.................... 0x08,0x08,0x88,0xCC,0x64,0x44,0xC4,0x84, 
.................... 0x84,0x84,0x8C,0x82,0x82,0x82,0x82,0x42, 
.................... 0x42,0x66,0x3C,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x38,0xEC,0x84,0x02,0x02,0x01,0x01, 
.................... 0x01,0x02,0x04,0x04,0x04,0x08,0x98,0x10, 
.................... 0x08,0x08,0x84,0x84,0xC4,0x44,0x6C,0x30, 
.................... 0x00,0x00,0x07,0x0E,0x18,0x18,0x18,0x1C, 
.................... 0x1C,0x0F,0x08,0x18,0x10,0x10,0x10,0x10, 
.................... 0x10,0x18,0x0F,0x03,0x0C,0x08,0x08,0x0C, 
.................... 0x0C,0x0C,0x0C,0x0C,0x06,0x07,0x07,0x03, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01, 
.................... 0x03,0x02,0x06,0x04,0x04,0x04,0x04,0x06, 
.................... 0x02,0x03,0x01,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x01,0x03,0x02,0x02,0x06, 
.................... 0x04,0x04,0x04,0x02,0x03,0x01,0x01,0x03, 
.................... 0x06,0x04,0x08,0x08,0x05,0x03,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x10,0x10,0x10,0xF0,0x90,0x10, 
.................... 0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00, 
.................... 0xFF,0xFF,0x01,0x01,0x19,0x01,0x01,0x01, 
.................... 0x01,0x01,0x01,0x39,0x01,0x01,0x01,0xFF, 
.................... 0x00,0x00,0x10,0x10,0xF8,0x10,0x10,0x10, 
.................... 0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0x01,0x01,0x19,0x19,0x01,0x01,0x01, 
.................... 0x01,0x19,0x01,0xFF,0x00,0x00,0x00,0x00, 
.................... 0xE0,0x20,0x3F,0x21,0x21,0x21,0x21,0x3F, 
.................... 0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0xE0,0xE2,0x22,0x3E,0xA3,0xE2, 
.................... 0x22,0x20,0x24,0xFC,0x24,0x64,0x60,0xE0, 
.................... 0xE0,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xB8, 
.................... 0xAC,0xA6,0xEB,0xB5,0x9C,0x87,0x80,0x80, 
.................... 0xFF,0xFF,0x00,0x00,0x18,0x00,0x00,0x00, 
.................... 0x00,0x00,0x04,0x3C,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x01,0x19,0x19,0x01,0x01,0x01,0x01, 
.................... 0x01,0x01,0x19,0x19,0x01,0x01,0x01,0xFF, 
.................... 0x00,0x00,0x20,0x30,0x70,0xF0,0x18,0x08, 
.................... 0x00,0x01,0x03,0x0E,0x7E,0xCC,0x00,0x00, 
.................... 0xFF,0x00,0x00,0xC3,0xC3,0x00,0x00,0x00, 
.................... 0x00,0xC3,0x00,0xFF,0xFC,0x04,0x04,0x04, 
.................... 0x87,0x84,0x04,0x1C,0x04,0x04,0x84,0x84, 
.................... 0x07,0x04,0x04,0x1C,0x04,0x84,0x04,0x04, 
.................... 0x04,0x04,0xFF,0xFF,0x00,0xF0,0x1F,0x00, 
.................... 0x00,0xFC,0x03,0x01,0x00,0x00,0x00,0x00, 
.................... 0x01,0x0F,0xFF,0x00,0x00,0x80,0x80,0xC0, 
.................... 0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00,0x08, 
.................... 0x08,0x08,0x00,0x00,0x1C,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00, 
.................... 0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x86,0x86,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x83,0x83,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x01,0x01,0x11,0x11,0x01,0x01,0x01, 
.................... 0x01,0x01,0x11,0x11,0x01,0x01,0x01,0xFF, 
.................... 0xFF,0x00,0x00,0x30,0x30,0x00,0x00,0x00, 
.................... 0x00,0x30,0x00,0xFF,0xFF,0x00,0x00,0x00, 
.................... 0x31,0x31,0x00,0x00,0x00,0x00,0x31,0x31, 
.................... 0x00,0x00,0x00,0x00,0x00,0x71,0x00,0x00, 
.................... 0x00,0x00,0xFF,0xFF,0x00,0x00,0x0F,0x30, 
.................... 0xE0,0x00,0x03,0x0C,0x30,0x60,0x80,0x00, 
.................... 0x00,0x00,0xFF,0xF0,0x13,0x11,0x91,0x97, 
.................... 0x1C,0x10,0x10,0x13,0x9C,0x14,0x10,0xF0, 
.................... 0xFF,0x00,0x00,0x0F,0x0F,0x00,0x00,0x00, 
.................... 0x04,0x04,0x00,0x00,0x0F,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0xC7,0xC7,0x00,0x00, 
.................... 0x00,0x00,0x00,0x43,0xC0,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x61,0x61,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x61,0x61,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x04,0x04,0x00,0x00,0x00, 
.................... 0x00,0x00,0x04,0x04,0x00,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x0C,0x0C,0x00,0x00,0x00, 
.................... 0x00,0x0C,0x00,0xFF,0xFF,0x00,0x00,0x00, 
.................... 0x1C,0x1C,0x00,0x00,0x00,0x00,0x1C,0x1C, 
.................... 0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x00, 
.................... 0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00, 
.................... 0xE1,0x1F,0x00,0x00,0x00,0x00,0x01,0x0F, 
.................... 0xF8,0x00,0xFF,0xFF,0x00,0x00,0xE3,0xE3, 
.................... 0x00,0x00,0x00,0x00,0xE3,0x00,0x00,0xFF, 
.................... 0xFF,0x00,0x00,0x8F,0x8F,0x00,0x00,0x04, 
.................... 0x04,0x04,0x00,0x00,0x1F,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0x00,0x00,0x30,0x30,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x73,0x00,0x00,0xFF, 
.................... 0xFF,0x80,0x8C,0x8C,0x80,0x80,0xC0,0xC0, 
.................... 0xC0,0x80,0x8C,0x8C,0x80,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x82,0x82,0x80,0xC0,0xC0, 
.................... 0xC0,0xC0,0x82,0x82,0x80,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x83,0x83,0x80,0x80,0x80, 
.................... 0x80,0x83,0x80,0xFF,0xFF,0x80,0x80,0x80, 
.................... 0x8E,0xCE,0xC0,0xC0,0xC0,0xC0,0xCE,0xCE, 
.................... 0xC0,0xC0,0xC0,0xC0,0xC0,0x8E,0x80,0x80, 
.................... 0x80,0x80,0xFF,0xFF,0x80,0x80,0x80,0xC0, 
.................... 0xBF,0x80,0x80,0x80,0x80,0xA0,0xB0,0x9C, 
.................... 0x87,0x80,0xFF,0xFF,0x80,0x80,0x98,0x98, 
.................... 0x80,0x80,0x80,0x80,0x98,0x80,0x80,0xFF, 
.................... 0xFF,0x80,0x80,0x87,0x87,0x80,0x80,0x82, 
.................... 0x82,0x82,0x80,0x80,0x87,0x80,0x80,0x80, 
.................... 0xFF,0xFF,0x80,0x80,0x86,0x86,0x80,0x80, 
.................... 0x80,0x80,0x80,0x80,0x86,0x80,0x80,0xFF}; 
.................... /* 
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01\ 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x00, 0x41, 0x49, 0x49, 0x36, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x00, 0x27, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x00, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x7e, 0x00, // A      34 
....................                          0x7F, 0x49, 0x49, 0x36, 0x00, // B 
....................                          0x3E, 0x41, 0x41, 0x22, 0x00, // C 
....................                          0x7F, 0x41, 0x41, 0x3e, 0x00, // D      37 
....................                          0x7F, 0x49, 0x49, 0x41, 0x00, // E 
....................                          0x7F, 0x09, 0x09, 0x01, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x08, 0x7f, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x3f, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x3e, 0x00, // O 
....................                          0x7F, 0x09, 0x09, 0x06, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x09, 0x76, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x32, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x40, 0x3f, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x08, 0x04, 0x78, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x04, 0x78, 0x00, // n 
....................                          0x38, 0x44, 0x44, 0x38, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x00, 0x3c, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x3c, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... */ 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE  01 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x00, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x00, // / 
....................                          0x3E, 0x51, 0x49, 0x3e, 0x00, // 0      17 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x00, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x41, 0x49, 0x49, 0x36, 0x00, // 3      20 
....................                          0x18, 0x14, 0x12, 0x7F, 0x00, // 4 
....................                          0x27, 0x45, 0x45, 0x39, 0x00, // 5 
....................                          0x3E, 0x49, 0x49, 0x32, 0x00, // 6      23 
....................                          0x71, 0x09, 0x09, 0x07, 0x00,  // 7 
....................                          0x36, 0x49, 0x49, 0x36, 0x00, // 8 
....................                          0x26, 0x49, 0x49, 0x3e, 0x00, // 9      26 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x00, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x7e, 0x00, 0x00, // A      34 
....................                          0x7F, 0x49, 0x36, 0x00, 0x00, // B 
....................                          0x3E, 0x41, 0x22, 0x00, 0x00, // C 
....................                          0x7F, 0x41, 0x3e, 0x00, 0x00, // D      37 
....................                          0x7F, 0x49, 0x41, 0x00, 0x00, // E 
....................                          0x7F, 0x09, 0x01, 0x00, 0x00, // F 
....................                          0x3E, 0x41, 0x49, 0x3a, 0x00, // G      40 
....................                          0x7F, 0x08, 0x7f, 0x00, 0x00, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x3f, 0x00, 0x00, // J      43 
....................                          0x7F, 0x08, 0x14, 0x63, 0x00, // K 
....................                          0x7F, 0x40, 0x40, 0x00, 0x00, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M      46 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x3e, 0x00, 0x00, // O 
....................                          0x7F, 0x09, 0x06, 0x00, 0x00, // P      49 
....................                          0x1E, 0x21, 0x21, 0x5e, 0x00, // Q 
....................                          0x7F, 0x09, 0x76, 0x00, 0x00};// R      51 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x32, 0x00, 0x00, // S 
....................                          0x00, 0x01, 0x7F, 0x01, 0x00, // T 
....................                          0x3F, 0x40, 0x3f, 0x00, 0x00, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x47, 0x00, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x00, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          //0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x38, 0x44, 0x44, 0x7c, 0x00,  // a  
....................                          0x7F, 0x44, 0x44, 0x38, 0x00, // b 
....................                          0x38, 0x44, 0x44, 0x00, 0x00, // c 
....................                          0x38, 0x44, 0x44, 0x7f, 0x00, // d 
....................                          0x38, 0x54, 0x54, 0x18, 0x00, // e 
....................                          0x00, 0x04, 0x7E, 0x05, 0x00, // f 
....................                          0x08, 0x54, 0x54, 0x3c, 0x00, // g 
....................                          0x7F, 0x04, 0x78, 0x00, 0x00, // h 
....................                          0x00, 0x00, 0x7a, 0x00, 0x00, // i 
....................                          0x20, 0x00, 0x44, 0x3D, 0x00, // j 
....................                          0x7e, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x04, 0x78, 0x00, 0x00, // n 
....................                          0x38, 0x44, 0x38, 0x00, 0x00, // o 
....................                          0x7C, 0x14, 0x14, 0x08, 0x00, // p 
....................                          0x08, 0x14, 0x14, 0x7c, 0x00, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x00, // r 
....................                          0x08, 0x54, 0x54, 0x20, 0x00, // s 
....................                          0x00, 0x04, 0x3F, 0x44, 0x00, // t 
....................                          0x3c, 0x40, 0x7c, 0x00, 0x00, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x3c, 0x00, 0x00, // y 
....................                          0x00, 0x64, 0x54, 0x4C, 0x00, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
.................... #define HMF6598_RS    pin_A0 
.................... #define HMF6598_RES   pin_A1 
.................... #define HMF6598_CS1   pin_A2 
.................... #define HMF6598_RD    pin_A3 
.................... #define HMF6598_WR    pin_A4 
....................  
.................... #define ON   1 
.................... #define OFF  0 
....................  
.................... int8 CurrentLine = 0; 
.................... int8 QuantChrLine = 0; 
.................... int8 OffsetX = 0; 
....................  
.................... void    HMF6598_InitLcd(void); 
.................... void    HMF6598_Write_command(char byte_command); 
.................... void    HMF6598_Write_data(char byte_data); 
.................... char    HMF6598_Read_data(); 
.................... void    HMF6598_Gotoxy(int8 x, int y); 
.................... void    HMF6598_Printchar(char cvar); 
.................... void    HMF6598_PutPixel(int8 x,int8 y, int1 COLOR); 
.................... void    HMF6598_OutPort(char byteDC); 
.................... void    clear_screen(void); 
.................... void    newLine(void); 
.................... void    HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR); 
.................... void    HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR); 
....................  
.................... void    HMF6598_InitLcd(void){ 
....................     
....................    output_low(HMF6598_CS1); // Chip Enabled 
*
0566:  BCF    F92.2
0568:  BCF    F89.2
....................    output_low(HMF6598_RES); 
056A:  BCF    F92.1
056C:  BCF    F89.1
....................    delay_us(200); 
056E:  MOVLW  C8
0570:  MOVWF  0D
0572:  RCALL  042A
....................    output_high(HMF6598_RES);  
0574:  BCF    F92.1
0576:  BSF    F89.1
....................    delay_us(200);    
0578:  MOVLW  C8
057A:  MOVWF  0D
057C:  RCALL  042A
....................  
....................    HMF6598_Write_command(0xc8);   // Duty = 65    
057E:  MOVLW  C8
0580:  MOVWF  18
0582:  RCALL  0466
....................    HMF6598_Write_command(0xa3);   // BIAS 1/9 
0584:  MOVLW  A3
0586:  MOVWF  18
0588:  RCALL  0466
....................    HMF6598_Write_command(0xa0);   // ADC Select 
058A:  MOVLW  A0
058C:  MOVWF  18
058E:  RCALL  0466
....................    HMF6598_Write_command(0xa6);   // Normal display 0xa6:  Reverse Display :0xa7 
0590:  MOVLW  A6
0592:  MOVWF  18
0594:  RCALL  0466
....................    HMF6598_Write_command(0x2c);   //---------------------------------------------  
0596:  MOVLW  2C
0598:  MOVWF  18
059A:  RCALL  0466
....................    delay_ms(3);                   // 
059C:  MOVLW  03
059E:  MOVWF  0D
05A0:  RCALL  0472
....................    HMF6598_Write_command(0x2e);   // Power Control Set VR, VC, VF  
05A2:  MOVLW  2E
05A4:  MOVWF  18
05A6:  RCALL  0466
....................    delay_ms(3);                   // 
05A8:  MOVLW  03
05AA:  MOVWF  0D
05AC:  RCALL  0472
....................    HMF6598_Write_command(0x2f);   //--------------------------------------------- 
05AE:  MOVLW  2F
05B0:  MOVWF  18
05B2:  RCALL  0466
....................    HMF6598_Write_command(0x20);   // 1+Rb/Ra Ratio    
05B4:  MOVLW  20
05B6:  MOVWF  18
05B8:  RCALL  0466
....................    HMF6598_Write_command(0x40);   // EVER register Set    
05BA:  MOVLW  40
05BC:  MOVWF  18
05BE:  RCALL  0466
....................     
....................    //Set Brightness   
....................    HMF6598_Write_command(0x81);  
05C0:  MOVLW  81
05C2:  MOVWF  18
05C4:  RCALL  0466
....................    HMF6598_Write_command(0x32); 
05C6:  MOVLW  32
05C8:  MOVWF  18
05CA:  RCALL  0466
....................     
....................    HMF6598_Write_command(0xe0);   // Set Modify Read  0xee to cancel / 0xe0 to activate 
05CC:  MOVLW  E0
05CE:  MOVWF  18
05D0:  RCALL  0466
....................  
....................    clear_screen(); 
05D2:  BRA    0536
....................    HMF6598_Write_command(0xaf);   // Display ON 
05D4:  MOVLW  AF
05D6:  MOVWF  18
05D8:  RCALL  0466
.................... } 
05DA:  GOTO   073A (RETURN)
....................  
.................... void HMF6598_OutPort(char byteDC){ 
....................   set_tris_b(0x00); 
*
044A:  MOVLW  00
044C:  MOVWF  F93
....................   output_low(HMF6598_CS1); 
044E:  BCF    F92.2
0450:  BCF    F89.2
....................   output_high(HMF6598_RD);  
0452:  BCF    F92.3
0454:  BSF    F89.3
....................   output_low(HMF6598_WR);   
0456:  BCF    F92.4
0458:  BCF    F89.4
....................   output_b(byteDC); 
045A:  CLRF   F93
045C:  MOVFF  19,F8A
....................   output_high(HMF6598_CS1);     
0460:  BCF    F92.2
0462:  BSF    F89.2
.................... } 
0464:  RETLW  00
.................... void    HMF6598_Write_command(char byte_command){ 
....................   output_low(HMF6598_RS);          // Write Command Enabled 
0466:  BCF    F92.0
0468:  BCF    F89.0
....................   HMF6598_OutPort(byte_command); 
046A:  MOVFF  18,19
046E:  RCALL  044A
.................... } 
0470:  RETLW  00
.................... void    HMF6598_Write_data(char byte_data){ 
....................   output_high(HMF6598_RS);         // Write data Enabled 
*
051E:  BCF    F92.0
0520:  BSF    F89.0
....................   HMF6598_OutPort(byte_data); 
0522:  MOVFF  13,19
0526:  RCALL  044A
....................   OffsetX++; 
0528:  INCF   06,F
....................   HMF6598_Gotoxy(OffsetX,CurrentLine); 
052A:  MOVFF  06,14
052E:  MOVFF  04,15
0532:  RCALL  04C2
.................... } 
0534:  RETLW  00
....................  
.................... char    HMF6598_Read_data(){ 
....................  
.................... /*  set_tris_b(0xff); 
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................    
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_WR); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1);    */  
....................    
....................   set_tris_b(0xff);     
....................   output_low(HMF6598_CS1); 
....................   output_high(HMF6598_WR); 
....................   output_high(HMF6598_RS); 
....................   output_low(HMF6598_RD); 
....................   output_high(HMF6598_CS1); 
....................   delay_us(1); 
....................   output_low(HMF6598_CS1); 
....................   return input_b(); 
....................   output_high(HMF6598_CS1); 
.................... } 
....................  
.................... void newLine(){ 
....................   if(CurrentLine < 7){  // New Line Command 
....................       HMF6598_Write_command((CurrentLine+1)|0xb0);  // Set Page Address to 0 (0 a 7) 
....................       HMF6598_Write_command(0x00);  // Set LSB for index Column 
....................       HMF6598_Write_command(0x10);  // Set MSB for index Column    
....................       CurrentLine+=1; 
....................   } 
....................   QuantChrLine = 1; 
....................   OffsetX = 0; 
.................... } 
.................... void clear_screen(void) { 
....................    int p, c; 
....................    for(p = 0; p < 8; p++) { 
0536:  CLRF   0D
0538:  MOVF   0D,W
053A:  SUBLW  07
053C:  BNC   055C
....................       for(c = 0; c < 128; c++) { 
053E:  CLRF   0E
0540:  MOVF   0E,W
0542:  SUBLW  7F
0544:  BNC   0558
....................          HMF6598_Gotoxy(c,p); 
0546:  MOVFF  0E,14
054A:  MOVFF  0D,15
054E:  RCALL  04C2
....................          HMF6598_Write_data(0x00); 
0550:  CLRF   13
0552:  RCALL  051E
....................       } 
0554:  INCF   0E,F
0556:  BRA    0540
....................    } 
0558:  INCF   0D,F
055A:  BRA    0538
....................    HMF6598_Gotoxy(0,0);    
055C:  CLRF   14
055E:  CLRF   15
0560:  RCALL  04C2
.................... } 
0562:  GOTO   05D4 (RETURN)
.................... void    HMF6598_Gotoxy(int x, int y){ 
*
04C2:  CLRF   16
....................    int8 OffsetChr = 0; 
....................     
....................    HMF6598_Write_command(0xb0 | y); 
04C4:  MOVF   15,W
04C6:  IORLW  B0
04C8:  MOVWF  17
04CA:  MOVWF  18
04CC:  RCALL  0466
....................    HMF6598_Write_command((0x00 | x) & 0x0f); 
04CE:  MOVF   14,W
04D0:  ANDLW  0F
04D2:  MOVWF  17
04D4:  MOVWF  18
04D6:  RCALL  0466
....................    HMF6598_Write_command(0x10|(x>>4)); 
04D8:  SWAPF  14,W
04DA:  MOVWF  00
04DC:  MOVLW  0F
04DE:  ANDWF  00,F
04E0:  MOVF   00,W
04E2:  IORLW  10
04E4:  MOVWF  17
04E6:  MOVWF  18
04E8:  RCALL  0466
....................     
....................    OffsetChr = (x+1)/6; 
04EA:  MOVLW  01
04EC:  ADDWF  14,W
04EE:  MOVWF  18
04F0:  MOVWF  19
04F2:  MOVLW  06
04F4:  MOVWF  1A
04F6:  RCALL  049A
04F8:  MOVFF  01,16
....................    if((x+1)%6) 
04FC:  MOVLW  01
04FE:  ADDWF  14,W
0500:  MOVWF  18
0502:  MOVWF  19
0504:  MOVLW  06
0506:  MOVWF  1A
0508:  RCALL  049A
050A:  MOVF   00,W
050C:  BZ    0510
....................       OffsetChr++;    
050E:  INCF   16,F
....................    CurrentLine = y; 
0510:  MOVFF  15,04
....................    QuantChrLine = OffsetChr; 
0514:  MOVFF  16,05
....................    OffsetX = x; 
0518:  MOVFF  14,06
.................... } 
051C:  RETLW  00
.................... void    HMF6598_Printchar(char cvar){ 
....................    int i; 
....................    if (QuantChrLine > 21)   
....................        newLine();  
....................    else 
....................        QuantChrLine++;     
....................    if(cvar == 0x20) 
....................       for(i=0;i<2;i++) 
....................          HMF6598_Write_data(0x00); 
....................    else{ 
....................       for(i=0;i<5;i++){ 
....................          if (cvar < 0x53){ 
....................             if(TEXT[cvar-0x20][i])          
....................                HMF6598_Write_data(TEXT[cvar-0x20][i]);       
....................          } 
....................          else { 
....................             if(TEXT2[cvar-0x53][i])                
....................                HMF6598_Write_data(TEXT2[cvar-0x53][i]);                
....................          } 
....................       } 
....................    } 
....................    HMF6598_Write_data(0x00); 
.................... } 
.................... void HMF6598_PutPixel(int x, int y, int1 COLOR){ 
....................    char BytePlot = 0, tempByte; 
....................    if((x > 127)||(y > 63)) 
....................       return; 
....................    BytePlot |= 1; 
....................    BytePlot<<=(y%8); 
....................    tempByte = BytePlot; 
....................    HMF6598_Gotoxy(x,(y/8)); 
....................    BytePlot|=HMF6598_Read_data(); 
....................    if(COLOR == OFF) 
....................       BytePlot-=tempByte; 
....................    HMF6598_Write_data(BytePlot); 
.................... } 
....................  
.................... void HMF6598_circle(int x, int y, int radius, int1 fill, int1 COLOR){ 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................    do{ 
....................       if(fill){ 
....................          HMF6598_line(x-a, y+b, x+a, y+b, color); 
....................          HMF6598_line(x-a, y-b, x+a, y-b, color); 
....................          HMF6598_line(x-b, y+a, x+b, y+a, color); 
....................          HMF6598_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else{ 
....................          HMF6598_PutPixel(a+x, b+y, color); 
....................          HMF6598_PutPixel(b+x, a+y, color); 
....................          HMF6598_PutPixel(x-a, b+y, color); 
....................          HMF6598_PutPixel(x-b, a+y, color); 
....................          HMF6598_PutPixel(b+x, y-a, color); 
....................          HMF6598_PutPixel(a+x, y-b, color); 
....................          HMF6598_PutPixel(x-a, y-b, color); 
....................          HMF6598_PutPixel(x-b, y-a, color); 
....................       } 
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... void HMF6598_line(int x1, int y1, int x2, int y2, int1 COLOR){ 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................  
....................    if(x1 > x2) 
....................       addx = -1; 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................       addy = -1; 
....................    else 
....................       addy = 1; 
....................    if(dx >= dy){ 
....................       P = 2*dy - dx; 
....................       for(i=0; i<=dx; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................          if(P < 0){ 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else{ 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else{ 
....................       P = 2*dx - dy; 
....................       for(i=0; i<=dy; ++i){ 
....................          HMF6598_PutPixel(x, y, COLOR); 
....................  
....................          if(P < 0){ 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else{ 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... int x_ext, y_ext; 
.................... void putSprite(int x, int y){ 
....................    const BYTE bloco[8] = {0xFF,0xFF,0x81,0x81,0x81,0x81,0xFF,0xFF}; 
....................    int i; 
....................    char Sp1, Sp2; 
....................    if(x < 121) 
*
05FC:  MOVF   0E,W
05FE:  SUBLW  78
0600:  BNC   0606
....................       x_ext = x; 
0602:  MOVFF  0E,09
....................    if(y < 57) 
0606:  MOVF   0F,W
0608:  SUBLW  38
060A:  BNC   0610
....................       y_ext = y; 
060C:  MOVFF  0F,0A
....................    for(i=0;i<8;i++){ 
0610:  CLRF   10
0612:  MOVF   10,W
0614:  SUBLW  07
0616:  BTFSS  FD8.0
0618:  BRA    0714
....................       Sp1 = bloco[i] <<(y_ext%8); 
061A:  CLRF   03
061C:  MOVF   10,W
061E:  RCALL  0412
0620:  MOVWF  13
0622:  MOVF   0A,W
0624:  ANDLW  07
0626:  MOVWF  01
0628:  MOVFF  13,11
062C:  MOVF   01,F
062E:  BZ    0638
0630:  BCF    FD8.0
0632:  RLCF   11,F
0634:  DECFSZ 01,F
0636:  BRA    0630
....................       Sp2 = bloco[i] >>(8-(y_ext%8));       
0638:  CLRF   03
063A:  MOVF   10,W
063C:  RCALL  0412
063E:  MOVWF  13
0640:  MOVF   0A,W
0642:  ANDLW  07
0644:  XORLW  FF
0646:  ADDLW  09
0648:  MOVWF  01
064A:  MOVFF  13,12
064E:  MOVF   01,F
0650:  BZ    065A
0652:  BCF    FD8.0
0654:  RRCF   12,F
0656:  DECFSZ 01,F
0658:  BRA    0652
....................       HMF6598_Gotoxy(x_ext,(y_ext/8)); 
065A:  RRCF   0A,W
065C:  MOVWF  13
065E:  RRCF   13,F
0660:  RRCF   13,F
0662:  MOVLW  1F
0664:  ANDWF  13,F
0666:  MOVFF  09,14
066A:  MOVFF  13,15
066E:  RCALL  04C2
....................       Sp1 |= cenario[y_ext/8][x_ext];       
0670:  RRCF   0A,W
0672:  MOVWF  00
0674:  RRCF   00,F
0676:  RRCF   00,F
0678:  MOVLW  1F
067A:  ANDWF  00,F
067C:  MOVFF  00,14
0680:  CLRF   16
0682:  MOVFF  00,15
0686:  CLRF   18
0688:  MOVLW  80
068A:  MOVWF  17
068C:  RCALL  05DE
068E:  MOVFF  02,14
0692:  MOVFF  01,13
0696:  MOVF   09,W
0698:  ADDWF  01,W
069A:  MOVWF  01
069C:  MOVLW  00
069E:  ADDWFC 02,W
06A0:  MOVWF  03
06A2:  MOVF   01,W
06A4:  MOVFF  03,FF7
06A8:  RCALL  0004
06AA:  IORWF  11,F
....................       HMF6598_Write_data(Sp1); 
06AC:  MOVFF  11,13
06B0:  RCALL  051E
....................       HMF6598_Gotoxy(x_ext,(y_ext/8)+1);  
06B2:  RRCF   0A,W
06B4:  MOVWF  00
06B6:  RRCF   00,F
06B8:  RRCF   00,F
06BA:  MOVLW  1F
06BC:  ANDWF  00,F
06BE:  MOVF   00,W
06C0:  ADDLW  01
06C2:  MOVWF  13
06C4:  MOVFF  09,14
06C8:  MOVWF  15
06CA:  RCALL  04C2
....................       Sp2 |= cenario[(y_ext/8)+1][x_ext]; 
06CC:  RRCF   0A,W
06CE:  MOVWF  00
06D0:  RRCF   00,F
06D2:  RRCF   00,F
06D4:  MOVLW  1F
06D6:  ANDWF  00,F
06D8:  MOVF   00,W
06DA:  ADDLW  01
06DC:  MOVWF  14
06DE:  CLRF   16
06E0:  MOVWF  15
06E2:  CLRF   18
06E4:  MOVLW  80
06E6:  MOVWF  17
06E8:  RCALL  05DE
06EA:  MOVFF  02,14
06EE:  MOVFF  01,13
06F2:  MOVF   09,W
06F4:  ADDWF  01,W
06F6:  MOVWF  01
06F8:  MOVLW  00
06FA:  ADDWFC 02,W
06FC:  MOVWF  03
06FE:  MOVF   01,W
0700:  MOVFF  03,FF7
0704:  RCALL  0004
0706:  IORWF  12,F
....................       HMF6598_Write_data(Sp2); 
0708:  MOVFF  12,13
070C:  RCALL  051E
....................       x_ext++; 
070E:  INCF   09,F
....................    } 
0710:  INCF   10,F
0712:  BRA    0612
....................    x_ext -= 8; 
0714:  MOVLW  08
0716:  SUBWF  09,F
.................... } 
0718:  RETLW  00
....................  
.................... void main(void){ 
071A:  CLRF   FF8
071C:  BCF    FD0.7
071E:  CLRF   FEA
0720:  CLRF   FE9
0722:  CLRF   04
0724:  CLRF   05
0726:  CLRF   06
0728:  MOVF   FC1,W
072A:  ANDLW  C0
072C:  IORLW  0F
072E:  MOVWF  FC1
0730:  MOVLW  07
0732:  MOVWF  FB4
0734:  CLRF   07
0736:  CLRF   08
....................    int i, j; 
....................    HMF6598_InitLcd(); 
0738:  BRA    0566
....................    // ------ SPRITE DE FUNDO ------- 
....................    for(i=0;i<8;i++){ 
073A:  CLRF   0B
073C:  MOVF   0B,W
073E:  SUBLW  07
0740:  BNC   078A
....................       HMF6598_Gotoxy(0,i); 
0742:  CLRF   14
0744:  MOVFF  0B,15
0748:  RCALL  04C2
....................       for(j=0;j<128;j++){ 
074A:  CLRF   0C
074C:  MOVF   0C,W
074E:  SUBLW  7F
0750:  BNC   0786
....................          HMF6598_Write_data(cenario[i][j]);            
0752:  CLRF   16
0754:  MOVFF  0B,15
0758:  CLRF   18
075A:  MOVLW  80
075C:  MOVWF  17
075E:  RCALL  05DE
0760:  MOVFF  02,0E
0764:  MOVFF  01,0D
0768:  MOVF   0C,W
076A:  ADDWF  01,W
076C:  MOVWF  01
076E:  MOVLW  00
0770:  ADDWFC 02,W
0772:  MOVWF  03
0774:  MOVF   01,W
0776:  MOVFF  03,FF7
077A:  RCALL  0004
077C:  MOVWF  0D
077E:  MOVWF  13
0780:  RCALL  051E
....................          } 
0782:  INCF   0C,F
0784:  BRA    074C
....................    }   
0786:  INCF   0B,F
0788:  BRA    073C
....................    // ----------------------------- 
....................    putSprite(3,3); 
078A:  MOVLW  03
078C:  MOVWF  0E
078E:  MOVWF  0F
0790:  RCALL  05FC
....................    while(true){ 
....................       delay_ms(50); 
0792:  MOVLW  32
0794:  MOVWF  0D
0796:  RCALL  0472
....................       if(!input(pin_D7)){    
0798:  BSF    F95.7
079A:  BTFSC  F83.7
079C:  BRA    086E
....................          putSprite(x_ext+1, y_ext); 
079E:  MOVLW  01
07A0:  ADDWF  09,W
07A2:  MOVWF  0D
07A4:  MOVWF  0E
07A6:  MOVFF  0A,0F
07AA:  RCALL  05FC
....................           
....................          HMF6598_Gotoxy(x_ext-1,(y_ext/8)); 
07AC:  MOVLW  01
07AE:  SUBWF  09,W
07B0:  MOVWF  0D
07B2:  RRCF   0A,W
07B4:  MOVWF  0E
07B6:  RRCF   0E,F
07B8:  RRCF   0E,F
07BA:  MOVLW  1F
07BC:  ANDWF  0E,F
07BE:  MOVFF  0D,14
07C2:  MOVFF  0E,15
07C6:  RCALL  04C2
....................          HMF6598_Write_data(cenario[y_ext/8][x_ext-1]); 
07C8:  RRCF   0A,W
07CA:  MOVWF  00
07CC:  RRCF   00,F
07CE:  RRCF   00,F
07D0:  MOVLW  1F
07D2:  ANDWF  00,F
07D4:  MOVFF  00,0E
07D8:  CLRF   16
07DA:  MOVFF  00,15
07DE:  CLRF   18
07E0:  MOVLW  80
07E2:  MOVWF  17
07E4:  RCALL  05DE
07E6:  MOVFF  02,0E
07EA:  MOVFF  01,0D
07EE:  MOVLW  01
07F0:  SUBWF  09,W
07F2:  ADDWF  01,W
07F4:  MOVWF  01
07F6:  MOVLW  00
07F8:  ADDWFC 02,W
07FA:  MOVWF  03
07FC:  MOVF   01,W
07FE:  MOVFF  03,FF7
0802:  RCALL  0004
0804:  MOVWF  0D
0806:  MOVWF  13
0808:  RCALL  051E
....................          HMF6598_Gotoxy(x_ext-1,(y_ext/8)+1); 
080A:  MOVLW  01
080C:  SUBWF  09,W
080E:  MOVWF  0D
0810:  RRCF   0A,W
0812:  MOVWF  00
0814:  RRCF   00,F
0816:  RRCF   00,F
0818:  MOVLW  1F
081A:  ANDWF  00,F
081C:  MOVF   00,W
081E:  ADDLW  01
0820:  MOVWF  0E
0822:  MOVFF  0D,14
0826:  MOVWF  15
0828:  RCALL  04C2
....................          HMF6598_Write_data(cenario[(y_ext/8)+1][x_ext-1]);          
082A:  RRCF   0A,W
082C:  MOVWF  00
082E:  RRCF   00,F
0830:  RRCF   00,F
0832:  MOVLW  1F
0834:  ANDWF  00,F
0836:  MOVF   00,W
0838:  ADDLW  01
083A:  MOVWF  0E
083C:  CLRF   16
083E:  MOVWF  15
0840:  CLRF   18
0842:  MOVLW  80
0844:  MOVWF  17
0846:  RCALL  05DE
0848:  MOVFF  02,0E
084C:  MOVFF  01,0D
0850:  MOVLW  01
0852:  SUBWF  09,W
0854:  ADDWF  01,W
0856:  MOVWF  01
0858:  MOVLW  00
085A:  ADDWFC 02,W
085C:  MOVWF  03
085E:  MOVF   01,W
0860:  MOVFF  03,FF7
0864:  CALL   0004
0868:  MOVWF  0D
086A:  MOVWF  13
086C:  RCALL  051E
....................       } 
....................       if(!input(pin_D6)){    
086E:  BSF    F95.6
0870:  BTFSC  F83.6
0872:  BRA    08F2
....................          for(i=0;i<8;i++){ 
0874:  CLRF   0B
0876:  MOVF   0B,W
0878:  SUBLW  07
087A:  BNC   08E4
....................             HMF6598_Gotoxy(x_ext+i,(y_ext/8)+1);             
087C:  MOVF   0B,W
087E:  ADDWF  09,W
0880:  MOVWF  0D
0882:  RRCF   0A,W
0884:  MOVWF  00
0886:  RRCF   00,F
0888:  RRCF   00,F
088A:  MOVLW  1F
088C:  ANDWF  00,F
088E:  MOVF   00,W
0890:  ADDLW  01
0892:  MOVWF  0E
0894:  MOVFF  0D,14
0898:  MOVWF  15
089A:  RCALL  04C2
....................             HMF6598_Write_data(cenario[(y_ext/8)+1][x_ext+i]);          
089C:  RRCF   0A,W
089E:  MOVWF  00
08A0:  RRCF   00,F
08A2:  RRCF   00,F
08A4:  MOVLW  1F
08A6:  ANDWF  00,F
08A8:  MOVF   00,W
08AA:  ADDLW  01
08AC:  MOVWF  0E
08AE:  CLRF   16
08B0:  MOVWF  15
08B2:  CLRF   18
08B4:  MOVLW  80
08B6:  MOVWF  17
08B8:  RCALL  05DE
08BA:  MOVFF  02,0E
08BE:  MOVFF  01,0D
08C2:  MOVF   0B,W
08C4:  ADDWF  09,W
08C6:  ADDWF  01,W
08C8:  MOVWF  01
08CA:  MOVLW  00
08CC:  ADDWFC 02,W
08CE:  MOVWF  03
08D0:  MOVF   01,W
08D2:  MOVFF  03,FF7
08D6:  CALL   0004
08DA:  MOVWF  0D
08DC:  MOVWF  13
08DE:  RCALL  051E
....................          } 
08E0:  INCF   0B,F
08E2:  BRA    0876
....................          putSprite(x_ext, y_ext-1); 
08E4:  MOVLW  01
08E6:  SUBWF  0A,W
08E8:  MOVWF  0D
08EA:  MOVFF  09,0E
08EE:  MOVWF  0F
08F0:  RCALL  05FC
....................       } 
....................       if(!input(pin_D5)){   
08F2:  BSF    F95.5
08F4:  BTFSC  F83.5
08F6:  BRA    0972
....................          for(i=0;i<8;i++){ 
08F8:  CLRF   0B
08FA:  MOVF   0B,W
08FC:  SUBLW  07
08FE:  BNC   0964
....................             HMF6598_Gotoxy(x_ext+i,(y_ext/8));             
0900:  MOVF   0B,W
0902:  ADDWF  09,W
0904:  MOVWF  0D
0906:  RRCF   0A,W
0908:  MOVWF  0E
090A:  RRCF   0E,F
090C:  RRCF   0E,F
090E:  MOVLW  1F
0910:  ANDWF  0E,F
0912:  MOVFF  0D,14
0916:  MOVFF  0E,15
091A:  RCALL  04C2
....................             HMF6598_Write_data(cenario[y_ext/8][x_ext+i]);          
091C:  RRCF   0A,W
091E:  MOVWF  00
0920:  RRCF   00,F
0922:  RRCF   00,F
0924:  MOVLW  1F
0926:  ANDWF  00,F
0928:  MOVFF  00,0E
092C:  CLRF   16
092E:  MOVFF  00,15
0932:  CLRF   18
0934:  MOVLW  80
0936:  MOVWF  17
0938:  RCALL  05DE
093A:  MOVFF  02,0E
093E:  MOVFF  01,0D
0942:  MOVF   0B,W
0944:  ADDWF  09,W
0946:  ADDWF  01,W
0948:  MOVWF  01
094A:  MOVLW  00
094C:  ADDWFC 02,W
094E:  MOVWF  03
0950:  MOVF   01,W
0952:  MOVFF  03,FF7
0956:  CALL   0004
095A:  MOVWF  0D
095C:  MOVWF  13
095E:  RCALL  051E
....................          }       
0960:  INCF   0B,F
0962:  BRA    08FA
....................          putSprite(x_ext, y_ext+1); 
0964:  MOVLW  01
0966:  ADDWF  0A,W
0968:  MOVWF  0D
096A:  MOVFF  09,0E
096E:  MOVWF  0F
0970:  RCALL  05FC
....................       } 
....................       if(!input(pin_D4)){    
0972:  BSF    F95.4
0974:  BTFSC  F83.4
0976:  BRA    0A4A
....................          putSprite(x_ext-1, y_ext); 
0978:  MOVLW  01
097A:  SUBWF  09,W
097C:  MOVWF  0D
097E:  MOVWF  0E
0980:  MOVFF  0A,0F
0984:  RCALL  05FC
....................           
....................          HMF6598_Gotoxy(x_ext+8,(y_ext/8)); 
0986:  MOVLW  08
0988:  ADDWF  09,W
098A:  MOVWF  0D
098C:  RRCF   0A,W
098E:  MOVWF  0E
0990:  RRCF   0E,F
0992:  RRCF   0E,F
0994:  MOVLW  1F
0996:  ANDWF  0E,F
0998:  MOVFF  0D,14
099C:  MOVFF  0E,15
09A0:  RCALL  04C2
....................          HMF6598_Write_data(cenario[y_ext/8][x_ext+8]); 
09A2:  RRCF   0A,W
09A4:  MOVWF  00
09A6:  RRCF   00,F
09A8:  RRCF   00,F
09AA:  MOVLW  1F
09AC:  ANDWF  00,F
09AE:  MOVFF  00,0E
09B2:  CLRF   16
09B4:  MOVFF  00,15
09B8:  CLRF   18
09BA:  MOVLW  80
09BC:  MOVWF  17
09BE:  RCALL  05DE
09C0:  MOVFF  02,0E
09C4:  MOVFF  01,0D
09C8:  MOVLW  08
09CA:  ADDWF  09,W
09CC:  ADDWF  01,W
09CE:  MOVWF  01
09D0:  MOVLW  00
09D2:  ADDWFC 02,W
09D4:  MOVWF  03
09D6:  MOVF   01,W
09D8:  MOVFF  03,FF7
09DC:  CALL   0004
09E0:  MOVWF  0D
09E2:  MOVWF  13
09E4:  RCALL  051E
....................          HMF6598_Gotoxy(x_ext+8,(y_ext/8)+1); 
09E6:  MOVLW  08
09E8:  ADDWF  09,W
09EA:  MOVWF  0D
09EC:  RRCF   0A,W
09EE:  MOVWF  00
09F0:  RRCF   00,F
09F2:  RRCF   00,F
09F4:  MOVLW  1F
09F6:  ANDWF  00,F
09F8:  MOVF   00,W
09FA:  ADDLW  01
09FC:  MOVWF  0E
09FE:  MOVFF  0D,14
0A02:  MOVWF  15
0A04:  RCALL  04C2
....................          HMF6598_Write_data(cenario[(y_ext/8)+1][x_ext+8]);            
0A06:  RRCF   0A,W
0A08:  MOVWF  00
0A0A:  RRCF   00,F
0A0C:  RRCF   00,F
0A0E:  MOVLW  1F
0A10:  ANDWF  00,F
0A12:  MOVF   00,W
0A14:  ADDLW  01
0A16:  MOVWF  0E
0A18:  CLRF   16
0A1A:  MOVWF  15
0A1C:  CLRF   18
0A1E:  MOVLW  80
0A20:  MOVWF  17
0A22:  RCALL  05DE
0A24:  MOVFF  02,0E
0A28:  MOVFF  01,0D
0A2C:  MOVLW  08
0A2E:  ADDWF  09,W
0A30:  ADDWF  01,W
0A32:  MOVWF  01
0A34:  MOVLW  00
0A36:  ADDWFC 02,W
0A38:  MOVWF  03
0A3A:  MOVF   01,W
0A3C:  MOVFF  03,FF7
0A40:  CALL   0004
0A44:  MOVWF  0D
0A46:  MOVWF  13
0A48:  RCALL  051E
....................       }       
....................    } 
0A4A:  BRA    0792
....................    //int i, j; 
....................    /* HMF6598_Gotoxy(0,0);    
....................    printf(HMF6598_Printchar, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");    
....................    */ 
....................    /*for(i=0;i<8;i++){ 
....................       HMF6598_Gotoxy(0,i); 
....................       for(j=0;j<128;j++){ 
....................          HMF6598_Write_data(cenario[i][j]);            
....................          } 
....................    }*/ 
....................     
.................... } 
0A4C:  SLEEP 

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV20 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICPRT NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
