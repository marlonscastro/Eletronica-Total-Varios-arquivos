#include <16F876.h>
#device adc=10
#FUSES NOWDT, HS, NOPUT, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NODEBUG, NOPROTECT
#use delay(clock=16000000)

BYTE const font5x8[128][5] = {
  0x00,0x00,0x00,0x00,0x00,   // 20 space 
  0x00,0x00,0x5f,0x00,0x00,   // 21 !
  0x00,0x07,0x00,0x07,0x00,   // 22 "
  0x14,0x7f,0x14,0x7f,0x14,   // 23 #
  0x24,0x2a,0x7f,0x2a,0x12,   // 24 $
  0x23,0x13,0x08,0x64,0x62,   // 25 %
  0x36,0x49,0x55,0x22,0x50,   // 26 &
  0x00,0x05,0x03,0x00,0x00,   // 27 '
  0x00,0x1c,0x22,0x41,0x00,   // 28 (
  0x00,0x41,0x22,0x1c,0x00,   // 29 )
  0x14,0x08,0x3e,0x08,0x14,   // 2a *
  0x08,0x08,0x3e,0x08,0x08,   // 2b +
  0x00,0x50,0x30,0x00,0x00,   // 2c ,
  0x08,0x08,0x08,0x08,0x08,   // 2d -
  0x00,0x60,0x60,0x00,0x00,   // 2e .
  0x20,0x10,0x08,0x04,0x02,   // 2f /
  0x3e,0x51,0x49,0x45,0x3e,   // 30 0
  0x00,0x42,0x7f,0x40,0x00,   // 31 1
  0x42,0x61,0x51,0x49,0x46,   // 32 2
  0x21,0x41,0x45,0x4b,0x31,   // 33 3
  0x18,0x14,0x12,0x7f,0x10,   // 34 4
  0x27,0x45,0x45,0x45,0x39,   // 35 5
  0x3c,0x4a,0x49,0x49,0x30,   // 36 6
  0x01,0x71,0x09,0x05,0x03,   // 37 7
  0x36,0x49,0x49,0x49,0x36,   // 38 8
  0x06,0x49,0x49,0x29,0x1e,   // 39 9
  0x00,0x36,0x36,0x00,0x00,   // 3a :
  0x00,0x56,0x36,0x00,0x00,   // 3b ;
  0x08,0x14,0x22,0x41,0x00,   // 3c <
  0x14,0x14,0x14,0x14,0x14,   // 3d =
  0x00,0x41,0x22,0x14,0x08,   // 3e >
  0x02,0x01,0x51,0x09,0x06,   // 3f ?
  0x32,0x49,0x79,0x41,0x3e,   // 40 @
  0x7e,0x11,0x11,0x11,0x7e,   // 41 A
  0x7f,0x49,0x49,0x49,0x36,   // 42 B
  0x3e,0x41,0x41,0x41,0x22,   // 43 C
  0x7f,0x41,0x41,0x22,0x1c,   // 44 D
  0x7f,0x49,0x49,0x49,0x41,   // 45 E
  0x7f,0x09,0x09,0x09,0x01,   // 46 F
  0x3e,0x41,0x49,0x49,0x7a,   // 47 G
  0x7f,0x08,0x08,0x08,0x7f,   // 48 H
  0x00,0x41,0x7f,0x41,0x00,   // 49 I
  0x20,0x40,0x41,0x3f,0x01,   // 4a J
  0x7f,0x08,0x14,0x22,0x41,   // 4b K
  0x7f,0x40,0x40,0x40,0x40,   // 4c L
  0x7f,0x02,0x0c,0x02,0x7f,   // 4d M
  0x7f,0x04,0x08,0x10,0x7f,   // 4e N
  0x3e,0x41,0x41,0x41,0x3e,   // 4f O
  0x7f,0x09,0x09,0x09,0x06,   // 50 P
  0x3e,0x41,0x51,0x21,0x5e,   // 51 Q
  0x7f,0x09,0x19,0x29,0x46,   // 52 R
  0x46,0x49,0x49,0x49,0x31,   // 53 S
  0x01,0x01,0x7f,0x01,0x01,   // 54 T
  0x3f,0x40,0x40,0x40,0x3f,   // 55 U
  0x1f,0x20,0x40,0x20,0x1f,   // 56 V
  0x3f,0x40,0x38,0x40,0x3f,   // 57 W
  0x63,0x14,0x08,0x14,0x63,   // 58 X
  0x07,0x08,0x70,0x08,0x07,   // 59 Y
  0x61,0x51,0x49,0x45,0x43,   // 5a Z
  0x00,0x7f,0x41,0x41,0x00,   // 5b [
  0x02,0x04,0x08,0x10,0x20,   // 5c
  0x00,0x41,0x41,0x7f,0x00,   // 5d
  0x04,0x02,0x01,0x02,0x04,   // 5e
  0x40,0x40,0x40,0x40,0x40,   // 5f
  0x00,0x01,0x02,0x04,0x00,   // 60
  0x20,0x54,0x54,0x54,0x78,   // 61 a
  0x7f,0x48,0x44,0x44,0x38,   // 62 b
  0x38,0x44,0x44,0x44,0x20,   // 63 c
  0x38,0x44,0x44,0x48,0x7f,   // 64 d
  0x38,0x54,0x54,0x54,0x18,   // 65 e
  0x08,0x7e,0x09,0x01,0x02,   // 66 f
  0x0c,0x52,0x52,0x52,0x3e,   // 67 g
  0x7f,0x08,0x04,0x04,0x78,   // 68 h
  0x00,0x44,0x7d,0x40,0x00,   // 69 i
  0x20,0x40,0x44,0x3d,0x00,   // 6a j
  0x7f,0x10,0x28,0x44,0x00,   // 6b k
  0x00,0x41,0x7f,0x40,0x00,   // 6c l
  0x7c,0x04,0x18,0x04,0x78,   // 6d m
  0x7c,0x08,0x04,0x04,0x78,   // 6e n
  0x38,0x44,0x44,0x44,0x38,   // 6f o
  0x7c,0x14,0x14,0x14,0x08,   // 70 p
  0x08,0x14,0x14,0x18,0x7c,   // 71 q
  0x7c,0x08,0x04,0x04,0x08,   // 72 r
  0x48,0x54,0x54,0x54,0x20,   // 73 s
  0x04,0x3f,0x44,0x40,0x20,   // 74 t
  0x3c,0x40,0x40,0x20,0x7c,   // 75 u
  0x1c,0x20,0x40,0x20,0x1c,   // 76 v
  0x3c,0x40,0x30,0x40,0x3c,   // 77 w
  0x44,0x28,0x10,0x28,0x44,   // 78 x
  0x0c,0x50,0x50,0x50,0x3c,   // 79 y
  0x44,0x64,0x54,0x4c,0x44,   // 7a z
  0x00,0x08,0x36,0x41,0x00,   // 7b
  0x00,0x00,0x7f,0x00,0x00,   // 7c
  0x00,0x41,0x36,0x08,0x00,   // 7d
  0x10,0x08,0x08,0x10,0x08,   // 7e
  0x78,0x46,0x41,0x46,0x78    // 7f
};

#define LED_STATUS   pin_a1
#define DATA_164     pin_c4
#define SCK_164      pin_c3
#define LATCH_595    pin_c2
#define DATA_595     pin_c6
#define SCK_595      pin_c5
#define ON           1
#define OFF          0

int tempo;
int x_obj = 3, y_obj = 3;
//int XX = 0, YY = 0;
char MAT[96] = {
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x3b,0xff,0xf0,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,                
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
               };
               
// PROTÓTIPOS DAS FUNÇÕES 
void write_col(char var);              // OK
void varre_coluna();                   // OK
void clearscreen();                    // OK
void put_led(int x, int y, int COLOR); // OK
void put_char(int x, char cvar);       // OK
void putstr(int x, char* text);        // OK
void mydelay(long time_ms);            // OK

#int_TIMER0
void  TIMER0_isr(void){
   tempo++;
   if(tempo == 20){
      tempo=0;
      output_toggle(LED_STATUS);
   }
   /*if((tempo%5) == 0){
      disable_interrupts(INT_RB);      
   } else    enable_interrupts(INT_RB);*/
   varre_coluna();    
}
#int_RB
void rb_isr(void){
   if(!input(pin_b7)){
      if(y_obj>0){    
         bit_clear(MAT[x_obj], y_obj); 
         bit_clear(MAT[x_obj-1], y_obj);             
         y_obj--;
         bit_set(MAT[x_obj], y_obj); 
         bit_set(MAT[x_obj-1], y_obj);            
      }
   }  
   if(!input(pin_b6)){
      if(x_obj>0){    
         bit_clear(MAT[x_obj], y_obj); 
         bit_clear(MAT[x_obj-1], y_obj);             
         x_obj--;
         bit_set(MAT[x_obj], y_obj); 
         bit_set(MAT[x_obj-1], y_obj);            
      }
   }  
   if(!input(pin_b5)){
      if(x_obj<31){    
         bit_clear(MAT[x_obj], y_obj); 
         bit_clear(MAT[x_obj-1], y_obj);             
         x_obj++;
         bit_set(MAT[x_obj], y_obj); 
         bit_set(MAT[x_obj-1], y_obj);            
      }
   }  
   if(!input(pin_b4)){
      if(y_obj<6){    
         bit_clear(MAT[x_obj], y_obj); 
         bit_clear(MAT[x_obj-1], y_obj);             
         y_obj++;
         bit_set(MAT[x_obj], y_obj); 
         bit_set(MAT[x_obj-1], y_obj);            
      }
   }   
}

// Faz a varredura das coluna uma a uma da 1a a 32a;
void varre_coluna(){
   int i;
   int32 chr = 1;
   for(i=0;i<32;i++){
      write_col(MAT[i]);
      output_low(SCK_164);
      if((chr&0x01) == 0) output_low(DATA_164);
      else output_high(DATA_164);
      output_high(SCK_164);
      chr=chr>>1;
      delay_us(500);
   }
   output_low(DATA_164);
}

// Função que escreve os dados da Matriz MAT[] na coluna especificada
void write_col(char colData){
   int i;
   for(i=0;i<8;i++){
      output_low(SCK_595);
      if((colData&0x01) == 0) output_low(DATA_595);
      else output_high(DATA_595);
      output_high(SCK_595);
      colData=colData>>1;
   }
   output_low(LATCH_595);  
   output_high(LATCH_595);
}

void clearscreen(){
   int i;
   for(i=0;i<96;i++)
      MAT[i] = 0x00;
}

void put_char(int x, char cvar){
  int i;
  char c;
  if ((cvar<0x20) || (cvar>0x7F)) return;
  for (i=0;i<5;i++){
    c=font5x8[((cvar&0xff)-0x20)][i];
    if((c!=0x00) || (cvar==0x20)){     
       MAT[x]=c;
       x++;
    }
  }
  MAT[x]=0x00;
}

void putstr(int x, char* text){
   int i = 0;
   while (text[i]!=0){   
      put_char(x+(i*6),text[i]);
      i++;               
   }
}

void mydelay(long time_ms){
   delay_ms(time_ms/1000*60);
}

void put_led(int x, int y, int COLOR){
   if(COLOR == ON)
      bit_set(MAT[x], y);
   else
      bit_clear(MAT[x], y);      
}

void main(){
   int i, j, n=32;
   long var=0;
   char txt[10]; 
   setup_timer_0(RTCC_INTERNAL|RTCC_DIV_64|RTCC_8_bit);
   setup_adc_ports(NO_ANALOGS);
   setup_adc(ADC_OFF);
   enable_interrupts(INT_TIMER0);
   enable_interrupts(INT_RB);
   enable_interrupts(GLOBAL);

   /* INICIO DO GAME R-TYPE Led */
   bit_set(MAT[x_obj], y_obj);      
   bit_set(MAT[x_obj-1], y_obj);   
   while(true){
      for(i=x_obj+1;i<32;i++){
         put_led(i, y_obj, ON);
         if(i>(x_obj+1))
            put_led(i-1, y_obj, OFF);               
         delay_us(400);
         // Piscar Cauda : Chamas da nave
         if((i%3) == 0){
            bit_clear(MAT[x_obj-1], y_obj);            
         }
         else                 
            bit_set(MAT[x_obj-1], y_obj);
      }
   }
}
