CCS PCM C Compiler, Version 4.074, 10898               13-abr-10 18:57

               Filename: index.lst

               ROM used: 426 words (5%)
                         Largest free fragment is 2048
               RAM used: 30 (8%) at main() level
                         49 (13%) worst case
               Stack:    5 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   15C
0003:  NOP
.................... #include <16f877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #use delay(clock=4000000) 
*
0021:  MOVLW  42
0022:  MOVWF  04
0023:  BCF    03.7
0024:  MOVF   00,W
0025:  BTFSC  03.2
0026:  GOTO   035
0027:  MOVLW  01
0028:  MOVWF  78
0029:  CLRF   77
002A:  DECFSZ 77,F
002B:  GOTO   02A
002C:  DECFSZ 78,F
002D:  GOTO   029
002E:  MOVLW  4A
002F:  MOVWF  77
0030:  DECFSZ 77,F
0031:  GOTO   030
0032:  GOTO   033
0033:  DECFSZ 00,F
0034:  GOTO   027
0035:  RETLW  00
.................... #fuses HS,NOWDT,PUT 
.................... #use rs232(baud=4800, xmit=PIN_C6,rcv=PIN_C7) 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_lcd TRUE 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
....................  
.................... #if defined use_portb_lcd 
....................    //#locate lcd = getenv("sfr:PORTB")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf81 
....................    #else 
....................     #locate lcd = 6 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    //#locate lcd = getenv("sfr:PORTD")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf83 
....................    #else 
....................     #locate lcd = 8 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... #ifndef lcd_type 
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
*
0043:  MOVLW  F0
0044:  BSF    03.5
0045:  MOVWF  08
....................       lcd.rw = 1; 
0046:  BCF    03.5
0047:  BSF    08.2
....................       delay_cycles(1); 
0048:  NOP
....................       lcd.enable = 1; 
0049:  BSF    08.0
....................       delay_cycles(1); 
004A:  NOP
....................       high = lcd.data; 
004B:  MOVF   08,W
004C:  SWAPF  08,W
004D:  ANDLW  0F
004E:  MOVWF  49
....................       lcd.enable = 0; 
004F:  BCF    08.0
....................       delay_cycles(1); 
0050:  NOP
....................       lcd.enable = 1; 
0051:  BSF    08.0
....................       delay_us(1); 
0052:  NOP
....................       low = lcd.data; 
0053:  MOVF   08,W
0054:  SWAPF  08,W
0055:  ANDLW  0F
0056:  MOVWF  48
....................       lcd.enable = 0; 
0057:  BCF    08.0
....................       set_tris_lcd(LCD_WRITE); 
0058:  MOVLW  00
0059:  BSF    03.5
005A:  MOVWF  08
....................       return( (high<<4) | low); 
005B:  BCF    03.5
005C:  SWAPF  49,W
005D:  MOVWF  77
005E:  MOVLW  F0
005F:  ANDWF  77,F
0060:  MOVF   77,W
0061:  IORWF  48,W
0062:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
0036:  SWAPF  49,W
0037:  ANDLW  F0
0038:  MOVWF  77
0039:  MOVLW  0F
003A:  ANDWF  08,W
003B:  IORWF  77,W
003C:  MOVWF  08
....................       delay_cycles(1); 
003D:  NOP
....................       lcd.enable = 1; 
003E:  BSF    08.0
....................       delay_us(2); 
003F:  GOTO   040
....................       lcd.enable = 0; 
0040:  BCF    08.0
.................... } 
0041:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
0042:  BCF    08.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
0063:  MOVF   78,W
0064:  MOVWF  48
0065:  BTFSC  48.7
0066:  GOTO   043
....................       lcd.rs = address; 
0067:  BTFSS  46.0
0068:  BCF    08.1
0069:  BTFSC  46.0
006A:  BSF    08.1
....................       delay_cycles(1); 
006B:  NOP
....................       lcd.rw = 0; 
006C:  BCF    08.2
....................       delay_cycles(1); 
006D:  NOP
....................       lcd.enable = 0; 
006E:  BCF    08.0
....................       lcd_send_nibble(n >> 4); 
006F:  SWAPF  47,W
0070:  MOVWF  48
0071:  MOVLW  0F
0072:  ANDWF  48,F
0073:  MOVF   48,W
0074:  MOVWF  49
0075:  CALL   036
....................       lcd_send_nibble(n & 0xf); 
0076:  MOVF   47,W
0077:  ANDLW  0F
0078:  MOVWF  48
0079:  MOVWF  49
007A:  CALL   036
.................... } 
007B:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
007C:  MOVLW  00
007D:  BSF    03.5
007E:  MOVWF  08
....................     lcd.rs = 0; 
007F:  BCF    03.5
0080:  BCF    08.1
....................     lcd.rw = 0; 
0081:  BCF    08.2
....................     lcd.enable = 0; 
0082:  BCF    08.0
....................     delay_ms(15); 
0083:  MOVLW  0F
0084:  MOVWF  42
0085:  CALL   021
....................     for(i=1;i<=3;++i) { 
0086:  MOVLW  01
0087:  MOVWF  38
0088:  MOVF   38,W
0089:  SUBLW  03
008A:  BTFSS  03.0
008B:  GOTO   094
....................        lcd_send_nibble(3); 
008C:  MOVLW  03
008D:  MOVWF  49
008E:  CALL   036
....................        delay_ms(5); 
008F:  MOVLW  05
0090:  MOVWF  42
0091:  CALL   021
....................     } 
0092:  INCF   38,F
0093:  GOTO   088
....................     lcd_send_nibble(2); 
0094:  MOVLW  02
0095:  MOVWF  49
0096:  CALL   036
....................     for(i=0;i<=3;++i) 
0097:  CLRF   38
0098:  MOVF   38,W
0099:  SUBLW  03
009A:  BTFSS  03.0
009B:  GOTO   0A5
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
009C:  MOVF   38,W
009D:  CALL   004
009E:  MOVWF  39
009F:  CLRF   46
00A0:  MOVF   39,W
00A1:  MOVWF  47
00A2:  CALL   042
00A3:  INCF   38,F
00A4:  GOTO   098
.................... } 
00A5:  BCF    0A.3
00A6:  BCF    0A.4
00A7:  GOTO   191 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
00A8:  DECFSZ 43,W
00A9:  GOTO   0AB
00AA:  GOTO   0AE
....................      address=lcd_line_two; 
00AB:  MOVLW  40
00AC:  MOVWF  44
....................    else 
00AD:  GOTO   0AF
....................      address=0; 
00AE:  CLRF   44
....................    address+=x-1; 
00AF:  MOVLW  01
00B0:  SUBWF  42,W
00B1:  ADDWF  44,F
....................    lcd_send_byte(0,0x80|address); 
00B2:  MOVF   44,W
00B3:  IORLW  80
00B4:  MOVWF  45
00B5:  CLRF   46
00B6:  MOVF   45,W
00B7:  MOVWF  47
00B8:  CALL   042
.................... } 
00B9:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
00BA:  MOVF   41,W
00BB:  XORLW  0C
00BC:  BTFSC  03.2
00BD:  GOTO   0C5
00BE:  XORLW  06
00BF:  BTFSC  03.2
00C0:  GOTO   0CD
00C1:  XORLW  02
00C2:  BTFSC  03.2
00C3:  GOTO   0D3
00C4:  GOTO   0D8
....................      case '\f'   : lcd_send_byte(0,1); 
00C5:  CLRF   46
00C6:  MOVLW  01
00C7:  MOVWF  47
00C8:  CALL   042
....................                    delay_ms(2); 
00C9:  MOVLW  02
00CA:  MOVWF  42
00CB:  CALL   021
....................                                            break; 
00CC:  GOTO   0DE
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
00CD:  MOVLW  01
00CE:  MOVWF  42
00CF:  MOVLW  02
00D0:  MOVWF  43
00D1:  CALL   0A8
00D2:  GOTO   0DE
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
00D3:  CLRF   46
00D4:  MOVLW  10
00D5:  MOVWF  47
00D6:  CALL   042
00D7:  GOTO   0DE
....................      default     : lcd_send_byte(1,c);     break; 
00D8:  MOVLW  01
00D9:  MOVWF  46
00DA:  MOVF   41,W
00DB:  MOVWF  47
00DC:  CALL   042
00DD:  GOTO   0DE
....................    } 
.................... } 
00DE:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
016F:  BCF    03.5
0170:  CLRF   20
0171:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#include <usart.c> 
....................    char k; 
....................    long int i = 0; 
0172:  CLRF   23
0173:  CLRF   24
....................    char arg[7] = {'$', 'G', 'P', 'R', 'M', 'C'};      
0174:  MOVLW  24
0175:  MOVWF  25
0176:  MOVLW  47
0177:  MOVWF  26
0178:  MOVLW  50
0179:  MOVWF  27
017A:  MOVLW  52
017B:  MOVWF  28
017C:  MOVLW  4D
017D:  MOVWF  29
017E:  MOVLW  43
017F:  MOVWF  2A
0180:  CLRF   2B
.................... void split(char caracter, int ind, char *retorno, char *str){ 
....................    int tam, i, x, cont, p; 
....................    tam = strlen(str); 
....................    x = cont = 0; 
....................    for (i = 0; i < tam; i++){ 
....................       if(ind == 0){ 
....................          if(caracter != str[i]){ 
....................             retorno[x] = str[i]; 
....................             x++; 
....................          } 
....................          else break; 
....................       } 
....................       else{ 
....................          if (caracter == str[i]){ 
....................             cont++; 
....................             if(cont == ind){ 
....................                p = i + 1; 
....................                while(true){ 
....................                   if(str[p] != caracter){ 
....................                      retorno[x] = str[p]; 
....................                      p++; 
....................                      x++; 
....................                   } 
....................                   else 
....................                      break; 
....................                } 
....................             } 
....................             if(cont > ind) 
....................                break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... void recebe_rs232(char *mat){ 
....................    int x = 0; 
....................    while(x < 70){ 
....................       k = getc(); 
....................       if(k == arg[i]) 
....................          i++; 
....................       if(i > 5){ 
....................          i = 0; 
....................          mat[i] = k; 
....................           
....................       } 
....................       x++; 
....................    } 
.................... } 
....................  
.................... void pressRb(){ 
....................    printf(lcd_putc, "funcao executada"); 
*
0144:  CLRF   38
0145:  MOVF   38,W
0146:  CALL   00C
0147:  INCF   38,F
0148:  MOVWF  77
0149:  MOVWF  41
014A:  CALL   0BA
014B:  MOVLW  10
014C:  SUBWF  38,W
014D:  BTFSS  03.2
014E:  GOTO   145
....................    delay_ms(1000); 
014F:  MOVLW  04
0150:  MOVWF  38
0151:  MOVLW  FA
0152:  MOVWF  42
0153:  CALL   021
0154:  DECFSZ 38,F
0155:  GOTO   151
....................    lcd_putc('\f');    
0156:  MOVLW  0C
0157:  MOVWF  41
0158:  CALL   0BA
.................... } 
0159:  BCF    0A.3
015A:  BCF    0A.4
015B:  GOTO   1A2 (RETURN)
....................  
.................... void main(){ 
015C:  CLRF   04
015D:  BCF    03.7
015E:  MOVLW  1F
015F:  ANDWF  03,F
0160:  MOVLW  0C
0161:  BSF    03.5
0162:  MOVWF  19
0163:  MOVLW  A2
0164:  MOVWF  18
0165:  MOVLW  90
0166:  BCF    03.5
0167:  MOVWF  18
0168:  BSF    03.5
0169:  BSF    1F.0
016A:  BSF    1F.1
016B:  BSF    1F.2
016C:  BCF    1F.3
016D:  MOVLW  07
016E:  MOVWF  1C
....................    char vet[10] = {'9', '9', '9', '9', '.', '9', '9', '2', '6', '\0'}; 
*
0181:  MOVLW  39
0182:  MOVWF  2C
0183:  MOVWF  2D
0184:  MOVWF  2E
0185:  MOVWF  2F
0186:  MOVLW  2E
0187:  MOVWF  30
0188:  MOVLW  39
0189:  MOVWF  31
018A:  MOVWF  32
018B:  MOVLW  32
018C:  MOVWF  33
018D:  MOVLW  36
018E:  MOVWF  34
018F:  CLRF   35
....................    int x, valor; 
....................    lcd_init(); 
0190:  GOTO   07C
....................    while(true){ 
....................       lcd_gotoxy(1,1); 
0191:  MOVLW  01
0192:  MOVWF  42
0193:  MOVWF  43
0194:  CALL   0A8
....................       printf(lcd_putc, "%lu", i); 
0195:  MOVLW  10
0196:  MOVWF  04
0197:  MOVF   24,W
0198:  MOVWF  39
0199:  MOVF   23,W
019A:  MOVWF  38
019B:  GOTO   0DF
....................       if(!input(pin_B5)) 
019C:  BSF    03.5
019D:  BSF    06.5
019E:  BCF    03.5
019F:  BTFSC  06.5
01A0:  GOTO   1A2
....................          pressRb(); 
01A1:  GOTO   144
....................       delay_ms(30); 
01A2:  MOVLW  1E
01A3:  MOVWF  42
01A4:  CALL   021
....................       i++; 
01A5:  INCF   23,F
01A6:  BTFSC  03.2
01A7:  INCF   24,F
....................    } 
01A8:  GOTO   191
....................     
.................... } 
....................  
.................... /* 
.................... #use rs232(baud=9600, xmit = PIN_C6, rcv = PIN_C7, parity = N, bits = 8, errors) 
....................  
.................... Int pacote[10]; 
....................  
.................... void main() 
.................... { 
.................... enable_interrupts(global); 
.................... enable_interrupts(int_rda); 
.................... While(1) 
.................... { 
.................... Escreve seu código……..... 
.................... Escreve seu código……..... 
.................... } 
.................... } 
....................  
....................  
.................... #INT_RDA 
.................... void Void Receber_RS232() 
.................... { 
.................... pacote[i++]=getc(); 
.................... printf (lcd_escreve,"%c",pacote[i]); //escreve no lcd o que recebeu 
.................... //– depende da sua configuração de lcd 
.................... }  
.................... */ 
....................  
....................  
....................  
.................... /* 
.................... void main(){ 
....................    char mat[80]; 
....................    char ret[10]; 
....................  
....................    lcd_init(); 
....................  
....................    while(true){ 
....................       k=getc(); 
....................       if(k == arg[i]) 
....................          i++; 
....................       else 
....................          if (i > 0) 
....................             i--; 
....................       if(i > 5){ 
....................          i = 0; 
....................          lcd_putc('\f'); 
....................          recebe_rs232(mat); 
....................          split(',', 4, ret, mat); 
....................          k = ret[0];       
....................          split(',', 3, ret, mat);       
....................          printf(lcd_putc,"LT: %s  %c",ret, k); 
....................           
....................          split(',', 6, ret, mat); 
....................          k = ret[0]; 
....................          split(',', 5, ret, mat); 
....................          printf(lcd_putc,"\r\nLG: %s %c",ret, k); 
....................       } 
....................    }  
.................... } 
.................... */ 
01A9:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
